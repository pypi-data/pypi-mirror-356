
# Generated by CodiumAI

import pytest

from marc21 import SubField, MarcException


class TestSubField:

    #  Creating a new SubField object with valid tag and value should be successful.
    def test_valid_tag_and_value(self):
        # Given
        tag = 'a'
        repeatable = True
        description = ''
        value = 'John Smith'

        # When
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # Then
        assert subfield.tag == tag
        assert subfield.repeatable == repeatable
        assert subfield.description == description
        assert subfield.value == value

    #  Creating a new SubField object with valid tag, value and description should be successful.
    def test_valid_tag_value_and_description(self):
        # Given
        tag = 'a'
        repeatable = True
        description = 'Author'
        value = 'John Smith'

        # When
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # Then
        assert subfield.tag == tag
        assert subfield.repeatable == repeatable
        assert subfield.description == description
        assert subfield.value == value

    #  Calling __repr__() method on a SubField object should return a string representation of the object.
    def test_repr_method(self):
        # Given
        tag = 'a'
        repeatable = True
        description = 'Author'
        value = 'John Smith'
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # When
        result = subfield.__repr__(show_description=True)

        # Then
        assert result == 'a [Author] John Smith'

    #  Calling __copy__() method on a SubField object should return a new SubField object with the same attributes.
    def test_copy_method(self):
        # Given
        tag = 'a'
        repeatable = True
        description = 'Author'
        value = 'John Smith'
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # When
        copy_subfield = subfield.__copy__()

        # Then
        assert copy_subfield.tag == subfield.tag
        assert copy_subfield.repeatable == subfield.repeatable
        assert copy_subfield.description == subfield.description
        assert copy_subfield.value == subfield.value

    #  Comparing two SubField objects with the same attributes should return True.
    def test_equality_operator(self):
        # Given
        tag = 'a'
        repeatable = True
        description = 'Author'
        value = 'John Smith'
        subfield1 = SubField(tag=tag, repeatable=repeatable, description=description, value=value)
        subfield2 = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # When
        result = subfield1 == subfield2

        # Then
        assert result is True

    #  Creating a new SubField object with an empty tag should raise a MarcException.
    def test_empty_tag(self):
        # Given
        tag = ''
        repeatable = True
        description = 'Author'
        value = 'John Smith'

        # When/Then
        with pytest.raises(MarcException):
            SubField(tag=tag, repeatable=repeatable, description=description, value=value)

    #  Creating a new SubField object with an empty value should raise a MarcException.
    def test_empty_value(self):
        # Given
        tag = 'a'
        repeatable = True
        description = 'Author'
        value = ''

        # When/Then
        with pytest.raises(MarcException):
            SubField(tag=tag, repeatable=repeatable, description=description, value=value)


    #  Creating a SubField object with repeatable set to True should set the repeatable attribute to True.
    def test_repeatable_true(self):
        # Given
        tag = 'A'
        repeatable = True

        # When
        subfield = SubField(tag, repeatable)

        # Then
        assert subfield.repeatable == repeatable

    #  Creating a SubField object with repeatable set to False should set the repeatable attribute to False.
    def test_repeatable_false(self):
        # Given
        tag = 'A'
        repeatable = False

        # When
        subfield = SubField(tag, repeatable)

        # Then
        assert subfield.repeatable == repeatable

    #  Creating a SubField object with a description should set the description attribute to the given value.
    def test_with_description(self):
        # Given
        tag = 'A'
        repeatable = True
        description = 'Example subfield'

        # When
        subfield = SubField(tag, repeatable, description)

        # Then
        assert subfield.description == description

    #  Creating a SubField object without a description should set the description attribute to an empty string.
    def test_without_description(self):
        # Given
        tag = 'A'
        repeatable = True

        # When
        subfield = SubField(tag, repeatable)

        # Then
        assert subfield.description == ''

    #  Creating a SubField object with a value should set the value attribute to the given value.
    def test_with_value(self):
        # Given
        tag = 'A'
        repeatable = True
        value = 'example value'

        # When
        subfield = SubField(tag, repeatable, value=value)

        # Then
        assert subfield.value == value

    #  Creating a SubField object without a tag should raise a MarcException.
    def test_without_tag(self):
        # Given
        tag = ''
        repeatable = True

        # When, Then
        with pytest.raises(MarcException):
            SubField(tag, repeatable)

    #  Creating a SubField object without a value should raise a MarcException.
    def test_without_value(self):
        # Given
        tag = 'A'
        repeatable = True
        value = ''

        # When, Then
        with pytest.raises(MarcException):
            SubField(tag, repeatable, value=value)

    #  Creating a SubField object with a tag longer than 1 character should initialize the tag attribute correctly.
    def test_long_tag(self):
        # Given
        tag = 'ABC'
        repeatable = True

        # When
        subfield = SubField(tag, repeatable)

        # Then
        assert subfield.tag == tag

    def test_tag_and_value_concatenated_if_show_description_is_false(self):
        # Given
        tag = 'a'
        repeatable = True
        description = ''
        value = 'John Smith'
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # When
        result = subfield.__repr__(show_description=False)

        # Then
        assert result == 'aJohn Smith'

    def test_special_characters_handled_in_tag_description_and_value(self):
        # Given
        tag = '!@#$%^&*()'
        repeatable = True
        description = '!@#$%^&*()'
        value = '!@#$%^&*()'
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # When
        result = subfield.__repr__(show_description=True)

        # Then
        assert result == '!@#$%^&*() [!@#$%^&*()] !@#$%^&*()'

    def test_long_strings_handled_in_tag_description_and_value(self):
        # Given
        tag = 'a' * 1000
        repeatable = True
        description = 'b' * 1000
        value = 'c' * 1000
        subfield = SubField(tag=tag, repeatable=repeatable, description=description, value=value)

        # When
        result = subfield.__repr__(show_description=True)

        # Then
        assert result == f'{tag} [{description}] {value}'

