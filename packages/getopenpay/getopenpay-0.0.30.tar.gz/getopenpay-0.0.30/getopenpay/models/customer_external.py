# coding: utf-8

"""
    OpenPay API

    super charge your subscription management.

    The version of the OpenAPI document: 1.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import datetime
from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from getopenpay.models.complete_address import CompleteAddress
from getopenpay.models.customer_balance_external import CustomerBalanceExternal
from getopenpay.models.customer_invoice_settings import CustomerInvoiceSettings
from getopenpay.models.customer_language import CustomerLanguage
from getopenpay.models.customer_status import CustomerStatus
from getopenpay.models.customer_total_amount import CustomerTotalAmount
from getopenpay.models.discount_external import DiscountExternal
from getopenpay.models.object_name import ObjectName
from getopenpay.models.product_external import ProductExternal
from getopenpay.models.subscription_external import SubscriptionExternal
from typing import Optional, Set
from typing_extensions import Self

class CustomerExternal(BaseModel):
    """
    CustomerExternal
    """ # noqa: E501
    account_id: StrictStr = Field(description="Unique identifier for the account.")
    address: Optional[CompleteAddress]
    balance_atoms: Optional[List[CustomerBalanceExternal]] = Field(default=None, description="List of the customer's balance in the smallest unit of currency (e.g., cents for USD). Positive values indicate the amount owed by the customer, to be applied to the next invoice. Negative values represent credit to apply to future invoices.")
    billing_email: Optional[StrictStr] = None
    business_name: Optional[StrictStr]
    created_at: datetime = Field(description="DateTime at which the object was created, in 'ISO 8601' format.")
    custom_fields: Optional[Dict[str, Any]] = None
    customer_billing_address: Optional[CompleteAddress] = None
    discount: Optional[DiscountExternal] = None
    email: StrictStr = Field(description="Customer's email address.")
    first_name: Optional[StrictStr]
    id: StrictStr = Field(description="Unique identifier of the customer.")
    invoice_settings: Optional[CustomerInvoiceSettings] = None
    is_deleted: Optional[StrictBool] = Field(default=False, description="If true, indicates that this object has been deleted")
    language: Optional[CustomerLanguage] = Field(default=None, description="Language of the customer.")
    last_name: Optional[StrictStr]
    last_successful_payment_intent: Optional[PaymentIntentExternal] = None
    metadata: Optional[Dict[str, Any]] = None
    mrr: Optional[List[CustomerTotalAmount]] = Field(default=None, description="The monthly recurring revenue of the customer broken down by currency.")
    notes: Optional[StrictStr]
    object: Optional[ObjectName] = None
    phone_number: Optional[StrictStr] = None
    shipping_addresses: Optional[List[CompleteAddress]] = Field(default=None, description="List of customer's shipping addresses.")
    should_send_payment_receipt: StrictBool = Field(description="Whether email should be sent or not on payment.")
    status: Optional[CustomerStatus] = None
    subscribed_to_products: Optional[List[ProductExternal]] = Field(default=None, description="List of products that the customer is subscribed to.")
    subscriptions: Optional[List[SubscriptionExternal]] = Field(default=None, description="List of customer's subscriptions.")
    total_refunds: Optional[List[CustomerTotalAmount]] = Field(default=None, description="The total amount refunded to the customer.")
    total_spent: Optional[List[CustomerTotalAmount]] = Field(default=None, description="The total amount spent by the customer.")
    updated_at: datetime = Field(description="DateTime at which the object was updated, in 'ISO 8601' format.")
    __properties: ClassVar[List[str]] = ["account_id", "address", "balance_atoms", "billing_email", "business_name", "created_at", "custom_fields", "customer_billing_address", "discount", "email", "first_name", "id", "invoice_settings", "is_deleted", "language", "last_name", "last_successful_payment_intent", "metadata", "mrr", "notes", "object", "phone_number", "shipping_addresses", "should_send_payment_receipt", "status", "subscribed_to_products", "subscriptions", "total_refunds", "total_spent", "updated_at"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CustomerExternal from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of address
        if self.address:
            _dict['address'] = self.address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in balance_atoms (list)
        _items = []
        if self.balance_atoms:
            for _item_balance_atoms in self.balance_atoms:
                if _item_balance_atoms:
                    _items.append(_item_balance_atoms.to_dict())
            _dict['balance_atoms'] = _items
        # override the default output from pydantic by calling `to_dict()` of customer_billing_address
        if self.customer_billing_address:
            _dict['customer_billing_address'] = self.customer_billing_address.to_dict()
        # override the default output from pydantic by calling `to_dict()` of discount
        if self.discount:
            _dict['discount'] = self.discount.to_dict()
        # override the default output from pydantic by calling `to_dict()` of invoice_settings
        if self.invoice_settings:
            _dict['invoice_settings'] = self.invoice_settings.to_dict()
        # override the default output from pydantic by calling `to_dict()` of last_successful_payment_intent
        if self.last_successful_payment_intent:
            _dict['last_successful_payment_intent'] = self.last_successful_payment_intent.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in mrr (list)
        _items = []
        if self.mrr:
            for _item_mrr in self.mrr:
                if _item_mrr:
                    _items.append(_item_mrr.to_dict())
            _dict['mrr'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in shipping_addresses (list)
        _items = []
        if self.shipping_addresses:
            for _item_shipping_addresses in self.shipping_addresses:
                if _item_shipping_addresses:
                    _items.append(_item_shipping_addresses.to_dict())
            _dict['shipping_addresses'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subscribed_to_products (list)
        _items = []
        if self.subscribed_to_products:
            for _item_subscribed_to_products in self.subscribed_to_products:
                if _item_subscribed_to_products:
                    _items.append(_item_subscribed_to_products.to_dict())
            _dict['subscribed_to_products'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in subscriptions (list)
        _items = []
        if self.subscriptions:
            for _item_subscriptions in self.subscriptions:
                if _item_subscriptions:
                    _items.append(_item_subscriptions.to_dict())
            _dict['subscriptions'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in total_refunds (list)
        _items = []
        if self.total_refunds:
            for _item_total_refunds in self.total_refunds:
                if _item_total_refunds:
                    _items.append(_item_total_refunds.to_dict())
            _dict['total_refunds'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in total_spent (list)
        _items = []
        if self.total_spent:
            for _item_total_spent in self.total_spent:
                if _item_total_spent:
                    _items.append(_item_total_spent.to_dict())
            _dict['total_spent'] = _items
        # set to None if address (nullable) is None
        # and model_fields_set contains the field
        if self.address is None and "address" in self.model_fields_set:
            _dict['address'] = None

        # set to None if billing_email (nullable) is None
        # and model_fields_set contains the field
        if self.billing_email is None and "billing_email" in self.model_fields_set:
            _dict['billing_email'] = None

        # set to None if business_name (nullable) is None
        # and model_fields_set contains the field
        if self.business_name is None and "business_name" in self.model_fields_set:
            _dict['business_name'] = None

        # set to None if custom_fields (nullable) is None
        # and model_fields_set contains the field
        if self.custom_fields is None and "custom_fields" in self.model_fields_set:
            _dict['custom_fields'] = None

        # set to None if customer_billing_address (nullable) is None
        # and model_fields_set contains the field
        if self.customer_billing_address is None and "customer_billing_address" in self.model_fields_set:
            _dict['customer_billing_address'] = None

        # set to None if discount (nullable) is None
        # and model_fields_set contains the field
        if self.discount is None and "discount" in self.model_fields_set:
            _dict['discount'] = None

        # set to None if first_name (nullable) is None
        # and model_fields_set contains the field
        if self.first_name is None and "first_name" in self.model_fields_set:
            _dict['first_name'] = None

        # set to None if invoice_settings (nullable) is None
        # and model_fields_set contains the field
        if self.invoice_settings is None and "invoice_settings" in self.model_fields_set:
            _dict['invoice_settings'] = None

        # set to None if last_name (nullable) is None
        # and model_fields_set contains the field
        if self.last_name is None and "last_name" in self.model_fields_set:
            _dict['last_name'] = None

        # set to None if last_successful_payment_intent (nullable) is None
        # and model_fields_set contains the field
        if self.last_successful_payment_intent is None and "last_successful_payment_intent" in self.model_fields_set:
            _dict['last_successful_payment_intent'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        # set to None if notes (nullable) is None
        # and model_fields_set contains the field
        if self.notes is None and "notes" in self.model_fields_set:
            _dict['notes'] = None

        # set to None if phone_number (nullable) is None
        # and model_fields_set contains the field
        if self.phone_number is None and "phone_number" in self.model_fields_set:
            _dict['phone_number'] = None

        # set to None if status (nullable) is None
        # and model_fields_set contains the field
        if self.status is None and "status" in self.model_fields_set:
            _dict['status'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CustomerExternal from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_id": obj.get("account_id"),
            "address": CompleteAddress.from_dict(obj["address"]) if obj.get("address") is not None else None,
            "balance_atoms": [CustomerBalanceExternal.from_dict(_item) for _item in obj["balance_atoms"]] if obj.get("balance_atoms") is not None else None,
            "billing_email": obj.get("billing_email"),
            "business_name": obj.get("business_name"),
            "created_at": obj.get("created_at"),
            "custom_fields": obj.get("custom_fields"),
            "customer_billing_address": CompleteAddress.from_dict(obj["customer_billing_address"]) if obj.get("customer_billing_address") is not None else None,
            "discount": DiscountExternal.from_dict(obj["discount"]) if obj.get("discount") is not None else None,
            "email": obj.get("email"),
            "first_name": obj.get("first_name"),
            "id": obj.get("id"),
            "invoice_settings": CustomerInvoiceSettings.from_dict(obj["invoice_settings"]) if obj.get("invoice_settings") is not None else None,
            "is_deleted": obj.get("is_deleted") if obj.get("is_deleted") is not None else False,
            "language": obj.get("language"),
            "last_name": obj.get("last_name"),
            "last_successful_payment_intent": PaymentIntentExternal.from_dict(obj["last_successful_payment_intent"]) if obj.get("last_successful_payment_intent") is not None else None,
            "metadata": obj.get("metadata"),
            "mrr": [CustomerTotalAmount.from_dict(_item) for _item in obj["mrr"]] if obj.get("mrr") is not None else None,
            "notes": obj.get("notes"),
            "object": obj.get("object"),
            "phone_number": obj.get("phone_number"),
            "shipping_addresses": [CompleteAddress.from_dict(_item) for _item in obj["shipping_addresses"]] if obj.get("shipping_addresses") is not None else None,
            "should_send_payment_receipt": obj.get("should_send_payment_receipt"),
            "status": obj.get("status"),
            "subscribed_to_products": [ProductExternal.from_dict(_item) for _item in obj["subscribed_to_products"]] if obj.get("subscribed_to_products") is not None else None,
            "subscriptions": [SubscriptionExternal.from_dict(_item) for _item in obj["subscriptions"]] if obj.get("subscriptions") is not None else None,
            "total_refunds": [CustomerTotalAmount.from_dict(_item) for _item in obj["total_refunds"]] if obj.get("total_refunds") is not None else None,
            "total_spent": [CustomerTotalAmount.from_dict(_item) for _item in obj["total_spent"]] if obj.get("total_spent") is not None else None,
            "updated_at": obj.get("updated_at")
        })
        return _obj

from getopenpay.models.payment_intent_external import PaymentIntentExternal
# TODO: Rewrite to not use raise_errors
CustomerExternal.model_rebuild(raise_errors=False)

