import hmac
from enum import Enum
from hashlib import sha256

EXPECTED_TIMESTAMP_MARKER = 't'


class InvalidSignatureError(ValueError):
  """
  Raised when a webhook event signature is invalid.
  """

  def __init__(self):
    super().__init__('Invalid signature')


class SignatureVersion(str, Enum):
  """
  Supported signature versions.
  """
  V1 = 'v1'


class WebhookUtils:

  def __init__(self):
    pass

  def _verify_v1_signature(
    self, payload: str, timestamp: int, secret_key: str, signature_digest: str
  ) -> bool:
    """
    Verification algorithm for OpenPay v1 event signatures.
    See _verify_signature for usage.
    """

    signature_payload = f'{timestamp}.{payload}'
    expected_signature = hmac.new(
      key=secret_key.encode('utf-8'), msg=signature_payload.encode('utf-8'), digestmod=sha256
    )
    expected_signature_digest = expected_signature.hexdigest()

    return hmac.compare_digest(signature_digest, expected_signature_digest)

  def _verify_signature(
    self, version: str, payload: str, timestamp: int, secret_key: str, signature_digest: str
  ):
    """
    Verifies the signature string for the event message.
    
    Args:
      version (str): The signature version.
      payload (str): The serialized event data JSON.
      timestamp (int): The timestamp of the signature.
      secret_key (str): The secret key to use for the signature.
      signature_digest (str): The signature digest to validate.
    
    Returns:
      bool: True if the signature is valid, False otherwise.

    Raises:
      NotImplementedError: If the signature version is not supported.
    """

    try:
      _version = SignatureVersion(version)
    except ValueError:
      raise NotImplementedError(f'Signature version {version} is not supported')

    if _version == SignatureVersion.V1:
      return self._verify_v1_signature(
        payload=payload,
        timestamp=timestamp,
        secret_key=secret_key,
        signature_digest=signature_digest
      )

  def extract_timestamp_from_digest(self, signature_digest: str) -> int:
    """
    Extracts the timestamp from the signature digest.
    
    Args:
      signature_digest (str): The signature digest to extract the timestamp from.
      
    Returns:
      int: The timestamp extracted from the signature digest.
    """

    parts = signature_digest.split(',')
    timestamp_marker, timestamp_value = parts[0].split('=')
    if timestamp_marker != EXPECTED_TIMESTAMP_MARKER:
      raise InvalidSignatureError()

    try:
      return int(timestamp_value)
    except ValueError:
      raise InvalidSignatureError()

  def validate_payload(self, event_data: str, signature_digest: str, secret: str) -> None:
    """
    Validates a webhook event payload using the value of the
    signature digest header and a secret key.

    Returns None if the signature is valid.

    Args:
      event_data (str): The serialized event data JSON.
        This is the value of the `data` field in the event payload.
      signature_digest (str): The signature digest to validate.
        This is the value of the `signature-digest` field in the event payload.
      secret (str): The secret key to use for the signature.
        This is autogenerated when you create a webhook endpoint.
        You can find it in the OpenPay dashboard.
    
    Raises:
      InvalidSignatureError: If the signature is invalid.
    """

    timestamp = self.extract_timestamp_from_digest(signature_digest)
    parts = signature_digest.split(',')
    digest_tuples = [p.split('=') for p in parts[1:]]

    verified_signatures = [
      self._verify_signature(
        version=digest_version,
        payload=event_data,
        timestamp=timestamp,
        signature_digest=digest,
        secret_key=secret
      ) for digest_version, digest in digest_tuples
    ]

    if not any(verified_signatures):
      raise InvalidSignatureError()
