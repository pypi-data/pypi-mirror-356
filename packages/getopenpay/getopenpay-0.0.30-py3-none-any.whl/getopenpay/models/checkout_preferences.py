# coding: utf-8

"""
    OpenPay API

    super charge your subscription management.

    The version of the OpenAPI document: 1.2.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field
from typing import Any, ClassVar, Dict, List, Optional
from getopenpay.models.checkout_processors_preferences import CheckoutProcessorsPreferences
from getopenpay.models.fallback_configuration_input import FallbackConfigurationInput
from getopenpay.models.selected_price_quantity import SelectedPriceQuantity
from typing import Optional, Set
from typing_extensions import Self

class CheckoutPreferences(BaseModel):
    """
    Preferences for the checkout session. All changes to this object must be backwards-compatible, old objects should still be valid with all new schemas.  Note: this object is stored in both PaymentLinks (in string form) and CheckoutSessions ðŸ’¡ Please don't forget to update the checkout_session.preferences property method when you update this model.
    """ # noqa: E501
    fallback_cascade_preferences: Optional[List[FallbackConfigurationInput]] = Field(default=None, description="This object contains a list of price groups that will be used to fall back to if the selected product price quantity fails to be created. Processor preferences here will override the processor preferences in the processor_preferences field.")
    fallback_cascade_selected_product_price_quantity: Optional[List[List[SelectedPriceQuantity]]] = Field(default=None, description="This object contains a list of price groups that will be used to fall back to if the selected product price quantity fails to be created.")
    override_feature_rollout_settings: Optional[Dict[str, Any]] = None
    processor_preferences: Optional[CheckoutProcessorsPreferences] = None
    __properties: ClassVar[List[str]] = ["fallback_cascade_preferences", "fallback_cascade_selected_product_price_quantity", "override_feature_rollout_settings", "processor_preferences"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CheckoutPreferences from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in fallback_cascade_preferences (list)
        _items = []
        if self.fallback_cascade_preferences:
            for _item_fallback_cascade_preferences in self.fallback_cascade_preferences:
                if _item_fallback_cascade_preferences:
                    _items.append(_item_fallback_cascade_preferences.to_dict())
            _dict['fallback_cascade_preferences'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in fallback_cascade_selected_product_price_quantity (list of list)
        _items = []
        if self.fallback_cascade_selected_product_price_quantity:
            for _item_fallback_cascade_selected_product_price_quantity in self.fallback_cascade_selected_product_price_quantity:
                if _item_fallback_cascade_selected_product_price_quantity:
                    _items.append(
                         [_inner_item.to_dict() for _inner_item in _item_fallback_cascade_selected_product_price_quantity if _inner_item is not None]
                    )
            _dict['fallback_cascade_selected_product_price_quantity'] = _items
        # override the default output from pydantic by calling `to_dict()` of processor_preferences
        if self.processor_preferences:
            _dict['processor_preferences'] = self.processor_preferences.to_dict()
        # set to None if override_feature_rollout_settings (nullable) is None
        # and model_fields_set contains the field
        if self.override_feature_rollout_settings is None and "override_feature_rollout_settings" in self.model_fields_set:
            _dict['override_feature_rollout_settings'] = None

        # set to None if processor_preferences (nullable) is None
        # and model_fields_set contains the field
        if self.processor_preferences is None and "processor_preferences" in self.model_fields_set:
            _dict['processor_preferences'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CheckoutPreferences from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "fallback_cascade_preferences": [FallbackConfigurationInput.from_dict(_item) for _item in obj["fallback_cascade_preferences"]] if obj.get("fallback_cascade_preferences") is not None else None,
            "fallback_cascade_selected_product_price_quantity": [
                    [SelectedPriceQuantity.from_dict(_inner_item) for _inner_item in _item]
                    for _item in obj["fallback_cascade_selected_product_price_quantity"]
                ] if obj.get("fallback_cascade_selected_product_price_quantity") is not None else None,
            "override_feature_rollout_settings": obj.get("override_feature_rollout_settings"),
            "processor_preferences": CheckoutProcessorsPreferences.from_dict(obj["processor_preferences"]) if obj.get("processor_preferences") is not None else None
        })
        return _obj


