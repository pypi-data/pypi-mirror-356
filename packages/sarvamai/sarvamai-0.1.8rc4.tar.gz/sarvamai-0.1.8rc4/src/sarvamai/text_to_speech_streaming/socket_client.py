# This file was auto-generated by Fern from our API Definition.

import json
import typing

import websockets
import websockets.sync.connection as websockets_sync_connection
from ..core.events import EventEmitterMixin, EventType
from ..core.pydantic_utilities import parse_obj_as
from ..types.audio_output import AudioOutput
from ..types.close_connection import CloseConnection
from ..types.error_response import ErrorResponse
from ..types.initialize_connection import InitializeConnection
from ..types.initialize_connection_data import InitializeConnectionData
from ..types.ping_signal import PingSignal
from ..types.send_text import SendText
from ..types.send_text_data import SendTextData

TextToSpeechStreamingSocketClientResponse = typing.Union[AudioOutput, ErrorResponse]


class AsyncTextToSpeechStreamingSocketClient(EventEmitterMixin):
    def __init__(self, *, websocket: websockets.WebSocketClientProtocol):
        super().__init__()
        self._websocket = websocket

    async def __aiter__(self):
        async for message in self._websocket:
            message = json.loads(message) if isinstance(message, str) else message
            yield parse_obj_as(TextToSpeechStreamingSocketClientResponse, message)  # type: ignore

    async def start_listening(self):
        """
        Start listening for messages on the websocket connection.

        Emits events in the following order:
        - EventType.OPEN when connection is established
        - EventType.MESSAGE for each message received
        - EventType.ERROR if an error occurs
        - EventType.CLOSE when connection is closed
        """
        self._emit(EventType.OPEN, None)
        try:
            async for raw_message in self._websocket:
                raw_message = (
                    json.loads(raw_message)
                    if isinstance(raw_message, str)
                    else raw_message
                )
                parsed = parse_obj_as(TextToSpeechStreamingSocketClientResponse, raw_message)  # type: ignore
                self._emit(EventType.MESSAGE, parsed)
        except websockets.WebSocketException as exc:
            self._emit(EventType.ERROR, exc)
        finally:
            self._emit(EventType.CLOSE, None)

    async def initialize_connection(
        self,
        target_language_code: str,
        speaker: str,
    ) -> None:
        """
        Initialize the TTS connection with configuration parameters.

        :param target_language_code: Target language code (e.g., 'hi-IN')
        :param speaker: Voice speaker name (e.g., 'meera', 'arvind')
        """
        data = InitializeConnectionData(
            target_language_code=target_language_code,
            speaker=speaker,
        )
        message = InitializeConnection(data=data)
        await self._send_model(message)

    async def convert(self, text: str) -> None:
        """
        Send text to be converted to speech.

        :param text: Text to be synthesized (1-2500 characters)
        """
        data = SendTextData(text=text)
        message = SendText(data=data)
        await self._send_model(message)

    async def flush(self) -> None:
        """
        Signal to flush the buffer and finalize audio output.
        This indicates the end of text input.
        """
        message = CloseConnection()
        await self._send_model(message)

    async def ping(self) -> None:
        """
        Send ping signal to keep the WebSocket connection alive.
        """
        message = PingSignal()
        await self._send_model(message)

    async def recv(self) -> TextToSpeechStreamingSocketClientResponse:
        """
        Receive a message from the websocket connection.
        """
        data = await self._websocket.recv()
        data = json.loads(data) if isinstance(data, str) else data
        return parse_obj_as(TextToSpeechStreamingSocketClientResponse, data)  # type: ignore

    async def _send(self, data: typing.Any) -> None:
        """
        Send a message to the websocket connection.
        """
        if isinstance(data, dict):
            data = json.dumps(data)
        await self._websocket.send(data)

    async def _send_model(self, data: typing.Any) -> None:
        """
        Send a Pydantic model to the websocket connection.
        """
        await self._send(data.dict())


class TextToSpeechStreamingSocketClient(EventEmitterMixin):
    def __init__(self, *, websocket: websockets_sync_connection.Connection):
        super().__init__()
        self._websocket = websocket

    def __iter__(self):
        for message in self._websocket:
            message = json.loads(message) if isinstance(message, str) else message
            yield parse_obj_as(TextToSpeechStreamingSocketClientResponse, message)  # type: ignore

    def start_listening(self):
        """
        Start listening for messages on the websocket connection.

        Emits events in the following order:
        - EventType.OPEN when connection is established
        - EventType.MESSAGE for each message received
        - EventType.ERROR if an error occurs
        - EventType.CLOSE when connection is closed
        """
        self._emit(EventType.OPEN, None)
        try:
            for raw_message in self._websocket:
                raw_message = (
                    json.loads(raw_message)
                    if isinstance(raw_message, str)
                    else raw_message
                )
                parsed = parse_obj_as(TextToSpeechStreamingSocketClientResponse, raw_message)  # type: ignore
                self._emit(EventType.MESSAGE, parsed)
        except websockets.WebSocketException as exc:
            self._emit(EventType.ERROR, exc)
        finally:
            self._emit(EventType.CLOSE, None)

    def initialize_connection(
        self,
        target_language_code: str,
        speaker: str,
    ) -> None:
        """
        Initialize the TTS connection with configuration parameters.

        :param target_language_code: Target language code (e.g., 'hi-IN')
        :param speaker: Voice speaker name (e.g., 'meera', 'arvind')
        """
        data = InitializeConnectionData(
            target_language_code=target_language_code,
            speaker=speaker,
        )
        message = InitializeConnection(data=data)
        self._send_model(message)

    def convert(self, text: str) -> None:
        """
        Send text to be converted to speech.

        :param text: Text to be synthesized (1-2500 characters)
        """
        data = SendTextData(text=text)
        message = SendText(data=data)
        self._send_model(message)

    def flush(self) -> None:
        """
        Signal to flush the buffer and finalize audio output.
        This indicates the end of text input.
        """
        message = CloseConnection()
        self._send_model(message)

    def ping(self) -> None:
        """
        Send ping signal to keep the WebSocket connection alive.
        """
        message = PingSignal()
        self._send_model(message)

    def recv(self) -> TextToSpeechStreamingSocketClientResponse:
        """
        Receive a message from the websocket connection.
        """
        data = self._websocket.recv()
        data = json.loads(data) if isinstance(data, str) else data
        return parse_obj_as(TextToSpeechStreamingSocketClientResponse, data)  # type: ignore

    def _send(self, data: typing.Any) -> None:
        """
        Send a message to the websocket connection.
        """
        if isinstance(data, dict):
            data = json.dumps(data)
        self._websocket.send(data)

    def _send_model(self, data: typing.Any) -> None:
        """
        Send a Pydantic model to the websocket connection.
        """
        self._send(data.dict())
