# This file was auto-generated by Fern from our API Definition.

import json
import typing

import websockets
import websockets.sync.connection as websockets_sync_connection
from ..core.events import EventEmitterMixin, EventType
from ..core.pydantic_utilities import parse_obj_as
from ..types.audio_output import AudioOutput
from ..types.flush_signal import FlushSignal
from ..types.error_response import ErrorResponse
from ..types.initialize_connection import InitializeConnection
from ..types.initialize_connection_data import InitializeConnectionData
from ..types.ping_signal import PingSignal
from ..types.send_text import SendText
from ..types.send_text_data import SendTextData

TextToSpeechStreamingSocketClientResponse = typing.Union[AudioOutput, ErrorResponse]


class AsyncTextToSpeechStreamingSocketClient(EventEmitterMixin):
    def __init__(self, *, websocket: websockets.WebSocketClientProtocol):
        super().__init__()
        self._websocket = websocket

    async def __aiter__(self):
        async for message in self._websocket:
            message = json.loads(message) if isinstance(message, str) else message
            yield parse_obj_as(TextToSpeechStreamingSocketClientResponse, message)  # type: ignore

    async def start_listening(self):
        """
        Start listening for messages on the websocket connection.

        Emits events in the following order:
        - EventType.OPEN when connection is established
        - EventType.MESSAGE for each message received
        - EventType.ERROR if an error occurs
        - EventType.CLOSE when connection is closed
        """
        self._emit(EventType.OPEN, None)
        try:
            async for raw_message in self._websocket:
                raw_message = (
                    json.loads(raw_message)
                    if isinstance(raw_message, str)
                    else raw_message
                )
                parsed = parse_obj_as(TextToSpeechStreamingSocketClientResponse, raw_message)  # type: ignore
                self._emit(EventType.MESSAGE, parsed)
        except websockets.WebSocketException as exc:
            self._emit(EventType.ERROR, exc)
        finally:
            self._emit(EventType.CLOSE, None)

    async def initialize_connection(
        self,
        target_language_code: str,
        speaker: str,
        pitch: float = 0.0,
        pace: float = 1.0,
        loudness: float = 1.0,
        speech_sample_rate: int = 22050,
        enable_preprocessing: bool = False,
        output_audio_codec: str = "mp3",
        output_audio_bitrate: str = "128k",
        min_buffer_size: int = 50,
        max_chunk_length: int = 150,
    ) -> None:
        """
        Initialize the TTS connection with configuration parameters.

        :param target_language_code: Target language code (e.g., 'hi-IN')
        :param speaker: Voice speaker name (e.g., 'meera', 'arvind')
        :param pitch: Voice pitch adjustment (-1.0 to 1.0, default: 0.0)
        :param pace: Speech pace (0.3 to 3.0, default: 1.0)
        :param loudness: Voice loudness (0.1 to 3.0, default: 1.0)
        :param speech_sample_rate: Audio sample rate, default: 22050
        :param enable_preprocessing: Enable text preprocessing, default: False
        :param output_audio_codec: Audio codec, default: 'mp3'
        :param output_audio_bitrate: Audio bitrate, default: '128k'
        :param min_buffer_size: Minimum buffer size, default: 50
        :param max_chunk_length: Maximum chunk length, default: 150
        """
        data = InitializeConnectionData(
            target_language_code=target_language_code,
            speaker=speaker,
            pitch=pitch,
            pace=pace,
            loudness=loudness,
            speech_sample_rate=speech_sample_rate,
            enable_preprocessing=enable_preprocessing,
            output_audio_codec=output_audio_codec,
            output_audio_bitrate=output_audio_bitrate,
            min_buffer_size=min_buffer_size,
            max_chunk_length=max_chunk_length,
        )
        message = InitializeConnection(data=data)
        await self._send_model(message)

    async def convert(self, text: str) -> None:
        """
        Send text to be converted to speech.

        :param text: Text to be synthesized (1-2500 characters)
        """
        data = SendTextData(text=text)
        message = SendText(data=data)
        await self._send_model(message)

    async def flush(self) -> None:
        """
        Signal to flush the buffer and finalize audio output.
        This indicates the end of text input.
        """
        message = FlushSignal()
        await self._send_model(message)

    async def ping(self) -> None:
        """
        Send ping signal to keep the WebSocket connection alive.
        """
        message = PingSignal()
        await self._send_model(message)

    async def recv(self) -> TextToSpeechStreamingSocketClientResponse:
        """
        Receive a message from the websocket connection.
        """
        data = await self._websocket.recv()
        data = json.loads(data) if isinstance(data, str) else data
        return parse_obj_as(TextToSpeechStreamingSocketClientResponse, data)  # type: ignore

    async def _send(self, data: typing.Any) -> None:
        """
        Send a message to the websocket connection.
        """
        if isinstance(data, dict):
            data = json.dumps(data)
        await self._websocket.send(data)

    async def _send_model(self, data: typing.Any) -> None:
        """
        Send a Pydantic model to the websocket connection.
        """
        await self._send(data.dict())


class TextToSpeechStreamingSocketClient(EventEmitterMixin):
    def __init__(self, *, websocket: websockets_sync_connection.Connection):
        super().__init__()
        self._websocket = websocket

    def __iter__(self):
        for message in self._websocket:
            message = json.loads(message) if isinstance(message, str) else message
            yield parse_obj_as(TextToSpeechStreamingSocketClientResponse, message)  # type: ignore

    def start_listening(self):
        """
        Start listening for messages on the websocket connection.

        Emits events in the following order:
        - EventType.OPEN when connection is established
        - EventType.MESSAGE for each message received
        - EventType.ERROR if an error occurs
        - EventType.CLOSE when connection is closed
        """
        self._emit(EventType.OPEN, None)
        try:
            for raw_message in self._websocket:
                raw_message = (
                    json.loads(raw_message)
                    if isinstance(raw_message, str)
                    else raw_message
                )
                parsed = parse_obj_as(TextToSpeechStreamingSocketClientResponse, raw_message)  # type: ignore
                self._emit(EventType.MESSAGE, parsed)
        except websockets.WebSocketException as exc:
            self._emit(EventType.ERROR, exc)
        finally:
            self._emit(EventType.CLOSE, None)

    def initialize_connection(
        self,
        target_language_code: str,
        speaker: str,
        pitch: float = 0.0,
        pace: float = 1.0,
        loudness: float = 1.0,
        speech_sample_rate: int = 22050,
        enable_preprocessing: bool = False,
        output_audio_codec: str = "mp3",
        output_audio_bitrate: str = "128k",
        min_buffer_size: int = 50,
        max_chunk_length: int = 150,
    ) -> None:
        """
        Initialize the TTS connection with configuration parameters.

        :param target_language_code: Target language code (e.g., 'hi-IN')
        :param speaker: Voice speaker name (e.g., 'meera', 'arvind')
        :param pitch: Voice pitch adjustment (-1.0 to 1.0, default: 0.0)
        :param pace: Speech pace (0.3 to 3.0, default: 1.0)
        :param loudness: Voice loudness (0.1 to 3.0, default: 1.0)
        :param speech_sample_rate: Audio sample rate, default: 22050
        :param enable_preprocessing: Enable text preprocessing, default: False
        :param output_audio_codec: Audio codec, default: 'mp3'
        :param output_audio_bitrate: Audio bitrate, default: '128k'
        :param min_buffer_size: Minimum buffer size, default: 50
        :param max_chunk_length: Maximum chunk length, default: 150
        """
        data = InitializeConnectionData(
            target_language_code=target_language_code,
            speaker=speaker,
            pitch=pitch,
            pace=pace,
            loudness=loudness,
            speech_sample_rate=speech_sample_rate,
            enable_preprocessing=enable_preprocessing,
            output_audio_codec=output_audio_codec,
            output_audio_bitrate=output_audio_bitrate,
            min_buffer_size=min_buffer_size,
            max_chunk_length=max_chunk_length,
        )
        message = InitializeConnection(data=data)
        self._send_model(message)

    def convert(self, text: str) -> None:
        """
        Send text to be converted to speech.

        :param text: Text to be synthesized (1-2500 characters)
        """
        data = SendTextData(text=text)
        message = SendText(data=data)
        self._send_model(message)

    def flush(self) -> None:
        """
        Signal to flush the buffer and finalize audio output.
        This indicates the end of text input.
        """
        message = FlushSignal()
        self._send_model(message)

    def ping(self) -> None:
        """
        Send ping signal to keep the WebSocket connection alive.
        """
        message = PingSignal()
        self._send_model(message)

    def recv(self) -> TextToSpeechStreamingSocketClientResponse:
        """
        Receive a message from the websocket connection.
        """
        data = self._websocket.recv()
        data = json.loads(data) if isinstance(data, str) else data
        return parse_obj_as(TextToSpeechStreamingSocketClientResponse, data)  # type: ignore

    def _send(self, data: typing.Any) -> None:
        """
        Send a message to the websocket connection.
        """
        if isinstance(data, dict):
            data = json.dumps(data)
        self._websocket.send(data)

    def _send_model(self, data: typing.Any) -> None:
        """
        Send a Pydantic model to the websocket connection.
        """
        self._send(data.dict())
