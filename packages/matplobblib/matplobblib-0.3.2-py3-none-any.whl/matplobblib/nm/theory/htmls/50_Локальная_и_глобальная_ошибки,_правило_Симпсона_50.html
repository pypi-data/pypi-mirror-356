<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>50. Локальная и глобальная ошибки, правило Симпсона, ошибка сокращения и ошибка округления, накопление ошибок.</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1 { color: #111; border-bottom: 2px solid #eee; padding-bottom: 0.3em; margin-top: 0; }
        img { max-width: 100%; height: auto; display: block; margin: 1em 0; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        p { margin: 1em 0; }
        div, section, article { margin-bottom: 1em; }
        /* Вы можете добавить сюда больше стилей или ссылку на CSS из оригинального документа, если это необходимо */
    </style>
</head>
<body>
<h1 class="c1" id="h.1cmqa2jajqyu"><span class="c34">50. Локальная и глобальная ошибки, правило Симпсона, ошибка сокращения и ошибка округления, накопление ошибок.</span></h1><p class="c17"><span class="c4">Локальные погрешности</span><span class="c3"> – погрешности, образовавшиеся на каждом шаге, </span></p><p class="c17"><span class="c4">Глобальная (накопленная) погрешность</span><span class="c3"> – погрешность, образовавшаяся за несколько шагов.</span></p><p class="c17"><span class="c5">Порядок глобальной погрешности относительно шага интегрирования на единицу ниже, чем порядок локальной погрешности. Таким образом, глобальная погрешность метода Эйлера имеет порядок p = 1: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image143.png"/><span class="c3"> = C ∙ h, где C – некоторая постоянная. </span></p><p class="c17"><span class="c3">Порядок численного метода для решения ОДУ определяется порядком его глобальной погрешности. Он может быть также определен, как количество вычислений значения производной f(x, y) искомой функции на каждом шаге. В соответствии с этим метод Эйлера является методом первого порядка.</span></p><p class="c9"><span class="c3"></span></p><p class="c17"><span class="c4 c11">Правило Симпсона</span><span class="c5 c11"> </span><span class="c5">–</span><span class="c5 c11"> это численный метод приближённого вычисления определённых интегралов, основанный на квадратичной интерполяции подынтегральной функции. Его суть заключается в том, что вместо интегрирования исходной функции мы заменяем её на параболу, </span><span class="c5 c11">проведённую</span><span class="c3 c11"> через три точки на равномерной сетке, и вычисляем площадь под этой параболой аналитически. Формула Симпсона для отрезка </span></p><p class="c59"><span class="c3 c11">[a,b] имеет вид:</span></p><p class="c39"><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image144.png"/><span class="c3 c11">.</span></p><p class="c39"><span class="c5 c11">Этот метод особенно эффективен, когда подынтегральная функция гладкая или её можно разбить на такие отрезки, где она ведёт себя почти как квадратичная. Правило Симпсона обеспечивает высокую точность — его погрешность имеет порядок O(</span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image145.png"/><span class="c5 c11">) для одного отрезка и O(</span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image146.png"/><span class="c3 c11">) для составного правила (где h — шаг разбиения), что значительно лучше методов прямоугольников или трапеций.</span></p><p class="c41 c11"><span class="c3 c11">Применять его стоит, когда требуется высокая точность при относительно небольшом количестве вычислений, например, при интегрировании аналитических функций или в инженерных расчётах. Однако если функция имеет резкие колебания или разрывы, лучше использовать другие методы или предварительно разбивать интервал на части.</span></p><p class="c11 c41"><span class="c5 c11">В более широком смысле "правило Симпсона" иногда называют принципом, что использование квадратичной аппроксимации часто </span><span class="c5 c11">даёт</span><span class="c3 c11"> оптимальный баланс между точностью и вычислительными затратами. Отсюда возможная связь с анализом ошибок.</span></p><p class="c11 c88"><span class="c4 c11">Ошибка сокращения (или ошибка усечения)</span><span class="c5 c11"> возникает из-за </span><span class="c5 c11">приближённого</span><span class="c3 c11"> характера численных методов, когда бесконечные процессы заменяются конечными или сложные функции — более простыми. Например, при вычислении производной с помощью разностной схемы отбрасываются старшие члены ряда Тейлора, что приводит к неточности. Эта ошибка зависит от выбранного метода и шага вычислений: чем точнее алгоритм и мельче шаг, тем она меньше. </span></p><p class="c88 c11"><span class="c5 c11">Однако уменьшение шага может усилить другой тип погрешности — </span><span class="c4 c11">ошибку округления</span><span class="c3 c11">, связанную с конечной точностью представления чисел в компьютере. При выполнении арифметических операций (особенно при вычитании близких чисел или сложении значений сильно разного масштаба) младшие значащие разряды теряются из-за ограниченной разрядности мантиссы, что искажает результат.</span></p><p class="c41 c11"><span class="c4 c11">Накопление ошибок</span><span class="c5 c11"> </span><span class="c5">– </span><span class="c3 c11">это процесс, при котором малые погрешности на каждом шаге алгоритма суммируются или усиливаются, приводя к значительному отклонению итогового значения. Например, при последовательном сложении тысяч чисел даже очень маленькие округления могут существенно изменить сумму. </span></p><p class="c41 c11"><span class="c5 c11">Для борьбы с этим используют специальные алгоритмы, такие как </span><span class="c4 c11">алгоритм Кахана</span><span class="c5 c11">. Его идея заключается в отслеживании и компенсации потерянных из-за округления частей чисел. На каждом шаге кроме основного суммирования вычисляется "погрешность" </span><span class="c5">–</span><span class="c5 c11"> разница между тем, что должно было добавиться, и тем, что действительно добавилось с </span><span class="c5 c11">учётом</span><span class="c3 c11"> ограниченной точности. Эта погрешность затем учитывается на следующей итерации. Таким образом, алгоритм Кахана значительно снижает ошибку накопления, особенно в задачах с большим количеством операций, например, при вычислении скалярных произведений или численном интегрировании.</span></p><p class="c11 c95"><span class="c3 c11">Полностью устранить ошибки невозможно, но грамотный выбор методов (например, алгоритм Кахана для суммирования) позволяет минимизировать их влияние. Это особенно критично в долгих вычислениях, таких как решение дифференциальных уравнений или моделирование физических процессов, где накопленные погрешности могут привести к качественно неверным результатам.</span></p><p class="c25"><span class="c64 c11 c44"></span></p>
</body>
</html>