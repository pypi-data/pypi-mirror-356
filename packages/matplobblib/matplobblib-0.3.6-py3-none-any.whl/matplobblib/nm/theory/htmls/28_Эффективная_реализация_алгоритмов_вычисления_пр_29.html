<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>28. Эффективная реализация алгоритмов вычисления произведения матриц.</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1 { color: #111; border-bottom: 2px solid #eee; padding-bottom: 0.3em; margin-top: 0; }
        img { max-width: 100%; height: auto; display: block; margin: 1em 0; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        p { margin: 1em 0; }
        div, section, article { margin-bottom: 1em; }
        /* Вы можете добавить сюда больше стилей или ссылку на CSS из оригинального документа, если это необходимо */
    </style>
</head>
<body>
<h1 class="c1" id="h.f3pr1sblrb4b"><span class="c34">28. Эффективная реализация алгоритмов вычисления произведения матриц.</span></h1><p class="c7"><span class="c4">Умножение матриц</span><span class="c3"> – одна из ключевых операций в линейной алгебре, машинном обучении и научных вычислениях. Для его эффективной реализации создано огромное количество методов.</span></p><p class="c7"><span class="c4">1. Наивное умножение</span><span class="c3"> (стандартный алгоритм).</span></p><p class="c7"><span class="c5">Пусть есть матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image25.png"/><span class="c5"> размера </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image26.png"/><span class="c5"> и матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image27.png"/><span class="c5"> размером </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image28.png"/><span class="c5">. Матрица </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image29.png"/><span class="c5"> – результат произведения размера </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image30.png"/><span class="c3">: </span></p><p class="c68 c50"><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image31.png"/></p><p class="c7"><span class="c5">Для умножения матриц требуется (при </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image32.png"/><span class="c5">): </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image33.png"/><span class="c5"> умножений и </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image34.png"/><span class="c5"> суммирований </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image35.png"/><span class="c5"> </span><span class="c4">Сложность </span><span class="c5">наивного алгоритма: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image36.png"/><span class="c3">.</span></p><p class="c7"><span class="c18 c4">2. Блочное умножение.</span></p><p class="c7"><span class="c5">С целью повышения эффективности использования кэш-памяти CPU существует алгоритм </span><span class="c4">блочного умножения</span><span class="c5"> матриц, в котором результирующая матрица формируется поблочно с использованием известной формулы </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image37.png"/><span class="c5">, либо </span><span class="c5">её</span><span class="c5"> более быстрых аналогов, а размер обрабатываемых данных на каждой итерации не превышает </span><span class="c5">ёмкость</span><span class="c5"> кэш-памяти. </span><span class="c4">Сложность</span><span class="c5">: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image38.png"/><span class="c3">.</span></p><p class="c7"><span class="c5">Размер блока напрямую зависит от архитектуры вычислительной системы и определяет время выполнения умножения. Аналогичный подход применяется при умножении матриц с использованием </span><span class="c5"><a class="c80" href="https://www.google.com/url?q=https://ru.wikipedia.org/wiki/GPU&amp;sa=D&amp;source=editors&amp;ust=1750071175922487&amp;usg=AOvVaw0j5ThmZmd6diKtHuFvovY5">GPU</a></span><span class="c3"> с оптимизацией использования разделяемой памяти ограниченного объёма.</span></p><p class="c7"><span class="c3">(по сути то же наивное умножение, но блоками в целях оптимизации затрат памяти и времени)</span></p><p class="c7"><span class="c4">3. Алгоритм Штрассена </span><span class="c5">(см. </span><span class="c28 c5"><a class="c80" href="#h.8k4uop79fp7">вопрос 29</a></span><span class="c3">).</span></p><p class="c7"><span class="c4">4. Алгоритм Копперсмита–Винограда.</span></p><p class="c7"><span class="c4">Алгоритм Копперсмита–Винограда </span><span class="c5">–</span><span class="c4"> </span><span class="c5">улучшенная версия Штрассена с вычислительной </span><span class="c4">сложностью </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image39.png"/><span class="c5">. О</span><span class="c3">бладает лучшей асимптотикой среди известных алгоритмов умножения матриц. </span></p><p class="c7"><span class="c3">На практике алгоритм Копперсмита–Винограда не используется, так как он имеет очень большую константу пропорциональности и начинает выигрывать в быстродействии у других известных алгоритмов только для матриц, размер которых превышает память современных компьютеров.</span></p><p class="c7"><span class="c18 c4">5. Реализация в numpy.</span></p><p class="c7"><span class="c4">NumPy </span><span class="c5">использует BLAS (Basic Linear Algebra Subprograms) – </span><span class="c5">высокооптимизированные</span><span class="c3"> низкоуровневые библиотеки, предназначенные для выполнения основных операций линейной алгебры. </span></p><p class="c7"><span class="c4">Сложность</span><span class="c5">: </span><img src="file:///C:/Users/ivant/Desktop/proj/matplobblib/htmls/NM/images/image38.png"/><span class="c3">.</span></p><p class="c7"><span class="c5">Почему NumPy </span><span class="c4">эффективен</span><span class="c3">?</span></p><ul class="c2 lst-kix_s6558encdjv-0 start"><li class="c14 li-bullet-0"><span class="c3">Использование параллельных вычислений.</span></li><li class="c14 li-bullet-0"><span class="c3">Оптимизация доступа к памяти (блочное умножение, минимизация кэш-промахов).</span></li></ul><ul class="c2 lst-kix_s6558encdjv-1 start"><li class="c20 c30 c37 li-bullet-0"><span class="c3">Row-major или column-major (методы хранения многомерных массивов в линейном пространстве, например, random access memory – запоминающее устройство с произвольным доступом).</span></li><li class="c20 c30 c37 li-bullet-0"><span class="c3">Кэш-дружественные алгоритмы: разбиение матриц на блоки, которые помещаются в кэш.</span></li></ul><ul class="c2 lst-kix_s6558encdjv-0"><li class="c14 li-bullet-0"><span class="c3">Многопоточность (параллельное вычисление блоков матрицы).</span></li><li class="c14 li-bullet-0"><span class="c3">Алгоритмы в зависимости от размера:</span></li></ul><ul class="c2 lst-kix_s6558encdjv-1 start"><li class="c20 c30 c37 li-bullet-0"><span class="c3">Для маленьких матриц – наивный метод.</span></li><li class="c20 c30 c37 li-bullet-0"><span class="c3">Для больших – Штрассен или другие оптимизированные методы.</span></li></ul><p class="c7 c40"><span class="c3"></span></p>
</body>
</html>