<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10. Профилирование кода в Python.</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 20px; line-height: 1.6; color: #333; }
        h1 { color: #111; border-bottom: 2px solid #eee; padding-bottom: 0.3em; margin-top: 0; }
        img { max-width: 100%; height: auto; display: block; margin: 1em 0; border: 1px solid #ddd; border-radius: 4px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        p { margin: 1em 0; }
        div, section, article { margin-bottom: 1em; }
        /* Вы можете добавить сюда больше стилей или ссылку на CSS из оригинального документа, если это необходимо */
    </style>
</head>
<body>
<h1 class="c1" id="h.xyg7jwyy5kxe"><span class="c34">10. Профилирование кода в Python.</span></h1><p class="c20"><span class="c4">Профилирование</span><span class="c3"> — это процесс измерения производительности программы:</span></p><ul class="c2 lst-kix_m7uwfmtnhkr2-0 start"><li class="c19 li-bullet-0"><span class="c3">сколько времени занимает выполнение разных частей кода;<br/></span></li><li class="c19 li-bullet-0"><span class="c3">сколько памяти потребляется;<br/></span></li><li class="c19 li-bullet-0"><span class="c3">какие функции вызываются чаще всего.<br/></span></li></ul><p class="c20"><span class="c5">Цель профилирования — </span><span class="c4">найти узкие места</span><span class="c5"> (bottlenecks), чтобы </span><span class="c4">оптимизировать</span><span class="c3"> код.</span></p><h2 class="c70" id="h.gejiqluwvxly"><span class="c18 c67 c91">   Зачем нужно профилирование?</span></h2><ul class="c2 lst-kix_pxes9q1jnqw0-0 start"><li class="c19 li-bullet-0"><span class="c3">Повышение скорости работы программы.<br/></span></li><li class="c19 li-bullet-0"><span class="c3">Снижение использования ресурсов (память, процессор).<br/></span></li><li class="c19 li-bullet-0"><span class="c3">Анализ эффективности алгоритмов.<br/></span></li><li class="c19 li-bullet-0"><span class="c3">Подготовка к масштабированию.</span></li></ul><p class="c7"><span class="c3">Не буду писать сюда все варианты профилирования, потому что в презе этого нет. Мы использовали вот такие функции (можешь глянуть мой файлик chim1-2 - это все, что мы юзали на первом семинаре, дальше вообще тыкали только timeit): </span></p><p class="c7"><span class="c3">%time sum(range(2000)) - Однократное измерение времени выполнения выражения. Полезно для быстрого замера, но не очень точно, так как результат может зависеть от фоновой нагрузки.</span></p><p class="c7"><span class="c3">%timeit sum(range(2000)) - Множественное измерение (по умолчанию: 7 повторов по 1 млн итераций или адаптивно) — средняя и надёжная оценка времени выполнения.</span></p><p class="c7"><span class="c3">%%time (перед ячейкой кода), %%timeit (перед ячейкой кода) - это и следующую применяли к тем же функциям, но расписанным циклом, поэтому юзали штучку, которая считает всю ячейку</span></p><p class="c7"><span class="c3">%prun slow_sum(100,10000) - Запускает встроенный профилировщик cProfile на одну строку (или функцию), и выводит статистику по вызовам функций. Полезно для анализа, где тратится больше всего времени. Показывает количество вызовов, время в функции, суммарное время с учётом подфункций</span></p><p class="c7"><span class="c3">а еще устанавливали такую штуку:</span></p><p class="c7"><span class="c3">pip install line-profiler</span></p><p class="c7"><span class="c3">%load_ext line_profiler</span></p><p class="c7"><span class="c5">%lprun -f slow_sum slow_sum(1000,10000) - Показывает время выполнения каждой строки функции. Очень точный для локального анализа производительности</span></p>
</body>
</html>