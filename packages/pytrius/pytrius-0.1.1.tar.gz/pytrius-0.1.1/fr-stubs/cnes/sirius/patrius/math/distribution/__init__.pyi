
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import fr.cnes.sirius.patrius.math.linear
import fr.cnes.sirius.patrius.math.random
import fr.cnes.sirius.patrius.math.util
import java.io
import java.util
import jpype
import typing



class IntegerDistribution:
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def inverseCumulativeProbability(self, double: float) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def probability(self, int: int) -> float: ...
    def reseedRandomGenerator(self, long: int) -> None: ...
    @typing.overload
    def sample(self) -> int: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[int]: ...

class KolmogorovSmirnovDistribution(java.io.Serializable):
    """
    public class KolmogorovSmirnovDistribution extends `Object <http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true>` implements `Serializable <http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true>`
    
        Implementation of the Kolmogorov-Smirnov distribution.
    
        Treats the distribution of the two-sided :code:`P(D_n < d)` where :code:`D_n = sup_x |G(x) - G_n (x)|` for the
        theoretical cdf :code:`G` and the empirical cdf :code:`G_n`.
    
        This implementation is based on [1] with certain quick decisions for extreme values given in [2].
    
        In short, when wanting to evaluate :code:`P(D_n < d)`, the method in [1] is to write :code:`d = (k - h) / n` for
        positive integer :code:`k` and :code:`0 <= h < 1`. Then :code:`P(D_n < d) = (n! / n^n) * t_kk`, where :code:`t_kk` is
        the :code:`(k, k)`'th entry in the special matrix :code:`H^n`, i.e. :code:`H` to the :code:`n`'th power.
    
        References:
    
          - [1] ` Evaluating Kolmogorov's Distribution <http://www.jstatsoft.org/v08/i18/>` by George Marsaglia, Wai Wan Tsang, and
            Jingbo Wang
          - [2] ` Computing the Two-Sided Kolmogorov-Smirnov Distribution <http://www.jstatsoft.org/v39/i11/>` by Richard Simard and
            Pierre L'Ecuyer
    
        Note that [1] contains an error in computing h, refer to MATH-437 for details.
    
        Also see:
            ` Kolmogorov-Smirnov test (Wikipedia) <http://en.wikipedia.org/wiki/Kolmogorov-Smirnov_test>`, :meth:`~serialized`
    """
    def __init__(self, int: int): ...
    @typing.overload
    def cdf(self, double: float) -> float:
        """
            Calculates :code:`P(D_n < d)` using method described in [1] with quick decisions for extreme values given in [2] (see
            above). The result is not exact as with
            :meth:`~fr.cnes.sirius.patrius.math.distribution.KolmogorovSmirnovDistribution.cdfExact` because calculations are based
            on :code:`double` rather than :class:`~fr.cnes.sirius.patrius.math.fraction.BigFraction`.
        
            Parameters:
                d (double): statistic
        
            Returns:
                the two-sided probability of :code:`P(D_n < d)`
        
            Raises:
                :class:`~fr.cnes.sirius.patrius.math.exception.MathArithmeticException`: if algorithm fails to convert :code:`h` to a :class:`~fr.cnes.sirius.patrius.math.fraction.BigFraction` in expressing
                    :code:`d` as :code:`(k - h) / m` for integer :code:`k, m` and :code:`0 <= h < 1`.
        
            Calculates :code:`P(D_n < d)` using method described in [1] with quick decisions for extreme values given in [2] (see
            above).
        
            Parameters:
                d (double): statistic
                exact (boolean): whether the probability should be calculated exact using :class:`~fr.cnes.sirius.patrius.math.fraction.BigFraction`
                    everywhere at the expense of very slow execution time, or if :code:`double` should be used convenient places to gain
                    speed. Almost never choose :code:`true` in real applications unless you are very sure; :code:`true` is almost solely for
                    verification purposes.
        
            Returns:
                the two-sided probability of :code:`P(D_n < d)`
        
            Raises:
                :class:`~fr.cnes.sirius.patrius.math.exception.MathArithmeticException`: if algorithm fails to convert :code:`h` to a :class:`~fr.cnes.sirius.patrius.math.fraction.BigFraction` in expressing
                    :code:`d` as :code:`(k - h) / m` for integer :code:`k, m` and :code:`0 <= h < 1`.
        
        
        """
        ...
    @typing.overload
    def cdf(self, double: float, boolean: bool) -> float: ...
    def cdfExact(self, double: float) -> float:
        """
            Calculates :code:`P(D_n < d)` using method described in [1] with quick decisions for extreme values given in [2] (see
            above). The result is exact in the sense that BigFraction/BigReal is used everywhere at the expense of very slow
            execution time. Almost never choose this in real applications unless you are very sure; this is almost solely for
            verification purposes. Normally, you would choose
            :meth:`~fr.cnes.sirius.patrius.math.distribution.KolmogorovSmirnovDistribution.cdf`
        
            Parameters:
                d (double): statistic
        
            Returns:
                the two-sided probability of :code:`P(D_n < d)`
        
            Raises:
                :class:`~fr.cnes.sirius.patrius.math.exception.MathArithmeticException`: if algorithm fails to convert :code:`h` to a :class:`~fr.cnes.sirius.patrius.math.fraction.BigFraction` in expressing
                    :code:`d` as :code:`(k - h) / m` for integer :code:`k, m` and :code:`0 <= h < 1`.
        
        
        """
        ...

class MultivariateRealDistribution:
    """
    public interface MultivariateRealDistribution
    
        Base interface for multivariate distributions on the reals. This is based largely on the RealDistribution interface, but
        cumulative distribution functions are not required because they are often quite difficult to compute for multivariate
        distributions.
    
        Since:
            3.1
    """
    def density(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float:
        """
            Returns the probability density function (PDF) of this distribution evaluated at the specified point :code:`x`. In
            general, the PDF is the derivative of the cumulative distribution function. If the derivative does not exist at
            :code:`x`, then an appropriate replacement should be returned, e.g. :code:`Double.POSITIVE_INFINITY`,
            :code:`Double.NaN`, or the limit inferior or limit superior of the difference quotient.
        
            Parameters:
                x (double[]): Point at which the PDF is evaluated.
        
            Returns:
                the value of the probability density function at point :code:`x`.
        
        
        """
        ...
    def getDimension(self) -> int:
        """
            Gets the number of random variables of the distribution. It is the size of the array returned by the
            :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample` method.
        
            Returns:
                the number of variables.
        
        
        """
        ...
    def reseedRandomGenerator(self, long: int) -> None:
        """
            Reseeds the random generator used to generate samples.
        
            Parameters:
                seed (long): Seed with which to initialize the random number generator.
        
        
        """
        ...
    @typing.overload
    def sample(self) -> typing.MutableSequence[float]:
        """
            Generates a random value vector sampled from this distribution.
        
            Returns:
                a random value vector.
        
        """
        ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]:
        """
            Generates a list of a random value vectors from the distribution.
        
            Parameters:
                sampleSize (int): the number of random vectors to generate.
        
            Returns:
                an array representing the random samples.
        
            Raises:
                :class:`~fr.cnes.sirius.patrius.math.exception.NotStrictlyPositiveException`: if :code:`sampleSize` is not positive.
        
            Also see:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample`
        
        
        """
        ...

class RealDistribution:
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def inverseCumulativeProbability(self, double: float) -> float: ...
    def isSupportConnected(self) -> bool: ...
    @typing.overload
    def probability(self, double: float) -> float: ...
    @typing.overload
    def probability(self, double: float, double2: float) -> float: ...
    def reseedRandomGenerator(self, long: int) -> None: ...
    @typing.overload
    def sample(self) -> float: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]: ...

class AbstractIntegerDistribution(IntegerDistribution, java.io.Serializable):
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    def inverseCumulativeProbability(self, double: float) -> int: ...
    def reseedRandomGenerator(self, long: int) -> None: ...
    @typing.overload
    def sample(self) -> int: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[int]: ...

class AbstractMultivariateRealDistribution(MultivariateRealDistribution):
    """
    public abstract class AbstractMultivariateRealDistribution extends `Object <http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true>` implements :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
    
        Base class for multivariate probability distributions.
    
        Since:
            3.1
    """
    def getDimension(self) -> int:
        """
            Gets the number of random variables of the distribution. It is the size of the array returned by the
            :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample` method.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.getDimension` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
        
            Returns:
                the number of variables.
        
        
        """
        ...
    def reseedRandomGenerator(self, long: int) -> None:
        """
            Reseeds the random generator used to generate samples.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.reseedRandomGenerator` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
        
            Parameters:
                seed (long): Seed with which to initialize the random number generator.
        
        
        """
        ...
    @typing.overload
    def sample(self) -> typing.MutableSequence[float]:
        """
            Generates a random value vector sampled from this distribution.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
        
            Returns:
                a random value vector.
        
        """
        ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]:
        """
            Generates a list of a random value vectors from the distribution.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
        
            Parameters:
                sampleSize (int): the number of random vectors to generate.
        
            Returns:
                an array representing the random samples.
        
            Also see:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample`
        
        
        """
        ...

class AbstractRealDistribution(RealDistribution, java.io.Serializable):
    """
    public abstract class AbstractRealDistribution extends `Object <http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html?is-external=true>` implements :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`, `Serializable <http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true>`
    
        Base class for probability distributions on the reals. Default implementations are provided for some of the methods that
        do not vary from distribution to distribution.
    
        Since:
            3.0
    
        Also see:
            :meth:`~serialized`
    """
    SOLVER_DEFAULT_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    """
    public static final double SOLVER_DEFAULT_ABSOLUTE_ACCURACY
    
        Default accuracy.
    
        Also see:
            :meth:`~constant`
    
    
    """
    def inverseCumulativeProbability(self, double: float) -> float:
        """
            The default implementation returns
        
              - :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.getSupportLowerBound` for :code:`p = 0`,
              - :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.getSupportUpperBound` for :code:`p = 1`.
        
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.inverseCumulativeProbability` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`
        
            Parameters:
                p (double): the cumulative probability
        
            Returns:
                the smallest :code:`p`-quantile of this distribution (largest 0-quantile for :code:`p = 0`)
        
        
        """
        ...
    @typing.overload
    def probability(self, double: float) -> float:
        """
            For a random variable :code:`X` whose values are distributed according to this distribution, this method returns
            :code:`P(x0 < X <= x1)`.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.probability` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`
        
            Parameters:
                x0 (double): Lower bound (excluded).
                x1 (double): Upper bound (included).
        
            Returns:
                the probability that a random variable with this distribution takes a value between :code:`x0` and :code:`x1`, excluding
                the lower and including the upper endpoint.
        
            Raises:
                :class:`~fr.cnes.sirius.patrius.math.exception.NumberIsTooLargeException`: if :code:`x0 > x1`. The default implementation uses the identity :code:`P(x0 < X <= x1) = P(X <= x1) - P(X <= x0)`
        
            Since:
                3.1
        
            For a random variable :code:`X` whose values are distributed according to this distribution, this method returns
            :code:`P(X = x)`. In other words, this method represents the probability mass function (PMF) for the distribution.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.probability` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`
        
            Parameters:
                x (double): the point at which the PMF is evaluated
        
            Returns:
                zero.
        
            Since:
                3.1
        
        
        """
        ...
    @typing.overload
    def probability(self, double: float, double2: float) -> float: ...
    def reseedRandomGenerator(self, long: int) -> None:
        """
            Reseed the random generator used to generate samples.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.reseedRandomGenerator` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`
        
            Parameters:
                seed (long): the new seed
        
        
        """
        ...
    @typing.overload
    def sample(self) -> float:
        """
            Generate a random value sampled from this distribution. The default implementation uses the ` inversion method.
            <http://en.wikipedia.org/wiki/Inverse_transform_sampling>`
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.sample` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`
        
            Returns:
                a random value.
        
        """
        ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]:
        """
            Generate a random sample from the distribution. The default implementation generates the sample by calling
            :meth:`~fr.cnes.sirius.patrius.math.distribution.AbstractRealDistribution.sample` in a loop.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution.sample` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.RealDistribution`
        
            Parameters:
                sampleSize (int): the number of random values to generate
        
            Returns:
                an array representing the random sample
        
        
        """
        ...

class BetaDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getAlpha(self) -> float: ...
    def getBeta(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class BinomialDistribution(AbstractIntegerDistribution):
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    def getNumberOfTrials(self) -> int: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getProbabilityOfSuccess(self) -> float: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def probability(self, int: int) -> float: ...

class CauchyDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getMedian(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getScale(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def inverseCumulativeProbability(self, double: float) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class ChiSquaredDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getDegreesOfFreedom(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class ExponentialDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getMean(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def inverseCumulativeProbability(self, double: float) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...
    @typing.overload
    def sample(self) -> float: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]: ...

class FDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getDenominatorDegreesOfFreedom(self) -> float: ...
    def getNumeratorDegreesOfFreedom(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class GammaDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getScale(self) -> float: ...
    def getShape(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...
    @typing.overload
    def sample(self) -> float: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]: ...

class HypergeometricDistribution(AbstractIntegerDistribution):
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, int: int, int2: int, int3: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int, int3: int): ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    def getNumberOfSuccesses(self) -> int: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getPopulationSize(self) -> int: ...
    def getSampleSize(self) -> int: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def probability(self, int: int) -> float: ...
    def upperCumulativeProbability(self, int: int) -> float: ...

class LogNormalDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getScale(self) -> float: ...
    def getShape(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...
    @typing.overload
    def probability(self, double: float) -> float: ...
    @typing.overload
    def probability(self, double: float, double2: float) -> float: ...
    @typing.overload
    def sample(self) -> float: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]: ...

_MixtureMultivariateRealDistribution__T = typing.TypeVar('_MixtureMultivariateRealDistribution__T', bound=MultivariateRealDistribution)  # <T>
class MixtureMultivariateRealDistribution(AbstractMultivariateRealDistribution, typing.Generic[_MixtureMultivariateRealDistribution__T]):
    """
    public class MixtureMultivariateRealDistribution<T extends :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`> extends :class:`~fr.cnes.sirius.patrius.math.distribution.AbstractMultivariateRealDistribution`
    
        Class for representing ` mixture model <http://en.wikipedia.org/wiki/Mixture_model>` distributions.
    
        Since:
            3.1
    """
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, list: java.util.List[fr.cnes.sirius.patrius.math.util.Pair[float, _MixtureMultivariateRealDistribution__T]]): ...
    @typing.overload
    def __init__(self, list: java.util.List[fr.cnes.sirius.patrius.math.util.Pair[float, _MixtureMultivariateRealDistribution__T]]): ...
    def density(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float:
        """
            Returns the probability density function (PDF) of this distribution evaluated at the specified point :code:`x`. In
            general, the PDF is the derivative of the cumulative distribution function. If the derivative does not exist at
            :code:`x`, then an appropriate replacement should be returned, e.g. :code:`Double.POSITIVE_INFINITY`,
            :code:`Double.NaN`, or the limit inferior or limit superior of the difference quotient.
        
            Parameters:
                values (double[]): Point at which the PDF is evaluated.
        
            Returns:
                the value of the probability density function at point :code:`x`.
        
        
        """
        ...
    def getComponents(self) -> java.util.List[fr.cnes.sirius.patrius.math.util.Pair[float, _MixtureMultivariateRealDistribution__T]]: ...
    def reseedRandomGenerator(self, long: int) -> None:
        """
            Reseeds the random generator used to generate samples.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.reseedRandomGenerator` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
        
            Overrides:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.AbstractMultivariateRealDistribution.reseedRandomGenerator` in
                class :class:`~fr.cnes.sirius.patrius.math.distribution.AbstractMultivariateRealDistribution`
        
            Parameters:
                seed (long): Seed with which to initialize the random number generator.
        
        
        """
        ...
    @typing.overload
    def sample(self) -> typing.MutableSequence[float]:
        """
            Generates a random value vector sampled from this distribution.
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution.sample` in
                interface :class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateRealDistribution`
        
            Specified by:
                :meth:`~fr.cnes.sirius.patrius.math.distribution.AbstractMultivariateRealDistribution.sample` in
                class :class:`~fr.cnes.sirius.patrius.math.distribution.AbstractMultivariateRealDistribution`
        
            Returns:
                a random value vector.
        
        
        """
        ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]: ...

class MultivariateNormalDistribution(AbstractMultivariateRealDistribution):
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    def density(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> float: ...
    def getCovariances(self) -> fr.cnes.sirius.patrius.math.linear.RealMatrix: ...
    def getMeans(self) -> typing.MutableSequence[float]: ...
    def getStandardDeviations(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def sample(self) -> typing.MutableSequence[float]: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[typing.MutableSequence[float]]: ...

class NormalDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getMean(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getStandardDeviation(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...
    @typing.overload
    def probability(self, double: float) -> float: ...
    @typing.overload
    def probability(self, double: float, double2: float) -> float: ...
    @typing.overload
    def sample(self) -> float: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]: ...

class PascalDistribution(AbstractIntegerDistribution):
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    def getNumberOfSuccesses(self) -> int: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getProbabilityOfSuccess(self) -> float: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def probability(self, int: int) -> float: ...

class PoissonDistribution(AbstractIntegerDistribution):
    DEFAULT_MAX_ITERATIONS: typing.ClassVar[int] = ...
    DEFAULT_EPSILON: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, int: int): ...
    @typing.overload
    def __init__(self, double: float, int: int): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, int: int): ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    def getMean(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def normalApproximateProbability(self, int: int) -> float: ...
    def probability(self, int: int) -> float: ...
    @typing.overload
    def sample(self) -> int: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[int]: ...

class TDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getDegreesOfFreedom(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class TriangularDistribution(AbstractRealDistribution):
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getMode(self) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def inverseCumulativeProbability(self, double: float) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class UniformIntegerDistribution(AbstractIntegerDistribution):
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, int: int, int2: int): ...
    @typing.overload
    def __init__(self, int: int, int2: int): ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def probability(self, int: int) -> float: ...
    @typing.overload
    def sample(self) -> int: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[int]: ...

class UniformRealDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self): ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...
    @typing.overload
    def sample(self) -> float: ...
    @typing.overload
    def sample(self, int: int) -> typing.MutableSequence[float]: ...

class WeibullDistribution(AbstractRealDistribution):
    DEFAULT_INVERSE_ABSOLUTE_ACCURACY: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, double: float, double2: float, double3: float): ...
    def cumulativeProbability(self, double: float) -> float: ...
    def density(self, double: float) -> float: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getScale(self) -> float: ...
    def getShape(self) -> float: ...
    def getSupportLowerBound(self) -> float: ...
    def getSupportUpperBound(self) -> float: ...
    def inverseCumulativeProbability(self, double: float) -> float: ...
    def isSupportConnected(self) -> bool: ...
    def isSupportLowerBoundInclusive(self) -> bool: ...
    def isSupportUpperBoundInclusive(self) -> bool: ...

class ZipfDistribution(AbstractIntegerDistribution):
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def cumulativeProbability(self, int: int, int2: int) -> float: ...
    @typing.overload
    def cumulativeProbability(self, int: int) -> float: ...
    def getExponent(self) -> float: ...
    def getNumberOfElements(self) -> int: ...
    def getNumericalMean(self) -> float: ...
    def getNumericalVariance(self) -> float: ...
    def getSupportLowerBound(self) -> int: ...
    def getSupportUpperBound(self) -> int: ...
    def isSupportConnected(self) -> bool: ...
    def probability(self, int: int) -> float: ...

class MixtureMultivariateNormalDistribution(MixtureMultivariateRealDistribution[MultivariateNormalDistribution]):
    """
    public class MixtureMultivariateNormalDistribution extends :class:`~fr.cnes.sirius.patrius.math.distribution.MixtureMultivariateRealDistribution`<:class:`~fr.cnes.sirius.patrius.math.distribution.MultivariateNormalDistribution`>
    
        Class that implements a mixture of Gaussian ditributions.
    """
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, list: java.util.List[fr.cnes.sirius.patrius.math.util.Pair[float, MultivariateNormalDistribution]]): ...
    @typing.overload
    def __init__(self, list: java.util.List[fr.cnes.sirius.patrius.math.util.Pair[float, MultivariateNormalDistribution]]): ...
    @staticmethod
    def createComponents(doubleArray: typing.Union[typing.List[float], jpype.JArray], doubleArray2: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], doubleArray3: typing.Union[typing.List[typing.MutableSequence[typing.MutableSequence[float]]], jpype.JArray]) -> java.util.List[fr.cnes.sirius.patrius.math.util.Pair[float, MultivariateNormalDistribution]]: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("fr.cnes.sirius.patrius.math.distribution")``.

    AbstractIntegerDistribution: typing.Type[AbstractIntegerDistribution]
    AbstractMultivariateRealDistribution: typing.Type[AbstractMultivariateRealDistribution]
    AbstractRealDistribution: typing.Type[AbstractRealDistribution]
    BetaDistribution: typing.Type[BetaDistribution]
    BinomialDistribution: typing.Type[BinomialDistribution]
    CauchyDistribution: typing.Type[CauchyDistribution]
    ChiSquaredDistribution: typing.Type[ChiSquaredDistribution]
    ExponentialDistribution: typing.Type[ExponentialDistribution]
    FDistribution: typing.Type[FDistribution]
    GammaDistribution: typing.Type[GammaDistribution]
    HypergeometricDistribution: typing.Type[HypergeometricDistribution]
    IntegerDistribution: typing.Type[IntegerDistribution]
    KolmogorovSmirnovDistribution: typing.Type[KolmogorovSmirnovDistribution]
    LogNormalDistribution: typing.Type[LogNormalDistribution]
    MixtureMultivariateNormalDistribution: typing.Type[MixtureMultivariateNormalDistribution]
    MixtureMultivariateRealDistribution: typing.Type[MixtureMultivariateRealDistribution]
    MultivariateNormalDistribution: typing.Type[MultivariateNormalDistribution]
    MultivariateRealDistribution: typing.Type[MultivariateRealDistribution]
    NormalDistribution: typing.Type[NormalDistribution]
    PascalDistribution: typing.Type[PascalDistribution]
    PoissonDistribution: typing.Type[PoissonDistribution]
    RealDistribution: typing.Type[RealDistribution]
    TDistribution: typing.Type[TDistribution]
    TriangularDistribution: typing.Type[TriangularDistribution]
    UniformIntegerDistribution: typing.Type[UniformIntegerDistribution]
    UniformRealDistribution: typing.Type[UniformRealDistribution]
    WeibullDistribution: typing.Type[WeibullDistribution]
    ZipfDistribution: typing.Type[ZipfDistribution]
