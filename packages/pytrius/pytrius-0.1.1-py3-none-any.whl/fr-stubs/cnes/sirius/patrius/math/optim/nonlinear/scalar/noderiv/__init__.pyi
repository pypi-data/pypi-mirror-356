
import sys
if sys.version_info >= (3, 8):
    from typing import Protocol
else:
    from typing_extensions import Protocol

import fr.cnes.sirius.patrius.math.analysis
import fr.cnes.sirius.patrius.math.linear
import fr.cnes.sirius.patrius.math.optim
import fr.cnes.sirius.patrius.math.optim.nonlinear.scalar
import fr.cnes.sirius.patrius.math.random
import java.util
import jpype
import typing



class AbstractSimplex(fr.cnes.sirius.patrius.math.optim.OptimizationData):
    def build(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]) -> None: ...
    def evaluate(self, multivariateFunction: typing.Union[fr.cnes.sirius.patrius.math.analysis.MultivariateFunction, typing.Callable], comparator: typing.Union[java.util.Comparator[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], int]]) -> None: ...
    def getDimension(self) -> int: ...
    def getPoint(self, int: int) -> fr.cnes.sirius.patrius.math.optim.PointValuePair: ...
    def getPoints(self) -> typing.MutableSequence[fr.cnes.sirius.patrius.math.optim.PointValuePair]: ...
    def getSize(self) -> int: ...
    def iterate(self, multivariateFunction: typing.Union[fr.cnes.sirius.patrius.math.analysis.MultivariateFunction, typing.Callable], comparator: typing.Union[java.util.Comparator[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], int]]) -> None: ...

class BOBYQAOptimizer(fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.MultivariateOptimizer):
    MINIMUM_PROBLEM_DIMENSION: typing.ClassVar[int] = ...
    DEFAULT_INITIAL_RADIUS: typing.ClassVar[float] = ...
    DEFAULT_STOPPING_RADIUS: typing.ClassVar[float] = ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float): ...

class CMAESOptimizer(fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.MultivariateOptimizer):
    def __init__(self, int: int, double: float, boolean: bool, int2: int, int3: int, randomGenerator: fr.cnes.sirius.patrius.math.random.RandomGenerator, boolean2: bool, convergenceChecker: typing.Union[fr.cnes.sirius.patrius.math.optim.ConvergenceChecker[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[int, fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], bool]]): ...
    def getStatisticsDHistory(self) -> java.util.List[fr.cnes.sirius.patrius.math.linear.RealMatrix]: ...
    def getStatisticsFitnessHistory(self) -> java.util.List[float]: ...
    def getStatisticsMeanHistory(self) -> java.util.List[fr.cnes.sirius.patrius.math.linear.RealMatrix]: ...
    def getStatisticsSigmaHistory(self) -> java.util.List[float]: ...
    def optimize(self, *optimizationData: fr.cnes.sirius.patrius.math.optim.OptimizationData) -> fr.cnes.sirius.patrius.math.optim.PointValuePair: ...
    class PopulationSize(fr.cnes.sirius.patrius.math.optim.OptimizationData):
        def __init__(self, int: int): ...
        def getPopulationSize(self) -> int: ...
    class Sigma(fr.cnes.sirius.patrius.math.optim.OptimizationData):
        def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
        def getSigma(self) -> typing.MutableSequence[float]: ...

class PowellOptimizer(fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.MultivariateOptimizer):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, double: float, double2: float, double3: float, double4: float, convergenceChecker: typing.Union[fr.cnes.sirius.patrius.math.optim.ConvergenceChecker[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[int, fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], bool]]): ...
    @typing.overload
    def __init__(self, double: float, double2: float, convergenceChecker: typing.Union[fr.cnes.sirius.patrius.math.optim.ConvergenceChecker[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[int, fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], bool]]): ...

class SimplexOptimizer(fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.MultivariateOptimizer):
    @typing.overload
    def __init__(self, double: float, double2: float): ...
    @typing.overload
    def __init__(self, convergenceChecker: typing.Union[fr.cnes.sirius.patrius.math.optim.ConvergenceChecker[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[int, fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], bool]]): ...
    def optimize(self, *optimizationData: fr.cnes.sirius.patrius.math.optim.OptimizationData) -> fr.cnes.sirius.patrius.math.optim.PointValuePair: ...

class MultiDirectionalSimplex(AbstractSimplex):
    """
    public class MultiDirectionalSimplex extends :class:`~fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.noderiv.AbstractSimplex`
    
        This class implements the multi-directional direct search method.
    
        Since:
            3.0
    """
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float, double3: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], double2: float, double3: float): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, double3: float): ...
    def iterate(self, multivariateFunction: typing.Union[fr.cnes.sirius.patrius.math.analysis.MultivariateFunction, typing.Callable], comparator: typing.Union[java.util.Comparator[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], int]]) -> None: ...

class NelderMeadSimplex(AbstractSimplex):
    """
    public class NelderMeadSimplex extends :class:`~fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.noderiv.AbstractSimplex`
    
        This class implements the Nelder-Mead simplex algorithm.
    
        Since:
            3.0
    """
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[float], jpype.JArray], double2: float, double3: float, double4: float, double5: float): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray]): ...
    @typing.overload
    def __init__(self, doubleArray: typing.Union[typing.List[typing.MutableSequence[float]], jpype.JArray], double2: float, double3: float, double4: float, double5: float): ...
    @typing.overload
    def __init__(self, int: int): ...
    @typing.overload
    def __init__(self, int: int, double: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, double3: float, double4: float): ...
    @typing.overload
    def __init__(self, int: int, double: float, double2: float, double3: float, double4: float, double5: float): ...
    def iterate(self, multivariateFunction: typing.Union[fr.cnes.sirius.patrius.math.analysis.MultivariateFunction, typing.Callable], comparator: typing.Union[java.util.Comparator[fr.cnes.sirius.patrius.math.optim.PointValuePair], typing.Callable[[fr.cnes.sirius.patrius.math.optim.PointValuePair, fr.cnes.sirius.patrius.math.optim.PointValuePair], int]]) -> None: ...


class __module_protocol__(Protocol):
    # A module protocol which reflects the result of ``jp.JPackage("fr.cnes.sirius.patrius.math.optim.nonlinear.scalar.noderiv")``.

    AbstractSimplex: typing.Type[AbstractSimplex]
    BOBYQAOptimizer: typing.Type[BOBYQAOptimizer]
    CMAESOptimizer: typing.Type[CMAESOptimizer]
    MultiDirectionalSimplex: typing.Type[MultiDirectionalSimplex]
    NelderMeadSimplex: typing.Type[NelderMeadSimplex]
    PowellOptimizer: typing.Type[PowellOptimizer]
    SimplexOptimizer: typing.Type[SimplexOptimizer]
