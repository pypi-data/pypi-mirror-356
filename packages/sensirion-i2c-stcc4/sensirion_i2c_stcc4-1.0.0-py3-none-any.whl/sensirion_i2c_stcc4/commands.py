#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# (c) Copyright 2025 Sensirion AG, Switzerland
#
#     THIS FILE IS AUTOMATICALLY GENERATED!
#
# Generator:     sensirion-driver-generator 1.2.0
# Product:       stcc4
# Model-Version: 3.4.0
#
"""
The transfer classes specify the data that is transferred between host and sensor. The generated transfer classes
are used by the driver class and not intended for direct use.
"""

from sensirion_driver_adapters.transfer import Transfer
from sensirion_driver_adapters.rx_tx_data import TxData, RxData


class StartContinuousMeasurement(Transfer):
    """
    After sending the start_continuous_measurement command, the sensor will begin measuring
    the CO2 gas concentration continuously with a sampling interval of 1 second.
    The recommended communication sequence for continuous measurement is as follows:
    1. The sensor is powered up into the idle state.
    2. The I2C controller sends a start_continuous_measurement command.
    3. The I2C controller periodically reads out data with the read_measurement command.
    4. If desired, stop taking measurements using the stop_continuous_measurement command.
    """

    CMD_ID = 0x218b

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class ReadMeasurementRaw(Transfer):
    """
    After the command *start_continuous_measurement* has been sent, the chip continuously measures and updates the
    measurement results.
    New results (co2_concentration, temperature, and relative_humidity) can be read continuously with this command.
    """

    CMD_ID = 0xec05

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData('>hHHH')


class StopContinuousMeasurement(Transfer):
    """
    After receiving the stop_continuous_measurement command, the sensor will finish the currently running measurement
    before returning to idle mode. Therefore, a wait time of one measurement interval plus a 200 ms clock tolerance is
    required before a new command is acknowledged.
    """

    CMD_ID = 0x3f86

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=1.2, slave_address=None, ignore_ack=False)


class MeasureSingleShot(Transfer):
    """
    The measure_single_shot command conducts an on-demand measurement of CO2 gas concentration.
    The typical communication sequence is as follows:
    1. The sensor is powered up with the exit_sleep_mode command if previously powered down using the enter_sleep_mode command.
    2. The I2C controller sends a measure_single_shot command and waits for the execution time.
    3. The I2C controller reads out data with the read_measurement command.
    4. Repeat steps 2-3 as required by the application.
    5. If desired, set the sensor to sleep with the enter_sleep_mode command.
    """

    CMD_ID = 0x219d

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.5, slave_address=None, ignore_ack=False)


class PerformForcedRecalibration(Transfer):
    """
    The forced recalibration (FRC) can be applied to correct the sensor's output by means of an externally obtained CO 2
    reference value.
    The recommended communication sequence for a successful FRC in continuous mode is as follows:
    1. Operate the STCC4 for at least 3 minutes. Ensure the sensor reading and environmental conditions, including CO2 concentration, are stable.
    2. The I2C controller sends the stop_continuous_measurement command (Section 5.3.2)
    3. Wait for the specified execution time of stop_continuous_measurement command.
    4. Issue the perform_forced_recalibration command with the target CO2 concentration and read out the applied FRC correction.

    The recommended communication sequence for a successful FRC in single shot mode is as follows:
    1. Operate the STCC4 for at least 3 minutes. For sampling intervals significantly larger than 10 seconds, increase the operation time accordingly. Ensure the sensor reading and environmental conditions, including CO2 concentration, are stable.
    2. Issue the perform_forced_recalibration command with the reference CO2 concentration and read out the applied FRC correction. The sensor must remain in idle mode after operation before command execution.
    """

    CMD_ID = 0x362f

    def __init__(self, target_CO2_concentration):
        self._target_CO2_concentration = target_CO2_concentration

    def pack(self):
        return self.tx_data.pack([self._target_CO2_concentration])

    tx = TxData(CMD_ID, '>Hh', device_busy_delay=0.09, slave_address=None, ignore_ack=False)
    rx = RxData('>h')


class GetProductId(Transfer):
    """
    The get_product_ID command retrieves the product identifier and serial number. The command can be used to check
    communication with the sensor.
    """

    CMD_ID = 0x365b

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.001, slave_address=None, ignore_ack=False)
    rx = RxData(descriptor='>I4H', convert_to_int=True)


class SetRhtCompensation(Transfer):
    """
    When the SHT4x is not directly connected to the STCC4 for humidity and temperature compensation,
    the set_rht_compensation command allows external input of relative humidity (RH) and temperature (T) values.
    The temperature value must be provided from the RHT sensor providing the RH value for
    correct absolute humidity calculation.
    The written RHT values are applied for compensation after a maximum of one measurement interval.
    The default or last written values are used for RHT compensation until overwritten.
    Power cycling resets the sensor to the default values of 25°C and 50 %RH.
    """

    CMD_ID = 0xe000

    def __init__(self, raw_temperature, raw_humidity):
        self._raw_temperature = raw_temperature
        self._raw_humidity = raw_humidity

    def pack(self):
        return self.tx_data.pack([self._raw_temperature, self._raw_humidity])

    tx = TxData(CMD_ID, '>HHH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class SetPressureCompensationRaw(Transfer):
    """
    External pressure values can be set through the set_pressure_compensation command. The written pressure value is
    applied for pressure compensation after a maximum of one measurement interval. Power cycling resets the sensor to
    the default value of 101'300 Pa. The default or the last written value is used in pressure compensation until overwritten.
    """

    CMD_ID = 0xe016

    def __init__(self, pressure):
        self._pressure = pressure

    def pack(self):
        return self.tx_data.pack([self._pressure])

    tx = TxData(CMD_ID, '>HH', device_busy_delay=0.001, slave_address=None, ignore_ack=False)


class PerformSelfTest(Transfer):
    """
    The perform_self_test command can be used as an end-of-line test to check the sensor functionality.
    Word[0] = 0 → pass
    Word[0] ≠ 0 → malfunction detected
    """

    CMD_ID = 0x278c

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.36, slave_address=None, ignore_ack=False)
    rx = RxData('>H')


class PerformConditioning(Transfer):
    """
    The perform_conditioning command is recommended to improve sensor performance when the sensor has not
    completed measurements for more than 3 hours. It is recommended to allow a settling time of 2 seconds after the
    execution time is complete.
    The recommended communication sequence is as follows:
    1. The sensor is woken up with the exit_sleep_mode command if previously put to sleep using the enter_sleep_mode command.
    2. The I2C controller sends a perform_conditioning command.
    3. Wait for the specified execution time of perform_conditioning command plus a 2 second settling time.
    4. The I2C controller sends a measurement command (e.g. start_continuous_measurement command or measure_single_shot command.
    """

    CMD_ID = 0x29bc

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=22.0, slave_address=None, ignore_ack=False)


class EnterSleepMode(Transfer):
    """
    The enter_sleep_mode command sets the sensor to sleep mode through the I2C interface. The written relative humidity,
    temperature, and pressure compensation values as well as the ASC state will be retained while in sleep mode.
    """

    CMD_ID = 0x3650

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.002, slave_address=None, ignore_ack=False)


class ExitSleepMode(Transfer):
    """
    The exit_sleep_mode command sets the sensor to idle mode through the I2C interface. The sensor's idle state can be
    verified by reading out the product ID.
    """

    CMD_ID = 0x0

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>B', device_busy_delay=0.005, slave_address=None, ignore_ack=True)


class EnableTestingMode(Transfer):
    """
    The enable_testing_mode command is used to test the sensor with  the ASC algorithm disabled.
    The sensor state can be verified by reading out the sensor status word in the read_measurement command.
    """

    CMD_ID = 0x3fbc

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class DisableTestingMode(Transfer):
    """
    The disable_testing_mode command is used to exit the testing mode.
    The sensor state can be verified by reading out the sensor status word in the read_measurement command.
    """

    CMD_ID = 0x3f3d

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H')


class PerformFactoryReset(Transfer):
    """The perform_factory_reset command can be used to reset the FRC and ASC algorithm history."""

    CMD_ID = 0x3632

    def pack(self):
        return self.tx_data.pack([])

    tx = TxData(CMD_ID, '>H', device_busy_delay=0.09, slave_address=None, ignore_ack=False)
    rx = RxData('>H')
