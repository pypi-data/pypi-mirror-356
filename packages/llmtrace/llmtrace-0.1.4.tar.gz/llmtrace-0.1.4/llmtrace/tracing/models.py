"""
Data models for LLMTrace.

This module defines the structure of sessions, messages, metrics, feedback,
and errors for consistent storage and retrieval across different backends.
These dataclasses facilitate type-hinting and clear data representation.
"""

import zlib
from dataclasses import dataclass, field
from datetime import datetime
from typing import Optional, Dict, Any, List

@dataclass
class Session:
    """
    Represents a single tracing session or conversation flow.

    A session encapsulates a series of LLM interactions, metrics, and feedback,
    providing a logical grouping for observability.

    :param id: The unique identifier for the session. Auto-generated by the database.
    :type id: Optional[int]
    :param name: An optional name for the session (e.g., "Customer Support Chat").
    :type name: Optional[str]
    :param start_time: The timestamp when the session started. Defaults to the current time.
    :type start_time: datetime
    :param end_time: The timestamp when the session ended. Defaults to None.
    :type end_time: Optional[datetime]
    :param total_tokens: The total number of tokens used in the session. Defaults to 0.
    :type total_tokens: int
    :param total_cost: The estimated total cost of the session. Defaults to 0.0.
    :type total_cost: float
    :param user_id: An optional identifier for the user associated with the session.
    :type user_id: Optional[str]
    """
    id: Optional[int] = None
    name: Optional[str] = None
    start_time: datetime = field(default_factory=datetime.now)
    end_time: Optional[datetime] = None
    total_tokens: int = 0
    total_cost: float = 0.0
    user_id: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """
        Converts the Session object to a dictionary.

        Timestamps are converted to ISO 8601 format strings.

        :returns: A dictionary representation of the session.
        :rtype: Dict[str, Any]
        """
        return {
            "id": self.id,
            "name": self.name,
            "start_time": self.start_time.isoformat() if self.start_time else None,
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "total_tokens": self.total_tokens,
            "total_cost": self.total_cost,
            "user_id": self.user_id,
        }

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]):
        """
        Creates a Session object from a database row.

        Handles potential differences in row access (e.g., `aiosqlite.Row`, `asyncpg.Record`)
        and converts timestamp strings back to `datetime` objects.

        :param row: A dictionary-like object representing a database row.
        :type row: Dict[str, Any]
        :returns: A Session object populated with data from the row.
        :rtype: Session
        """
        get_value = lambda r, key: r[key] if isinstance(r, dict) or hasattr(r, '__getitem__') else getattr(r, key)

        start_time_str = get_value(row, "start_time")
        end_time_str = get_value(row, "end_time")

        return cls(
            id=get_value(row, "id"),
            name=get_value(row, "name"),
            start_time=datetime.fromisoformat(start_time_str) if isinstance(start_time_str, str) else start_time_str,
            end_time=datetime.fromisoformat(end_time_str) if isinstance(end_time_str, str) and end_time_str else end_time_str,
            total_tokens=get_value(row, "total_tokens"),
            total_cost=get_value(row, "total_cost"),
            user_id=get_value(row, "user_id"),
        )

@dataclass
class Message:
    """
    Represents a single message (prompt or response) within a session.

    Message content is compressed for efficient storage and decompressed upon retrieval.

    :param id: The unique identifier for the message. Auto-generated by the database.
    :type id: Optional[int]
    :param session_id: The ID of the session this message belongs to.
    :type session_id: int
    :param role: The role of the message ('user', 'assistant', 'system', 'tool').
    :type role: str
    :param content: The text content of the message.
    :type content: str
    :param timestamp: The timestamp when the message was logged. Defaults to the current time.
    :type timestamp: datetime
    :param tokens_in: Number of input tokens for the message. Defaults to 0.
    :type tokens_in: int
    :param tokens_out: Number of output tokens for the message. Defaults to 0.
    :type tokens_out: int
    :param cost: Estimated cost of the message. Defaults to 0.0.
    :type cost: float
    :param model_name: The name of the LLM model used for this message. Defaults to None.
    :type model_name: Optional[str]
    :param metadata: A dictionary for additional LLM-specific data or custom attributes. Defaults to an empty dict.
    :type metadata: Dict[str, Any]
    """
    id: Optional[int] = None
    session_id: int = None
    role: str = ""
    content: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    tokens_in: int = 0
    tokens_out: int = 0
    cost: float = 0.0
    model_name: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        """
        Converts the Message object to a dictionary.

        Timestamps are converted to ISO 8601 format strings.

        :returns: A dictionary representation of the message.
        :rtype: Dict[str, Any]
        """
        return {
            "id": self.id,
            "session_id": self.session_id,
            "role": self.role,
            "content": self.content,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
            "tokens_in": self.tokens_in,
            "tokens_out": self.tokens_out,
            "cost": self.cost,
            "model_name": self.model_name,
            "metadata": self.metadata,
        }

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]):
        """
        Creates a Message object from a database row.

        Decompresses the 'content' field if it's stored as BLOB/BYTEA.
        Handles potential differences in row access and converts timestamp strings.

        :param row: A dictionary-like object representing a database row.
        :type row: Dict[str, Any]
        :returns: A Message object populated with data from the row.
        :rtype: Message
        """
        get_value = lambda r, key: r[key] if isinstance(r, dict) or hasattr(r, '__getitem__') else getattr(r, key)

        content_raw = get_value(row, "content")
        content = ""
        if isinstance(content_raw, bytes):
            try:
                content = zlib.decompress(content_raw).decode('utf-8')
            except zlib.error:
                content = content_raw.decode('utf-8', errors='ignore')
        elif isinstance(content_raw, str):
            content = content_raw

        timestamp_str = get_value(row, "timestamp")
        
        return cls(
            id=get_value(row, "id"),
            session_id=get_value(row, "session_id"),
            role=get_value(row, "role"),
            content=content,
            timestamp=datetime.fromisoformat(timestamp_str) if isinstance(timestamp_str, str) else timestamp_str,
            tokens_in=get_value(row, "tokens_in"),
            tokens_out=get_value(row, "tokens_out"),
            cost=get_value(row, "cost"),
            model_name=get_value(row, "model_name"),
        )

@dataclass
class Metric:
    """
    Represents a custom metric logged for a session.

    Metrics can be used to store quantitative evaluation results, performance indicators,
    or any other numerical data associated with an LLM interaction.

    :param id: The unique identifier for the metric. Auto-generated by the database.
    :type id: Optional[int]
    :param session_id: The ID of the session this metric belongs to.
    :type session_id: int
    :param name: The name of the metric (e.g., 'latency_ms', 'response_quality_score').
    :type name: str
    :param value: The numerical value of the metric.
    :type value: float
    :param timestamp: The timestamp when the metric was logged. Defaults to the current time.
    :type timestamp: datetime
    """
    id: Optional[int] = None
    session_id: int = None
    name: str = ""
    value: float = 0.0
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        """
        Converts the Metric object to a dictionary.

        Timestamps are converted to ISO 8601 format strings.

        :returns: A dictionary representation of the metric.
        :rtype: Dict[str, Any]
        """
        return {
            "id": self.id,
            "session_id": self.session_id,
            "name": self.name,
            "value": self.value,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
        }

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]):
        """
        Creates a Metric object from a database row.

        Handles potential differences in row access and converts timestamp strings.

        :param row: A dictionary-like object representing a database row.
        :type row: Dict[str, Any]
        :returns: A Metric object populated with data from the row.
        :rtype: Metric
        """
        get_value = lambda r, key: r[key] if isinstance(r, dict) or hasattr(r, '__getitem__') else getattr(r, key)
        timestamp_str = get_value(row, "timestamp")

        return cls(
            id=get_value(row, "id"),
            session_id=get_value(row, "session_id"),
            name=get_value(row, "name"),
            value=get_value(row, "value"),
            timestamp=datetime.fromisoformat(timestamp_str) if isinstance(timestamp_str, str) else timestamp_str,
        )

@dataclass
class Feedback:
    """
    Represents user feedback for a session or specific message.

    Feedback can be used to capture user satisfaction, relevance, or other qualitative
    assessments of LLM responses.

    :param id: The unique identifier for the feedback entry. Auto-generated by the database.
    :type id: Optional[int]
    :param session_id: The ID of the session this feedback belongs to.
    :type session_id: int
    :param message_id: The ID of the specific message the feedback is for. Defaults to None (session-level feedback).
    :type message_id: Optional[int]
    :param type: The type of feedback ('rating', 'thumb_up', 'thumb_down', 'relevance', etc.). Defaults to "rating".
    :type type: str
    :param score: The numerical score of the feedback (e.g., 1-5 for rating, 0/1 for thumbs). Defaults to None.
    :type score: Optional[int]
    :param comment: An optional text comment for the feedback. Defaults to None.
    :type comment: Optional[str]
    :param timestamp: The timestamp when the feedback was logged. Defaults to the current time.
    :type timestamp: datetime
    """
    id: Optional[int] = None
    session_id: int = None
    message_id: Optional[int] = None
    type: str = "rating"
    score: Optional[int] = None
    comment: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        """
        Converts the Feedback object to a dictionary.

        Timestamps are converted to ISO 8601 format strings.

        :returns: A dictionary representation of the feedback.
        :rtype: Dict[str, Any]
        """
        return {
            "id": self.id,
            "session_id": self.session_id,
            "message_id": self.message_id,
            "type": self.type,
            "score": self.score,
            "comment": self.comment,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
        }

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]):
        """
        Creates a Feedback object from a database row.

        Handles potential differences in row access and converts timestamp strings.

        :param row: A dictionary-like object representing a database row.
        :type row: Dict[str, Any]
        :returns: A Feedback object populated with data from the row.
        :rtype: Feedback
        """
        get_value = lambda r, key: r[key] if isinstance(r, dict) or hasattr(r, '__getitem__') else getattr(r, key)
        timestamp_str = get_value(row, "timestamp")

        return cls(
            id=get_value(row, "id"),
            session_id=get_value(row, "session_id"),
            message_id=get_value(row, "message_id"),
            type=get_value(row, "type"),
            score=get_value(row, "score"),
            comment=get_value(row, "comment"),
            timestamp=datetime.fromisoformat(timestamp_str) if isinstance(timestamp_str, str) else timestamp_str,
        )

@dataclass
class Error:
    """
    Represents an error logged for a session or specific message.

    Error entries help in debugging and monitoring the reliability of LLM applications.

    :param id: The unique identifier for the error entry. Auto-generated by the database.
    :type id: Optional[int]
    :param session_id: The ID of the session this error belongs to.
    :type session_id: int
    :param message_id: The ID of the specific message related to the error. Defaults to None.
    :type message_id: Optional[int]
    :param error_type: The type of error (e.g., 'APIError', 'NetworkError', 'ValueError'). Defaults to None.
    :type error_type: Optional[str]
    :param message: A brief description of the error.
    :type message: str
    :param timestamp: The timestamp when the error was logged. Defaults to the current time.
    :type timestamp: datetime
    :param details: More detailed information about the error (e.g., stack trace, full error message). Defaults to None.
    :type details: Optional[str]
    """
    id: Optional[int] = None
    session_id: int = None
    message_id: Optional[int] = None
    error_type: Optional[str] = None
    message: str = ""
    timestamp: datetime = field(default_factory=datetime.now)
    details: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        """
        Converts the Error object to a dictionary.

        Timestamps are converted to ISO 8601 format strings.

        :returns: A dictionary representation of the error.
        :rtype: Dict[str, Any]
        """
        return {
            "id": self.id,
            "session_id": self.session_id,
            "message_id": self.message_id,
            "error_type": self.error_type,
            "message": self.message,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
            "details": self.details,
        }

    @classmethod
    def from_db_row(cls, row: Dict[str, Any]):
        """
        Creates an Error object from a database row.

        Handles potential differences in row access and converts timestamp strings.

        :param row: A dictionary-like object representing a database row.
        :type row: Dict[str, Any]
        :returns: An Error object populated with data from the row.
        :rtype: Error
        """
        get_value = lambda r, key: r[key] if isinstance(r, dict) or hasattr(r, '__getitem__') else getattr(r, key)
        timestamp_str = get_value(row, "timestamp")

        return cls(
            id=get_value(row, "id"),
            session_id=get_value(row, "session_id"),
            message_id=get_value(row, "message_id"),
            error_type=get_value(row, "error_type"),
            message=get_value(row, "message"),
            timestamp=datetime.fromisoformat(timestamp_str) if isinstance(timestamp_str, str) else timestamp_str,
            details=get_value(row, "details"),
        )
