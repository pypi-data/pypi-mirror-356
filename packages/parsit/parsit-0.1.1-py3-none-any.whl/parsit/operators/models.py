import copy 
import json 
import os 
from typing import Callable 
from loguru import logger
from parsit .config .constants import PARSE_TYPE_OCR ,PARSE_TYPE_TXT 
from parsit .config .enums import SupportedPdfParseMethod 
from parsit .data .data_reader_writer import DataWriter 
from parsit .data .dataset import Dataset 
from parsit .libs .draw_bbox import draw_model_bbox 
from parsit .libs .version import __version__ 
from parsit .operators .pipes import PipeResult 
from parsit .pdf_parse_union_core_v2 import pdf_parse_union 
from parsit .operators import InferenceResultBase 

class InferenceResult (InferenceResultBase ):
    def __init__ (self ,inference_results :list ,dataset :Dataset, form_invoice_data: list = None, signature_data: list = None):
        """Initialized method.

        Args:
            inference_results (list): the inference result generated by model
            dataset (Dataset): the dataset related with model inference result
            form_invoice_data (list, optional): form and invoice extraction results
            signature_data (list, optional): signature detection results
        """
        self._infer_res = inference_results 
        self._dataset = dataset 
        self._form_invoice_data = form_invoice_data
        self._signature_data = signature_data or [] 

    def draw_model (self ,file_path :str )->None :
        """Draw model inference result.

        Args:
            file_path (str): the output file path
        """
        dir_name =os .path .dirname (file_path )
        base_name =os .path .basename (file_path )
        if not os .path .exists (dir_name ):
            os .makedirs (dir_name ,exist_ok =True )
        draw_model_bbox (
        copy .deepcopy (self ._infer_res ),self ._dataset ,dir_name ,base_name 
        )

    def dump_model (self ,writer :DataWriter ,file_path :str ):
        """Dump model inference result to file.

        Args:
            writer (DataWriter): writer handle
            file_path (str): the location of target file
        """
        writer .write_string (
        file_path ,json .dumps (self ._infer_res ,ensure_ascii =False ,indent =4 )
        )

    def get_infer_res (self ):
        """Get the inference result.

        Returns:
            list: the inference result generated by model
        """
        return self ._infer_res 

    def get_form_invoice_data(self):
        """Get the aggregated form and invoice data."""
        return self._form_invoice_data
        
    def get_signature_data(self):
        """Get the signature detection data."""
        return self._signature_data

    def _convert_form_invoice_to_markdown(self) -> str:
        """Converts the aggregated form and invoice data to a Markdown string."""
        if not self._form_invoice_data:
            return "No form/invoice data to convert.\n"

        md_lines = ["# Form and Invoice Extraction Results\n"]
        for page_data in self._form_invoice_data:
            page_no = page_data.get("page_no", "N/A")
            extraction_result = page_data.get("extraction_result", {})
            md_lines.append(f"## Page {page_no}\n")
            if extraction_result:
                for key, value in extraction_result.items():
                    md_lines.append(f"- **{key}:** {value}")
            else:
                md_lines.append("- No data extracted for this page.")
            md_lines.append("\n")
        return "\n".join(md_lines)

    def _convert_signature_to_markdown(self) -> str:
        """Converts the signature detection data to a Markdown string."""
        if not self._signature_data:
            return "No signature data to convert.\n"

        md_lines = ["# Signature Detection Results\n"]
        for page_idx, page_signatures in enumerate(self._signature_data):
            if not page_signatures:
                continue
                
            md_lines.append(f"## Page {page_idx + 1}\n")
            for sig_idx, signature in enumerate(page_signatures, 1):
                bbox = signature.get('bbox', [])
                score = signature.get('score', 0)
                image_path = signature.get('image_path', 'Not saved')
                
                md_lines.append(f"### Signature {sig_idx}")
                md_lines.append(f"- **Bounding Box:** {bbox}")
                md_lines.append(f"- **Confidence:** {score:.2f}")
                if image_path != 'Not saved':
                    md_lines.append(f"- **Image:** ![]({image_path})\n")
                else:
                    md_lines.append("- **Image:** Not saved\n")
        
        return "\n".join(md_lines)

    def dump_form_invoice_data(self, writer: DataWriter, base_file_path: str, output_formats: list):
        """Dump form and invoice data to specified file formats if it exists."""
        if not self._form_invoice_data:
            logger.info("No form/invoice data to dump.")
        else:
            for fmt in output_formats:
                if fmt.lower() == "json":
                    file_path_json = f"{base_file_path}_form_invoice_data.json"
                    writer.write_string(
                        file_path_json, json.dumps(self._form_invoice_data, ensure_ascii=False, indent=4)
                    )
                    logger.info(f"Form/invoice data successfully dumped to {file_path_json}")
                elif fmt.lower() == "markdown":
                    file_path_md = f"{base_file_path}_form_invoice_data.md"
                    markdown_content = self._convert_form_invoice_to_markdown()
                    writer.write_string(file_path_md, markdown_content)
                    logger.info(f"Form/invoice data successfully dumped to {file_path_md}")
                else:
                    logger.warning(f"Unsupported output format for form/invoice data: {fmt}")
        
        # Dump signature data if available
        if self._signature_data and any(self._signature_data):
            for fmt in output_formats:
                if fmt.lower() == "json":
                    file_path_json = f"{base_file_path}_signatures.json"
                    writer.write_string(
                        file_path_json, json.dumps(self._signature_data, ensure_ascii=False, indent=4)
                    )
                    logger.info(f"Signature data successfully dumped to {file_path_json}")
                elif fmt.lower() == "markdown":
                    file_path_md = f"{base_file_path}_signatures.md"
                    markdown_content = self._convert_signature_to_markdown()
                    writer.write_string(file_path_md, markdown_content)
                    logger.info(f"Signature data successfully dumped to {file_path_md}")
                else:
                    logger.warning(f"Unsupported output format for signature data: {fmt}")

    def apply (self ,proc :Callable ,*args ,**kwargs ):
        """Apply callable method which.

        Args:
            proc (Callable): invoke proc as follows:
                proc(inference_result, *args, **kwargs)

        Returns:
            Any: return the result generated by proc
        """
        return proc (copy .deepcopy (self ._infer_res ),*args ,**kwargs )

    def pipe_txt_mode (
    self ,
    imageWriter :DataWriter ,
    start_page_id =0 ,
    end_page_id =None ,
    debug_mode =False ,
    lang =None ,
    )->PipeResult :
        """Post-proc the model inference result, Extract the text using the
        third library, such as `pymupdf`

        Args:
            imageWriter (DataWriter): the image writer handle
            start_page_id (int, optional): Defaults to 0. Let user select some pages He/She want to process
            end_page_id (int, optional):  Defaults to the last page index of dataset. Let user select some pages He/She want to process
            debug_mode (bool, optional): Defaults to False. will dump more log if enabled
            lang (str, optional): Defaults to None.

        Returns:
            PipeResult: the result
        """

        def proc (*args ,**kwargs )->PipeResult :
            res =pdf_parse_union (*args ,**kwargs )
            res ['_parse_type']=PARSE_TYPE_TXT 
            res ['_version_name']=__version__ 
            if 'lang'in kwargs and kwargs ['lang']is not None :
                res ['lang']=kwargs ['lang']
            return PipeResult(res, self._dataset, signature_data=self._signature_data)

        res =self .apply (
        proc ,
        self ._dataset ,
        imageWriter ,
        SupportedPdfParseMethod .TXT ,
        start_page_id =start_page_id ,
        end_page_id =end_page_id ,
        debug_mode =debug_mode ,
        lang =lang ,
        )
        return res 

    def pipe_ocr_mode (
    self ,
    imageWriter :DataWriter ,
    start_page_id =0 ,
    end_page_id =None ,
    debug_mode =False ,
    lang =None ,
    )->PipeResult :
        """Post-proc the model inference result, Extract the text using `OCR`
        technical.

        Args:
            imageWriter (DataWriter): the image writer handle
            start_page_id (int, optional): Defaults to 0. Let user select some pages He/She want to process
            end_page_id (int, optional):  Defaults to the last page index of dataset. Let user select some pages He/She want to process
            debug_mode (bool, optional): Defaults to False. will dump more log if enabled
            lang (str, optional): Defaults to None.

        Returns:
            PipeResult: the result
        """

        def proc (*args ,**kwargs )->PipeResult :
            res =pdf_parse_union (*args ,**kwargs )
            res ['_parse_type']=PARSE_TYPE_OCR 
            res ['_version_name']=__version__ 
            if 'lang'in kwargs and kwargs ['lang']is not None :
                res ['lang']=kwargs ['lang']
            return PipeResult(res, self._dataset, signature_data=self._signature_data)

        res =self .apply (
        proc ,
        self ._dataset ,
        imageWriter ,
        SupportedPdfParseMethod .OCR ,
        start_page_id =start_page_id ,
        end_page_id =end_page_id ,
        debug_mode =debug_mode ,
        lang =lang ,
        )
        return res 

