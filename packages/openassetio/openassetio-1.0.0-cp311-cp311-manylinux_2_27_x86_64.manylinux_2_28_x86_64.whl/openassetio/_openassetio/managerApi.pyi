from __future__ import annotations
import openassetio._openassetio
import openassetio._openassetio.access
import openassetio._openassetio.errors
import openassetio._openassetio.hostApi
import openassetio._openassetio.log
import openassetio._openassetio.trait
import typing
__all__ = ['EntityReferencePagerInterface', 'Host', 'HostSession', 'ManagerInterface', 'ManagerStateBase']
class EntityReferencePagerInterface:
    def __init__(self) -> None:
        ...
    def close(self, hostSession: HostSession) -> None:
        ...
    def get(self, hostSession: HostSession) -> list[openassetio._openassetio.EntityReference]:
        ...
    def hasNext(self, hostSession: HostSession) -> bool:
        ...
    def next(self, hostSession: HostSession) -> None:
        ...
class Host:
    def __init__(self, hostInterface: openassetio._openassetio.hostApi.HostInterface) -> None:
        ...
    def displayName(self) -> str:
        ...
    def identifier(self) -> str:
        ...
    def info(self) -> dict[str, bool | int | float | str]:
        ...
class HostSession:
    def __init__(self, host: Host, logger: openassetio._openassetio.log.LoggerInterface) -> None:
        ...
    def host(self) -> Host:
        ...
    def logger(self) -> openassetio._openassetio.log.LoggerInterface:
        ...
class ManagerInterface:
    class Capability:
        """
        Members:
        
          kEntityReferenceIdentification
        
          kManagementPolicyQueries
        
          kStatefulContexts
        
          kCustomTerminology
        
          kResolution
        
          kPublishing
        
          kRelationshipQueries
        
          kExistenceQueries
        
          kDefaultEntityReferences
        
          kEntityTraitIntrospection
        """
        __members__: typing.ClassVar[dict[str, ManagerInterface.Capability]]  # value = {'kEntityReferenceIdentification': <Capability.kEntityReferenceIdentification: 0>, 'kManagementPolicyQueries': <Capability.kManagementPolicyQueries: 1>, 'kStatefulContexts': <Capability.kStatefulContexts: 2>, 'kCustomTerminology': <Capability.kCustomTerminology: 3>, 'kResolution': <Capability.kResolution: 4>, 'kPublishing': <Capability.kPublishing: 5>, 'kRelationshipQueries': <Capability.kRelationshipQueries: 6>, 'kExistenceQueries': <Capability.kExistenceQueries: 7>, 'kDefaultEntityReferences': <Capability.kDefaultEntityReferences: 8>, 'kEntityTraitIntrospection': <Capability.kEntityTraitIntrospection: 9>}
        kCustomTerminology: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kCustomTerminology: 3>
        kDefaultEntityReferences: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kDefaultEntityReferences: 8>
        kEntityReferenceIdentification: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kEntityReferenceIdentification: 0>
        kEntityTraitIntrospection: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kEntityTraitIntrospection: 9>
        kExistenceQueries: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kExistenceQueries: 7>
        kManagementPolicyQueries: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kManagementPolicyQueries: 1>
        kPublishing: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kPublishing: 5>
        kRelationshipQueries: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kRelationshipQueries: 6>
        kResolution: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kResolution: 4>
        kStatefulContexts: typing.ClassVar[ManagerInterface.Capability]  # value = <Capability.kStatefulContexts: 2>
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __repr__(self) -> str:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    kCapabilityNames: typing.ClassVar[list] = ['entityReferenceIdentification', 'managementPolicyQueries', 'statefulContexts', 'customTerminology', 'resolution', 'publishing', 'relationshipQueries', 'existenceQueries', 'defaultEntityReferences', 'entityTraitIntrospection']
    def __init__(self) -> None:
        ...
    def _createEntityReference(self, entityReferenceString: str) -> openassetio._openassetio.EntityReference:
        ...
    def createChildState(self, parentState: ManagerStateBase, hostSession: HostSession) -> ManagerStateBase:
        ...
    def createState(self, hostSession: HostSession) -> ManagerStateBase:
        ...
    def defaultEntityReference(self, traitSets: list[set[str]], defaultEntityAccess: openassetio._openassetio.access.DefaultEntityAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, openassetio._openassetio.EntityReference | None], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def displayName(self) -> str:
        ...
    def entityExists(self, entityReferences: list[openassetio._openassetio.EntityReference], context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, bool], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def entityTraits(self, entityReferences: list[openassetio._openassetio.EntityReference], entityTraitsAccess: openassetio._openassetio.access.EntityTraitsAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, set[str]], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def flushCaches(self, hostSession: HostSession) -> None:
        ...
    def getWithRelationship(self, entityReferences: list[openassetio._openassetio.EntityReference], relationshipTraitsData: openassetio._openassetio.trait.TraitsData, resultTraitSet: set[str], pageSize: int, relationsAccess: openassetio._openassetio.access.RelationsAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, EntityReferencePagerInterface], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def getWithRelationships(self, entityReference: openassetio._openassetio.EntityReference, relationshipTraitsDatas: list[openassetio._openassetio.trait.TraitsData], resultTraitSet: set[str], pageSize: int, relationsAccess: openassetio._openassetio.access.RelationsAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, EntityReferencePagerInterface], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def hasCapability(self, capability: ManagerInterface.Capability) -> bool:
        ...
    def identifier(self) -> str:
        ...
    def info(self) -> dict[str, bool | int | float | str]:
        ...
    def initialize(self, managerSettings: dict[str, bool | int | float | str], hostSession: HostSession) -> None:
        ...
    def isEntityReferenceString(self, someString: str, hostSession: HostSession) -> bool:
        ...
    def managementPolicy(self, traitSets: list[set[str]], policyAccess: openassetio._openassetio.access.PolicyAccess, context: openassetio._openassetio.Context, hostSession: HostSession) -> list[openassetio._openassetio.trait.TraitsData]:
        ...
    def persistenceTokenForState(self, state: ManagerStateBase, hostSession: HostSession) -> str:
        ...
    def preflight(self, entityReferences: list[openassetio._openassetio.EntityReference], traitsHints: list[openassetio._openassetio.trait.TraitsData], publishingAccess: openassetio._openassetio.access.PublishingAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, openassetio._openassetio.EntityReference], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def register(self, entityReferences: list[openassetio._openassetio.EntityReference], entityTraitsDatas: list[openassetio._openassetio.trait.TraitsData], publishingAccess: openassetio._openassetio.access.PublishingAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, openassetio._openassetio.EntityReference], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def resolve(self, entityReferences: list[openassetio._openassetio.EntityReference], traitSet: set[str], resolveAcess: openassetio._openassetio.access.ResolveAccess, context: openassetio._openassetio.Context, hostSession: HostSession, successCallback: typing.Callable[[int, openassetio._openassetio.trait.TraitsData], None], errorCallback: typing.Callable[[int, openassetio._openassetio.errors.BatchElementError], None]) -> None:
        ...
    def settings(self, hostSession: HostSession) -> dict[str, bool | int | float | str]:
        ...
    def stateFromPersistenceToken(self, token: str, hostSession: HostSession) -> ManagerStateBase:
        ...
    def updateTerminology(self, terms: dict[str, str], hostSession: HostSession) -> dict[str, str]:
        ...
class ManagerStateBase:
    def __init__(self) -> None:
        ...
