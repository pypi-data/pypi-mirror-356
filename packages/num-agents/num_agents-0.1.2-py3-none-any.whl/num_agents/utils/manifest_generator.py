"""
Manifest Generator for N端m Agents SDK.

This module provides functionality to generate a comprehensive manifest of all files
in a N端m Agents project, including descriptions and categorizations.
"""

import os
import json
import yaml
from pathlib import Path
from typing import Dict, List, Optional, Any


class ManifestGenerator:
    """
    Generates a manifest of all files in a N端m Agents project.
    
    The manifest includes file paths, descriptions, and categorizations,
    providing a comprehensive overview of the project structure.
    """
    
    def __init__(self, project_path: str):
        """
        Initialize the ManifestGenerator.
        
        Args:
            project_path: The path to the N端m Agents project.
        """
        self.project_path = Path(project_path)
        
    def generate_manifest(self, output_format: str = "markdown") -> str:
        """
        Generate a manifest of all files in the project.
        
        Args:
            output_format: The output format for the manifest ("markdown" or "json").
            
        Returns:
            The generated manifest as a string in the specified format.
            
        Raises:
            ValueError: If the output format is not supported.
        """
        files_info = self._collect_files_info()
        
        if output_format.lower() == "markdown":
            return self._generate_markdown(files_info)
        elif output_format.lower() == "json":
            return json.dumps(files_info, indent=2)
        else:
            raise ValueError(f"Unsupported output format: {output_format}")
    
    def _collect_files_info(self) -> Dict[str, List[Dict[str, Any]]]:
        """
        Collect information about all files in the project.
        
        Returns:
            A dictionary with categories as keys and lists of file information as values.
        """
        result: Dict[str, List[Dict[str, Any]]] = {}
        
        for root, dirs, files in os.walk(self.project_path):
            # Skip hidden directories and __pycache__
            dirs[:] = [d for d in dirs if not d.startswith('.') and d != '__pycache__']
            
            rel_path = os.path.relpath(root, self.project_path)
            if rel_path == ".":
                category = "root"
            else:
                category = rel_path.split(os.sep)[0]
                
            if category not in result:
                result[category] = []
                
            for file in files:
                if file.startswith(".") or file.endswith(".pyc"):
                    continue
                    
                file_path = os.path.join(rel_path, file)
                if rel_path == ".":
                    file_path = file
                    
                description = self._get_file_description(file_path)
                file_type = self._get_file_type(file_path)
                
                result[category].append({
                    "path": file_path,
                    "description": description,
                    "type": file_type
                })
        
        return result
    
    def _get_file_description(self, file_path: str) -> str:
        """
        Get a description for a file based on its content and type.
        
        Args:
            file_path: The relative path to the file.
            
        Returns:
            A description of the file.
        """
        full_path = self.project_path / file_path
        
        if not full_path.exists():
            return "File not found"
            
        file_ext = full_path.suffix.lower()
        
        # Special files with known purposes
        if file_path == "agent.yaml" or file_path.endswith("/agent.yaml"):
            return "Agent specification file defining the agent's configuration, universes, and modules"
        elif file_path == "flow.py" or file_path.endswith("/flow.py"):
            return "Flow definition for the agent, connecting nodes in a processing pipeline"
        elif file_path == "shared_store.py" or file_path.endswith("/shared_store.py"):
            return "Shared storage for the agent, providing data persistence and communication between nodes"
        elif file_path == "main.py" or file_path.endswith("/main.py"):
            return "Entry point for the agent, initializing and running the flow"
        elif file_path == "logical_graph.mmd" or file_path.endswith("/logical_graph.mmd"):
            return "Mermaid diagram of the agent's logical flow, visualizing node connections"
        elif file_path == "audit_report.json" or file_path.endswith("/audit_report.json"):
            return "Audit report generated by the MetaOrchestrator, containing validation results and suggestions"
        elif "nodes/" in file_path and file_ext == ".py":
            # Extract node name from file path
            node_name = os.path.basename(file_path).replace(".py", "")
            return f"Node implementation: {node_name}"
        
        # Try to extract docstring for Python files
        if file_ext == ".py":
            try:
                with open(full_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                # Simple docstring extraction
                if '"""' in content:
                    docstring_start = content.find('"""') + 3
                    docstring_end = content.find('"""', docstring_start)
                    if docstring_end > docstring_start:
                        docstring = content[docstring_start:docstring_end].strip()
                        # Take first line or first sentence
                        first_line = docstring.split('\n')[0].strip()
                        if first_line:
                            return first_line
                            
                # Check for class or function definitions
                if "class " in content:
                    return "Python module defining one or more classes"
                elif "def " in content:
                    return "Python module defining one or more functions"
                
                return "Python module"
            except Exception:
                return "Python module"
        
        # Generic file types
        if file_ext in [".md", ".markdown"]:
            # Try to extract title from markdown
            try:
                with open(full_path, 'r', encoding='utf-8') as f:
                    for line in f:
                        line = line.strip()
                        if line.startswith('# '):
                            return f"Documentation: {line[2:]}"
            except Exception:
                pass
            return "Documentation file"
        elif file_ext in [".yaml", ".yml"]:
            return "Configuration file"
        elif file_ext == ".json":
            return "JSON data file"
        elif file_ext == ".txt":
            return "Text file"
        elif file_ext in [".png", ".jpg", ".jpeg", ".gif", ".svg"]:
            return "Image file"
        else:
            return f"File with {file_ext} extension"
    
    def _get_file_type(self, file_path: str) -> str:
        """
        Get the type of a file based on its extension and path.
        
        Args:
            file_path: The relative path to the file.
            
        Returns:
            The type of the file.
        """
        full_path = self.project_path / file_path
        file_ext = full_path.suffix.lower()
        
        if "nodes/" in file_path and file_ext == ".py":
            return "node"
        elif file_path in ["agent.yaml", "flow.py", "shared_store.py", "main.py"]:
            return "core"
        elif file_ext == ".py":
            return "python"
        elif file_ext in [".md", ".markdown"]:
            return "documentation"
        elif file_ext in [".yaml", ".yml"]:
            return "configuration"
        elif file_ext == ".json":
            return "data"
        elif file_ext in [".png", ".jpg", ".jpeg", ".gif", ".svg"]:
            return "image"
        else:
            return "other"
    
    def _generate_markdown(self, files_info: Dict[str, List[Dict[str, Any]]]) -> str:
        """
        Generate a markdown representation of the files manifest.
        
        Args:
            files_info: A dictionary with categories as keys and lists of file information as values.
            
        Returns:
            A markdown string representing the manifest.
        """
        result = ["# Project Files Manifest\n"]
        result.append("This document provides an overview of all files in the project, their descriptions, and types.\n")
        
        # Add table of contents
        result.append("## Table of Contents\n")
        for category in sorted(files_info.keys()):
            result.append(f"- [{category.capitalize()}](#{category.lower()})")
        result.append("")
        
        # Add file information by category
        for category, files in sorted(files_info.items()):
            result.append(f"## {category.capitalize()}\n")
            result.append("| File | Type | Description |")
            result.append("| ---- | ---- | ----------- |")
            
            for file_info in sorted(files, key=lambda x: x["path"]):
                path = file_info["path"]
                desc = file_info["description"]
                file_type = file_info["type"]
                result.append(f"| `{path}` | {file_type} | {desc} |")
            
            result.append("")
        
        return "\n".join(result)
