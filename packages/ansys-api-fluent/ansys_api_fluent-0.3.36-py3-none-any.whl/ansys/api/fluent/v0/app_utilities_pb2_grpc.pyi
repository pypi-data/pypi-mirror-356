"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import abc
import ansys.api.fluent.v0.app_utilities_pb2
import grpc

class AppUtilitiesStub:
    def __init__(self, channel: grpc.Channel) -> None: ...
    GetProductVersion: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.GetProductVersionRequest,
        ansys.api.fluent.v0.app_utilities_pb2.GetProductVersionResponse] = ...
    """Get product version"""

    GetBuildInfo: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.GetBuildInfoRequest,
        ansys.api.fluent.v0.app_utilities_pb2.GetBuildInfoResponse] = ...
    """Get build information"""

    GetControllerProcessInfo: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.GetControllerProcessInfoRequest,
        ansys.api.fluent.v0.app_utilities_pb2.GetControllerProcessInfoResponse] = ...
    """*
    Get Controller process information if the solver app is running in client-server mode,
    Controller process commanding the Solver process.
    """

    GetSolverProcessInfo: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.GetSolverProcessInfoRequest,
        ansys.api.fluent.v0.app_utilities_pb2.GetSolverProcessInfoResponse] = ...
    """Get Solver process information"""

    GetAppMode: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.GetAppModeRequest,
        ansys.api.fluent.v0.app_utilities_pb2.GetAppModeResponse] = ...
    """Get App mode"""

    StartPythonJournal: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.StartPythonJournalRequest,
        ansys.api.fluent.v0.app_utilities_pb2.StartPythonJournalResponse] = ...
    """Start Python journal"""

    StopPythonJournal: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.StopPythonJournalRequest,
        ansys.api.fluent.v0.app_utilities_pb2.StopPythonJournalResponse] = ...
    """Stop Python journal"""

    IsBetaEnabled: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.IsBetaEnabledRequest,
        ansys.api.fluent.v0.app_utilities_pb2.IsBetaEnabledResponse] = ...
    """Is beta feature enabled?"""

    EnableBeta: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.EnableBetaRequest,
        ansys.api.fluent.v0.app_utilities_pb2.EnableBetaResponse] = ...
    """Enable beta features"""

    IsWildcard: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.IsWildcardRequest,
        ansys.api.fluent.v0.app_utilities_pb2.IsWildcardResponse] = ...
    """Is wildcard as per the solver app's syntax?"""

    IsSolutionDataAvailable: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.IsSolutionDataAvailableRequest,
        ansys.api.fluent.v0.app_utilities_pb2.IsSolutionDataAvailableResponse] = ...
    """Is solution data available?"""

    RegisterPauseOnSolutionEvents: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.RegisterPauseOnSolutionEventsRequest,
        ansys.api.fluent.v0.app_utilities_pb2.RegisterPauseOnSolutionEventsResponse] = ...
    """*
    Following 3 methods are useful to execute synchronous callbacks in gRPC client on solution events
    such as iteration or time-step advancement. An implementation of such mechanism will look like:
    1. After each solution event, the solver will send a paused event to clients and pause itself.
    2. The registered client will receive the paused event and execute the callback and then resume the solver.

    Register to pause on solution events.
    """

    ResumeOnSolutionEvent: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.ResumeOnSolutionEventRequest,
        ansys.api.fluent.v0.app_utilities_pb2.ResumeOnSolutionEventResponse] = ...
    """Resume from pause on a solution event"""

    UnregisterPauseOnSolutionEvents: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.UnregisterPauseOnSolutionEventsRequest,
        ansys.api.fluent.v0.app_utilities_pb2.UnregisterPauseOnSolutionEventsResponse] = ...
    """Unregister to pause on solution events"""

    Exit: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.ExitRequest,
        ansys.api.fluent.v0.app_utilities_pb2.ExitResponse] = ...
    """Exit the solver app"""

    SetWorkingDirectory: grpc.UnaryUnaryMultiCallable[
        ansys.api.fluent.v0.app_utilities_pb2.SetWorkingDirectoryRequest,
        ansys.api.fluent.v0.app_utilities_pb2.SetWorkingDirectoryResponse] = ...
    """Change cortex working directory"""


class AppUtilitiesServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def GetProductVersion(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.GetProductVersionRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.GetProductVersionResponse:
        """Get product version"""
        pass

    @abc.abstractmethod
    def GetBuildInfo(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.GetBuildInfoRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.GetBuildInfoResponse:
        """Get build information"""
        pass

    @abc.abstractmethod
    def GetControllerProcessInfo(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.GetControllerProcessInfoRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.GetControllerProcessInfoResponse:
        """*
        Get Controller process information if the solver app is running in client-server mode,
        Controller process commanding the Solver process.
        """
        pass

    @abc.abstractmethod
    def GetSolverProcessInfo(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.GetSolverProcessInfoRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.GetSolverProcessInfoResponse:
        """Get Solver process information"""
        pass

    @abc.abstractmethod
    def GetAppMode(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.GetAppModeRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.GetAppModeResponse:
        """Get App mode"""
        pass

    @abc.abstractmethod
    def StartPythonJournal(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.StartPythonJournalRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.StartPythonJournalResponse:
        """Start Python journal"""
        pass

    @abc.abstractmethod
    def StopPythonJournal(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.StopPythonJournalRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.StopPythonJournalResponse:
        """Stop Python journal"""
        pass

    @abc.abstractmethod
    def IsBetaEnabled(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.IsBetaEnabledRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.IsBetaEnabledResponse:
        """Is beta feature enabled?"""
        pass

    @abc.abstractmethod
    def EnableBeta(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.EnableBetaRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.EnableBetaResponse:
        """Enable beta features"""
        pass

    @abc.abstractmethod
    def IsWildcard(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.IsWildcardRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.IsWildcardResponse:
        """Is wildcard as per the solver app's syntax?"""
        pass

    @abc.abstractmethod
    def IsSolutionDataAvailable(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.IsSolutionDataAvailableRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.IsSolutionDataAvailableResponse:
        """Is solution data available?"""
        pass

    @abc.abstractmethod
    def RegisterPauseOnSolutionEvents(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.RegisterPauseOnSolutionEventsRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.RegisterPauseOnSolutionEventsResponse:
        """*
        Following 3 methods are useful to execute synchronous callbacks in gRPC client on solution events
        such as iteration or time-step advancement. An implementation of such mechanism will look like:
        1. After each solution event, the solver will send a paused event to clients and pause itself.
        2. The registered client will receive the paused event and execute the callback and then resume the solver.

        Register to pause on solution events.
        """
        pass

    @abc.abstractmethod
    def ResumeOnSolutionEvent(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.ResumeOnSolutionEventRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.ResumeOnSolutionEventResponse:
        """Resume from pause on a solution event"""
        pass

    @abc.abstractmethod
    def UnregisterPauseOnSolutionEvents(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.UnregisterPauseOnSolutionEventsRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.UnregisterPauseOnSolutionEventsResponse:
        """Unregister to pause on solution events"""
        pass

    @abc.abstractmethod
    def Exit(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.ExitRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.ExitResponse:
        """Exit the solver app"""
        pass

    @abc.abstractmethod
    def SetWorkingDirectory(self,
        request: ansys.api.fluent.v0.app_utilities_pb2.SetWorkingDirectoryRequest,
        context: grpc.ServicerContext,
    ) -> ansys.api.fluent.v0.app_utilities_pb2.SetWorkingDirectoryResponse:
        """Change cortex working directory"""
        pass


def add_AppUtilitiesServicer_to_server(servicer: AppUtilitiesServicer, server: grpc.Server) -> None: ...
