Metadata-Version: 2.4
Name: gchatbot
Version: 0.2.6
Summary: Biblioteca Python moderna para criar bots para Google Chat com suporte h√≠brido sync/async e respostas progressivas
Home-page: https://github.com/guilhermecf10/gchatbot
Author: Jo√£o Matheus & Guilherme Fialho
Author-email: guilhermec.fialho@gmail.com
License: MIT
Project-URL: Bug Reports, https://github.com/guilhermecf10/gchatbot/issues
Project-URL: Source, https://github.com/guilhermecf10/gchatbot
Project-URL: Documentation, https://github.com/guilhermecf10/gchatbot#readme
Keywords: google-chat,chatbot,bot,google-workspace,fastapi,async,progressive-responses,hybrid-sync-async
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Topic :: Communications :: Chat
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Framework :: FastAPI
Classifier: Framework :: Flask
Requires-Python: >=3.7
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: google-auth>=2.0.0
Requires-Dist: google-api-python-client>=2.0.0
Requires-Dist: google-apps-chat>=0.1.0
Requires-Dist: protobuf>=3.19.0
Provides-Extra: fastapi
Requires-Dist: fastapi>=0.70.0; extra == "fastapi"
Requires-Dist: uvicorn>=0.15.0; extra == "fastapi"
Provides-Extra: flask
Requires-Dist: flask>=2.0.0; extra == "flask"
Provides-Extra: async
Requires-Dist: aiohttp>=3.8.0; extra == "async"
Requires-Dist: asyncio-throttle>=1.0.0; extra == "async"
Provides-Extra: dev
Requires-Dist: pytest>=6.0.0; extra == "dev"
Requires-Dist: pytest-asyncio>=0.18.0; extra == "dev"
Requires-Dist: black>=22.0.0; extra == "dev"
Requires-Dist: isort>=5.0.0; extra == "dev"
Requires-Dist: mypy>=0.900; extra == "dev"
Provides-Extra: all
Requires-Dist: fastapi>=0.70.0; extra == "all"
Requires-Dist: uvicorn>=0.15.0; extra == "all"
Requires-Dist: flask>=2.0.0; extra == "all"
Requires-Dist: aiohttp>=3.8.0; extra == "all"
Requires-Dist: asyncio-throttle>=1.0.0; extra == "all"
Dynamic: author
Dynamic: author-email
Dynamic: classifier
Dynamic: description
Dynamic: description-content-type
Dynamic: home-page
Dynamic: keywords
Dynamic: license
Dynamic: license-file
Dynamic: project-url
Dynamic: provides-extra
Dynamic: requires-dist
Dynamic: requires-python
Dynamic: summary

# Google Chat Bot Library (`gchatbot`)

Uma biblioteca Python moderna para simplificar a cria√ß√£o de bots para o Google Chat, utilizando **FastAPI** para alta performance e suporte nativo a opera√ß√µes ass√≠ncronas.

## Vis√£o Geral

Esta biblioteca fornece uma classe base robusta (`GChatBot`) que gerencia as complexidades da API do Google Chat, permitindo que voc√™ se concentre na l√≥gica do seu bot.

-   **Estrutura Moderna com FastAPI:** Aproveita a velocidade e o suporte `async` nativo do FastAPI.
-   **Processamento H√≠brido Robusto:** Tenta responder em segundos para tarefas curtas. Para tarefas longas, ele muda para um modo ass√≠ncrono **seguro**, que n√£o duplica o trabalho, garantindo consist√™ncia e uma √≥tima experi√™ncia do usu√°rio.
-   **Suporte H√≠brido Sync/Async:** Detecta automaticamente se seus m√©todos s√£o s√≠ncronos ou ass√≠ncronos e processa adequadamente.
-   **Respostas Progressivas:** Fornece feedback imediato ao usu√°rio e depois atualiza com informa√ß√µes detalhadas.
-   **Arquitetura Modular:** Componentes como `EventParser`, `AsyncProcessor` e `ResponseFactory` s√£o desacoplados, permitindo customiza√ß√µes avan√ßadas.
-   **Extra√ß√£o de Eventos Simplificada:** Converte automaticamente os diversos formatos de payload do Google Chat em uma estrutura de dados (`ExtractedEventData`) limpa e previs√≠vel.
-   **Tipagem Completa:** Suporte completo a type hints com tipos exportados para melhor experi√™ncia de desenvolvimento.

## Como Funciona: O Modelo H√≠brido Robusto

A biblioteca implementa um padr√£o de processamento h√≠brido que √© eficiente e, mais importante, seguro contra condi√ß√µes de corrida e duplica√ß√£o de trabalho.

1.  **Requisi√ß√£o Recebida:** O `GChatBot` recebe um evento do Google Chat.
2.  **Detec√ß√£o Autom√°tica:** A biblioteca detecta se seus m√©todos s√£o s√≠ncronos ou ass√≠ncronos usando `inspect.iscoroutinefunction()`.
3.  **Tentativa S√≠ncrona:** Ele inicia o processamento da sua l√≥gica (`_processSlashCommand` ou `_processMessage`) e aguarda por um curto per√≠odo de tempo (`syncTimeout`).
4.  **Caminho Feliz (Resposta R√°pida):** Se a sua l√≥gica terminar antes do timeout, a resposta √© enviada diretamente na requisi√ß√£o original.
5.  **Caminho Ass√≠ncrono (Resposta Lenta):** Se o timeout for atingido:
    a. O bot responde **imediatamente** `200 OK` ao Google Chat, liberando a conex√£o.
    b. Uma tarefa "monitora" √© iniciada em background. Essa tarefa **n√£o reexecuta** sua l√≥gica.
    c. A tarefa monitora **aguarda a conclus√£o da tarefa original**, que continua rodando.
    d. Assim que a tarefa original termina, a monitora pega o resultado e o envia como uma nova mensagem no chat.

Este modelo garante que sua l√≥gica de neg√≥cio **nunca seja executada mais de uma vez por evento**, prevenindo bugs de consist√™ncia de dados e consumo excessivo de recursos.

**Diagrama de Fluxo (GChatBot com FastAPI):**

```mermaid
graph TD
    A[Webhook Recebido] --> B("GChatBot.handleRequest");
    B --> C{Parsing do Evento};
    C --> D[Detec√ß√£o Sync/Async];
    D --> E[Cria√ß√£o da Tarefa de Processamento];
    E --> F{Aguardar Tarefa com Timeout};

    F -- Conclu√≠do a Tempo --> G{Resposta Progressiva?};
    G -- N√£o --> H[Formatar Resposta S√≠ncrona];
    G -- Sim --> I[Enviar Resposta R√°pida];
    H --> J[Resposta HTTP 200 OK com JSON];
    I --> J;

    F -- Timeout Atingido --> K[Resposta HTTP 200 OK Vazio];
    K --> L[Iniciar Tarefa Monitora Async];

    subgraph "Processamento em Background"
        E -- Tarefa Original Continua --> Z[L√≥gica do Bot];
        L -- Monitora --> Z;
        Z -- Resultado Pronto --> M{Resposta Progressiva?};
        M -- N√£o --> N[API: Postar Mensagem no Chat];
        M -- Sim --> O[Processar Resposta Detalhada];
        O --> P[API: Atualizar Mensagem no Chat];
    end
```

## Instala√ß√£o

A biblioteca √© projetada para funcionar com FastAPI, mas tamb√©m suporta Flask para compatibilidade.

```bash
# Instale a biblioteca com as depend√™ncias do FastAPI (Recomendado)
pip install "gchatbot[fastapi]"

# Ou instale apenas as depend√™ncias b√°sicas
pip install gchatbot

# Depend√™ncias opcionais dispon√≠veis:
# pip install "gchatbot[flask]"    # Para suporte Flask
# pip install "gchatbot[async]"    # Para recursos ass√≠ncronos adicionais
```

## Uso Recomendado: Exemplo com FastAPI

```python
# example.py
import os
import time
import asyncio
from typing import Any, Dict
from fastapi import FastAPI, Request
from gchatbot import GChatBot, ExtractedEventData, EventPayload, ResponseType

# Certifique-se de ter um arquivo 'service.json' ou defina a vari√°vel de ambiente.
SERVICE_ACCOUNT_FILE: str = os.environ.get("SERVICE_ACCOUNT_FILE", "service.json")

class BotExemplo(GChatBot):
    """
    Bot de exemplo que demonstra m√©todos s√≠ncronos e ass√≠ncronos.
    
    Este exemplo mostra como voc√™ pode misturar m√©todos sync e async
    na mesma classe, e a biblioteca automaticamente detecta e trata
    cada um de forma apropriada.
    
    Tamb√©m demonstra respostas progressivas (progressive fallback).
    """
    def __init__(self) -> None:
        super().__init__(
            botName="Bot Exemplo H√≠brido",
            serviceAccountFile=SERVICE_ACCOUNT_FILE,
            syncTimeout=4.0  # Responde em at√© 4s ou muda para modo ass√≠ncrono.
        )

    async def _processSlashCommand(self, command: str, arguments: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
        """
        M√âTODO ASS√çNCRONO - Processa comandos de barra usando async/await.
        
        Este m√©todo √© async, ent√£o pode usar await para opera√ß√µes n√£o-bloqueantes.
        """
        user: str = extractedData.get('userDisplayName', 'Usu√°rio')
        userChatId: str = extractedData.get('userGoogleChatId', 'Unknown ID')
        
        if command == "lento":
            # Opera√ß√£o ass√≠ncrona que demora mais que o syncTimeout
            await asyncio.sleep(6)
            return f"‚è±Ô∏è Comando /lento ASYNC executado para {user}! Demorou 6 segundos de forma n√£o-bloqueante."
        
        elif command == "api":
            # Simula chamada para API externa ass√≠ncrona
            await asyncio.sleep(3)
            return f"üåê Chamada ASYNC para API externa conclu√≠da para {user}!"
        
        elif command == "concorrente":
            # Demonstra opera√ß√µes concorrentes
            tasks: list[asyncio.Task[str]] = [
                asyncio.create_task(self._operacaoAsync(f"Task {i}", 1)) 
                for i in range(3)
            ]
            resultados: list[str] = await asyncio.gather(*tasks)
            return f"üöÄ Opera√ß√µes concorrentes para {user}:\n" + "\n".join(resultados)
        
        elif command == "progressivo":
            # üÜï Demonstra resposta progressiva ASS√çNCRONA
            quickResponse = f"‚ö° Iniciando an√°lise para {user}..."
            
            async def detailedResponse() -> str:
                await asyncio.sleep(5)  # Simula processamento longo
                dados = await self._analisarDadosAsync()
                return f"üìä An√°lise completa para {user}!\n\nResultados:\n{dados}"
            
            return (quickResponse, detailedResponse)
        
        elif command == "relatorio":
            # üÜï Demonstra resposta progressiva com processamento complexo
            quickResponse = f"üìã Gerando relat√≥rio para {user}..."
            
            async def detailedResponse() -> str:
                # Simula v√°rias etapas de processamento
                await asyncio.sleep(2)  # Coleta de dados
                await asyncio.sleep(3)  # Processamento
                await asyncio.sleep(2)  # Formata√ß√£o
                return f"‚úÖ Relat√≥rio completo gerado para {user}!\n\nüìà Dados processados\nüìä Gr√°ficos gerados\nüìÑ Documento finalizado"
            
            return (quickResponse, detailedResponse)
        
        elif command == "info":
            # üÜï Demonstra uso do userGoogleChatId
            userEmail: str = extractedData.get('userEmail', 'Unknown Email')
            return f"""‚ÑπÔ∏è **Informa√ß√µes do Usu√°rio:**
‚Ä¢ Nome: {user}
‚Ä¢ Email: {userEmail}
‚Ä¢ Google Chat ID: {userChatId}

üí° O Google Chat ID √© √∫til para men√ß√µes program√°ticas!"""
        
        else:
            await asyncio.sleep(0.5)
            return f"‚úÖ Comando ASYNC /{command} executado para {user}."

    def _processMessage(self, text: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
        """
        M√âTODO S√çNCRONO - Processa mensagens usando m√©todos tradicionais.
        
        Este m√©todo √© s√≠ncrono (sem async), ent√£o usa time.sleep() e 
        opera√ß√µes bloqueantes normais.
        """
        user: str = extractedData.get('userDisplayName', 'Usu√°rio')
        
        if "demorado" in text.lower():
            # Opera√ß√£o s√≠ncrona que bloqueia a thread
            time.sleep(7)
            return f"üïê Voc√™ pediu algo demorado, {user}. Processamento S√çNCRONO conclu√≠do em 7 segundos!"
        
        elif "progressivo" in text.lower():
            # üÜï Demonstra resposta progressiva S√çNCRONA
            quickResponse = f"‚ö° Recebido! Processando sua solicita√ß√£o, {user}..."
            
            def detailedResponse() -> str:
                time.sleep(4)  # Simula processamento
                resultado = self._processarDadosSync()
                return f"üìã An√°lise completa conclu√≠da para {user}!\n\nResultados: {resultado}"
            
            return (quickResponse, detailedResponse)
        
        elif "analise" in text.lower():
            # üÜï Outro exemplo de resposta progressiva s√≠ncrona
            quickResponse = f"üîç Iniciando an√°lise para {user}..."
            
            def detailedResponse() -> str:
                time.sleep(3)  # Processamento
                return f"üìä An√°lise detalhada conclu√≠da para {user}!\n\n‚úÖ Dados validados\nüìà Tend√™ncias identificadas\nüéØ Recomenda√ß√µes geradas"
            
            return (quickResponse, detailedResponse)
        
        elif "calcular" in text.lower():
            # Processamento s√≠ncrono intensivo
            time.sleep(2)
            resultado: int = sum(range(1000000))
            return f"üßÆ C√°lculo S√çNCRONO conclu√≠do para {user}: {resultado}"
        
        else:
            return f"üí¨ Mensagem processada de forma S√çNCRONA, {user}: '{text}'"

    # --- M√©todos auxiliares ---
    
    async def _operacaoAsync(self, nome: str, duracao: int) -> str:
        """M√©todo auxiliar ass√≠ncrono."""
        await asyncio.sleep(duracao)
        return f"‚úì {nome} conclu√≠da ASYNC em {duracao}s"
    
    async def _analisarDadosAsync(self) -> str:
        """Simula an√°lise de dados ass√≠ncrona."""
        await asyncio.sleep(2)
        return "‚Ä¢ Padr√µes identificados\n‚Ä¢ Anomalias detectadas\n‚Ä¢ Relat√≥rio gerado"
    
    def _processarDadosSync(self) -> str:
        """Simula processamento de dados s√≠ncrono."""
        time.sleep(2)
        return "Dados processados com sucesso"

# --- Configura√ß√£o do FastAPI ---
app: FastAPI = FastAPI(title="Google Chat Bot - Exemplo H√≠brido")
bot: BotExemplo = BotExemplo()

@app.post("/google-chat-webhook")
async def handleEvent(request: Request) -> Any:
    """Ponto de entrada para todos os eventos do Google Chat."""
    return await bot.handleRequest(request)

@app.get("/")
def home() -> Dict[str, Any]:
    """Endpoint para verifica√ß√£o de sa√∫de."""
    return {
        "status": "ativo", 
        "bot_name": bot.botName, 
        "hybrid_support": True,
        "progressive_responses": True
    }

# Para executar localmente: uvicorn example:app --reload --port 8080
```

## üÜï **Principais Funcionalidades**

### **1. Suporte H√≠brido Sync/Async**

A partir da vers√£o 0.2.5, a biblioteca detecta automaticamente se seus m√©todos `_processMessage` e `_processSlashCommand` s√£o s√≠ncronos ou ass√≠ncronos:

- **M√©todos Ass√≠ncronos (`async def`)**: Ideais para chamadas de API, consultas a bancos de dados, ou qualquer opera√ß√£o I/O. Use `await` para opera√ß√µes n√£o-bloqueantes.
- **M√©todos S√≠ncronos (`def`)**: Perfeitos para processamento local, c√°lculos ou quando voc√™ prefere a simplicidade do c√≥digo s√≠ncrono.

**Voc√™ pode misturar ambos na mesma classe!** A biblioteca automaticamente:
- Detecta o tipo de cada m√©todo usando `inspect.iscoroutinefunction()`
- Usa o pipeline ass√≠ncrono para m√©todos `async`
- Usa o pipeline em thread separada para m√©todos s√≠ncronos
- Mant√©m a mesma l√≥gica de timeout e processamento ass√≠ncrono robusto

### **2. Respostas Progressivas (Progressive Fallback)**

A partir da vers√£o 0.2.5, voc√™ pode implementar respostas progressivas que fornecem feedback imediato e depois atualizam com informa√ß√µes mais detalhadas.

#### **Tipagem Adequada**

Use os tipos exportados pela biblioteca para melhor experi√™ncia de desenvolvimento:

```python
from gchatbot import GChatBot, ExtractedEventData, EventPayload, ResponseType, ProgressiveResponse

class MeuBot(GChatBot):
    def _processMessage(self, text: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
        # Seu c√≥digo aqui
        pass
    
    async def _processSlashCommand(self, command: str, arguments: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
        # Seu c√≥digo aqui
        pass
```

#### **Como Implementar Respostas Progressivas**

**M√©todo S√≠ncrono:**
```python
def _processMessage(self, text: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
    if "analise" in text.lower():
        # Resposta progressiva s√≠ncrona
        quickResponse = "‚ö° Iniciando an√°lise..."
        
        def detailedResponse() -> str:
            time.sleep(5)  # Processamento intensivo
            return "üìä An√°lise completa: Dados processados com sucesso!"
        
        return (quickResponse, detailedResponse)  # Tuple = resposta progressiva
    
    return "Resposta normal"  # String = resposta √∫nica
```

**M√©todo Ass√≠ncrono:**
```python
async def _processSlashCommand(self, command: str, arguments: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
    if command == "relatorio":
        # Resposta progressiva ass√≠ncrona
        quickResponse = "üìã Gerando relat√≥rio..."
        
        async def detailedResponse() -> str:
            await asyncio.sleep(10)  # Opera√ß√£o longa
            return "‚úÖ Relat√≥rio completo gerado com todos os dados!"
        
        return (quickResponse, detailedResponse)  # Tuple = resposta progressiva
    
    return "Comando executado"  # String = resposta √∫nica
```

#### **Como Funciona:**
1. **Resposta Imediata**: O usu√°rio v√™ a resposta r√°pida instantaneamente
2. **Processamento em Background**: A resposta detalhada √© processada em paralelo
3. **Atualiza√ß√£o Autom√°tica**: A mensagem √© atualizada com o resultado final

#### **Casos de Uso Ideais:**
- An√°lises de dados que demoram v√°rios segundos
- Consultas a APIs externas
- Processamento de arquivos
- Relat√≥rios complexos
- Qualquer opera√ß√£o onde voc√™ quer dar feedback imediato ao usu√°rio

#### **Tipos de Resposta Detalhada:**

A resposta detalhada pode ser:
- **String simples**: `"Resultado final"`
- **Fun√ß√£o s√≠ncrona**: `lambda: expensive_computation()`
- **Fun√ß√£o ass√≠ncrona**: `async def detailed(): await api_call()`

### **3. Arquitetura Modular**

A biblioteca foi refatorada para uma arquitetura modular, com cada componente tendo uma responsabilidade clara:

-   `main.py`: Cont√©m a classe principal `GChatBot` e a l√≥gica de orquestra√ß√£o.
-   `parser.py`: Respons√°vel por analisar os payloads dos eventos.
-   `processor.py`: Gerencia o fluxo de resposta ass√≠ncrona.
-   `response.py`: F√°brica para criar as respostas em formato de card.
-   `types.py`: Define todas as estruturas de dados e tipos para clareza e robustez.

### **4. Estrutura de Dados do Evento (`ExtractedEventData`)**

O `EventParser` unifica os diferentes payloads do Google Chat em um dicion√°rio `ExtractedEventData` previs√≠vel:

-   `rawText`, `processedText`, `command`, `arguments`, `userEmail`, `userDisplayName`, `userGoogleChatId`, `spaceName`, `isDirectMessageEvent`, `messageName`, `isFallbackEvent`.

#### **Campos Dispon√≠veis:**

- **`userEmail`**: Email do usu√°rio que enviou a mensagem
- **`userDisplayName`**: Nome de exibi√ß√£o do usu√°rio  
- **`userGoogleChatId`**: ID √∫nico do usu√°rio no Google Chat (ex: `users/123456789012345678901`) - **üÜï Novo na v0.2.5**
- **`rawText`**: Texto original da mensagem
- **`processedText`**: Texto processado (ap√≥s remo√ß√£o de men√ß√µes, etc.)
- **`command`**: Nome do comando slash (sem a `/`) ou `None`
- **`arguments`**: Argumentos do comando ou texto da mensagem
- **`spaceName`**: Nome do espa√ßo/sala onde ocorreu o evento
- **`isDirectMessageEvent`**: `True` se for uma mensagem direta (DM)
- **`messageName`**: Nome da mensagem original (para refer√™ncia)
- **`isFallbackEvent`**: `True` se foi um evento com estrutura n√£o reconhecida

### **5. Tipagem Completa**

Todos os tipos principais s√£o exportados para melhor experi√™ncia de desenvolvimento:

```python
from gchatbot import (
    GChatBot,                    # Classe principal
    ExtractedEventData,          # Dados estruturados do evento
    EventPayload,                # Payload original do Google Chat
    ResponseType,                # Union[str, ProgressiveResponse]
    ProgressiveResponse,         # Tuple[str, Union[str, Callable[[], str], Callable[[], Awaitable[str]]]]
    EventParser,                 # Parser de eventos (uso avan√ßado)
    AsyncProcessor,              # Processador ass√≠ncrono (uso avan√ßado)
    ResponseFactory,             # F√°brica de respostas (uso avan√ßado)
)
```

## Suporte Legado (Flask)

Para garantir a retrocompatibilidade, as classes baseadas em Flask (`GChatBotFlask` e `GChatBotOld`) ainda est√£o dispon√≠veis, mas n√£o s√£o mais recomendadas para novos projetos. A vers√£o `GChatBotFlask` j√° inclui a corre√ß√£o de concorr√™ncia da vers√£o `0.2.4`.

<details>
<summary>Clique para ver o exemplo com Flask</summary>

```python
# app_flask.py
import os
import time
from flask import Flask, request
from gchatbot import GChatBotFlask  # Importe a vers√£o para Flask

class MeuBotFlask(GChatBotFlask):
    def __init__(self):
        super().__init__(
            bot_name="Assistente Flask",
            service_account_file=os.environ.get("SERVICE_ACCOUNT_FILE", "service.json"),
            sync_timeout=3.0
        )
    
    def _process_slash_command(self, command: str, arguments: str, extracted_data: dict, event_data: dict) -> str:
        if command == 'lento':
            time.sleep(5)
            return "Tarefa lenta conclu√≠da no Flask!"
        return "Comando r√°pido executado no Flask."
    
    def _process_message(self, text: str, extracted_data: dict, event_data: dict) -> str:
        return f"Mensagem recebida no Flask: '{text}'"

# Configura√ß√£o da aplica√ß√£o Flask
app = Flask(__name__)
bot_flask = MeuBotFlask()

@app.route('/', methods=['POST'])
def webhook():
    """Endpoint que recebe eventos do Google Chat"""
    return bot_flask.handle_request(request)

@app.route('/', methods=['GET'])
def home():
    """P√°gina inicial para verificar se o servi√ßo est√° rodando"""
    return "Bot Flask est√° ativo!"

if __name__ == '__main__':
    port = int(os.environ.get('PORT', 8080))
    app.run(host='0.0.0.0', port=port, debug=True)
```
</details>

## Configura√ß√£o do Google Chat

Para configurar seu bot no Google Chat:

1.  Acesse o [Google Cloud Console](https://console.cloud.google.com/).
2.  Crie/Configure um projeto.
3.  **Habilite a API do Google Chat**.
4.  V√° para a configura√ß√£o da API do Chat:
    -   **Nome do App, Avatar, Descri√ß√£o:** Preencha os detalhes.
    -   **Funcionalidade:** Habilite "Receber mensagens 1:1" e "Participar de espa√ßos".
    -   **Configura√ß√µes de Conex√£o:**
        -   Selecione "App URL".
        -   Insira a URL p√∫blica do seu endpoint (ex: de um servi√ßo de nuvem ou `ngrok` para testes).

## Execu√ß√£o Local

Para testar seu bot localmente:

```bash
# 1. Instale as depend√™ncias
pip install "gchatbot[fastapi]"

# 2. Configure o arquivo de credenciais
export SERVICE_ACCOUNT_FILE="path/to/your/service-account.json"

# 3. Execute o servidor
uvicorn example:app --reload --port 8080

# 4. Use ngrok para expor publicamente (para testes)
ngrok http 8080
```

## Migra√ß√£o de Vers√µes Anteriores

### De 0.2.4 para 0.2.5

**Mudan√ßas de Compatibilidade:**
- Par√¢metros agora usam camelCase: `extractedData`, `eventData` (antes eram `extracted_data`, `event_data`)
- M√©todos principais mudaram de `_process_message` para `_processMessage` e `_process_slash_command` para `_processSlashCommand`

**Migra√ß√£o Autom√°tica:**
```python
# Antes (ainda funciona, mas deprecated)
def _process_message(self, text, extracted_data, event_data):
    return "Resposta"

# Depois (recomendado)
def _processMessage(self, text: str, extractedData: ExtractedEventData, eventData: EventPayload) -> ResponseType:
    return "Resposta"
```

**Novas Funcionalidades Opcionais:**
- Respostas progressivas: retorne `(quick_response, detailed_response)` em vez de apenas string
- M√©todos ass√≠ncronos: use `async def` para opera√ß√µes I/O intensivas
- Tipagem completa: importe `ResponseType`, `ProgressiveResponse` da biblioteca

# Changelog

## 0.2.6 - 2025-01-18 - Identifica√ß√£o Aprimorada de Usu√°rios

### Novos Recursos (Added)

**üÜî Campo userGoogleChatId:**
- Adicionado campo `userGoogleChatId` ao tipo `ExtractedEventData` para identifica√ß√£o √∫nica de usu√°rios.
- O Google Chat ID √© extra√≠do automaticamente do payload do evento e disponibilizado em `extractedData['userGoogleChatId']`.
- Formato t√≠pico: `users/123456789012345678901` (ID num√©rico √∫nico do Google Chat).
- √ötil para men√ß√µes program√°ticas, identifica√ß√£o √∫nica e refer√™ncias diretas a usu√°rios.

**üìö Exemplos Atualizados:**
- Adicionado comando `/info` no exemplo que demonstra o uso do `userGoogleChatId`.
- Adicionada mensagem `meusdados` que mostra informa√ß√µes completas do usu√°rio.
- Documenta√ß√£o expandida explicando o uso e benef√≠cios do Google Chat ID.

### Melhorias (Improved)

**üîß Parser Aprimorado:**
- Atualizado `EventParser` para extrair o campo `name` do usu√°rio como `userGoogleChatId`.
- Melhor estrutura√ß√£o dos dados do usu√°rio com identifica√ß√£o mais robusta.

**üìñ Documenta√ß√£o:**
- Se√ß√£o expandida sobre estrutura de dados do evento com descri√ß√£o detalhada de todos os campos.
- Exemplos pr√°ticos de como usar o `userGoogleChatId` em diferentes cen√°rios.

---

## 0.2.5 - 2025-01-18 - Suporte H√≠brido Sync/Async e Respostas Progressivas

### Novos Recursos (Added)

**üöÄ Suporte H√≠brido para M√©todos S√≠ncronos e Ass√≠ncronos:**
- Os m√©todos `_processMessage` e `_processSlashCommand` agora podem ser implementados como `async def` ou `def` (s√≠ncrono).
- A biblioteca detecta automaticamente o tipo de m√©todo usando `inspect.iscoroutinefunction()`.
- M√©todos ass√≠ncronos s√£o executados no pipeline async nativo, permitindo opera√ß√µes I/O n√£o-bloqueantes.
- M√©todos s√≠ncronos continuam sendo executados em threads separadas para manter compatibilidade.
- **Flexibilidade Total:** Voc√™ pode misturar m√©todos sync e async na mesma classe de bot.

**üéØ Respostas Progressivas (Progressive Fallback):**
- **Nova funcionalidade:** M√©todos podem retornar `tuple(quick_response, detailed_response)` para respostas em duas etapas.
- **Resposta Imediata:** O usu√°rio v√™ a resposta r√°pida instantaneamente.
- **Atualiza√ß√£o Autom√°tica:** A mensagem √© atualizada com o resultado detalhado quando pronto.
- **Suporte H√≠brido:** Funciona tanto com m√©todos s√≠ncronos quanto ass√≠ncronos.
- **Casos de Uso:** Ideal para an√°lises longas, consultas a APIs, processamento de arquivos, relat√≥rios complexos.
- **Tipos Flex√≠veis:** Resposta detalhada pode ser string, fun√ß√£o s√≠ncrona ou fun√ß√£o ass√≠ncrona.

**üîß Nova Arquitetura de Processamento:**
- Adicionado m√©todo `_processEventAsync()` para lidar especificamente com m√©todos ass√≠ncronos.
- Melhorada a detec√ß√£o de m√©todos async no `handleRequest()` para escolher o pipeline correto.
- Pipeline ass√≠ncrono agora suporta `await` nativo sem convers√µes ou workarounds.
- Implementados m√©todos `_isProgressiveResponse()`, `_handleProgressiveResponse()` e `_sendDetailedResponse()`.

**üìù Tipagem Completa e Padroniza√ß√£o:**
- Todos os m√©todos e vari√°veis agora t√™m anota√ß√µes de tipo completas.
- Padroniza√ß√£o para camelCase em par√¢metros (`extractedData`, `eventData`).
- Exporta√ß√£o de tipos principais (`ExtractedEventData`, `EventPayload`, `ResponseType`, `ProgressiveResponse`) no `__init__.py`.
- Novos type aliases: `ProgressiveResponse` e `ResponseType` centralizados em `types.py`.
- Documenta√ß√£o detalhada com Args e Returns em todos os m√©todos.

**üÜî Identifica√ß√£o Aprimorada de Usu√°rios:**
- Adicionado campo `userGoogleChatId` ao `ExtractedEventData` para identifica√ß√£o √∫nica de usu√°rios.
- O Google Chat ID √© extra√≠do automaticamente do payload e disponibilizado em `extractedData['userGoogleChatId']`.
- √ötil para men√ß√µes program√°ticas, identifica√ß√£o √∫nica e refer√™ncias diretas a usu√°rios.
- Formato t√≠pico: `users/123456789012345678901` (ID num√©rico √∫nico do Google Chat).

### Melhorias (Improved)

**üèóÔ∏è Arquitetura Modular Aprimorada:**
- Separa√ß√£o clara entre processamento s√≠ncrono e ass√≠ncrono.
- Melhor organiza√ß√£o do c√≥digo com m√©todos auxiliares bem definidos.
- Compatibilidade total com vers√µes anteriores mantida.
- Tipos centralizados em `types.py` e exportados adequadamente.

**üìö Documenta√ß√£o e Exemplos:**
- Novo exemplo h√≠brido demonstrando m√©todos sync e async na mesma classe.
- Documenta√ß√£o expandida explicando quando usar cada abordagem.
- Exemplos pr√°ticos de opera√ß√µes concorrentes com `asyncio.gather()`.
- Guias de uso para chamadas de API ass√≠ncronas e processamento intensivo s√≠ncrono.
- **Novo:** Exemplos completos de respostas progressivas tanto s√≠ncronas quanto ass√≠ncronas.
- Se√ß√£o dedicada sobre tipagem e uso dos tipos exportados.
- Guia de migra√ß√£o de vers√µes anteriores.

**üîÑ Gerenciamento de Depend√™ncias:**
- Atualiza√ß√£o do `setup.py` com depend√™ncias opcionais organizadas.
- Suporte para instala√ß√£o modular: `pip install gchatbot[fastapi]`, `gchatbot[flask]`, `gchatbot[async]`.
- Melhor documenta√ß√£o sobre op√ß√µes de instala√ß√£o.

### Corre√ß√µes (Fixed)

**üêõ Corre√ß√£o de Compatibilidade de Tipos:**
- Resolvidos conflitos entre `EventPayload` e `Dict[str, Any]` nas assinaturas de m√©todos.
- Corre√ß√£o de erros de linter relacionados a convers√£o de corrotinas.
- Ajustes na tipagem para suportar `ResponseType` e `ProgressiveResponse` adequadamente.
- Centraliza√ß√£o de tipos em `types.py` para evitar duplica√ß√£o.

**‚ö° Otimiza√ß√µes de Performance:**
- Elimina√ß√£o de convers√µes desnecess√°rias entre sync/async.
- Melhor utiliza√ß√£o de recursos com detec√ß√£o pr√©via do tipo de m√©todo.
- Redu√ß√£o de overhead na cria√ß√£o de tasks desnecess√°rias.
- Processamento mais eficiente de respostas progressivas.

### Detalhes T√©cnicos

**Como Funciona a Detec√ß√£o Autom√°tica:**
```python
# A biblioteca verifica automaticamente:
hasAsyncMethods = (
    inspect.iscoroutinefunction(self._processMessage) or 
    inspect.iscoroutinefunction(self._processSlashCommand)
)

# E escolhe o pipeline apropriado:
if hasAsyncMethods:
    processing_task = asyncio.create_task(self._processEventAsync(extractedData, eventData))
else:
    processing_task = asyncio.create_task(asyncio.to_thread(self._processEvent, extractedData, eventData))
```

**Como Funcionam as Respostas Progressivas:**
```python
# Retornando uma tupla ativa o modo progressivo:
def _processMessage(self, text, extractedData, eventData):
    quick = "‚ö° Processando..."
    def detailed():
        time.sleep(5)
        return "‚úÖ Conclu√≠do!"
    return (quick, detailed)  # Resposta progressiva

# Ou com async:
async def _processSlashCommand(self, command, arguments, extractedData, eventData):
    quick = "üìä Analisando..."
    async def detailed():
        await asyncio.sleep(10)
        return "üìà An√°lise completa!"
    return (quick, detailed)  # Resposta progressiva async
```

**Tipos Dispon√≠veis:**
```python
# Importados de gchatbot.types
ProgressiveResponse = Tuple[str, Union[str, Callable[[], str], Callable[[], Awaitable[str]]]]
ResponseType = Union[str, ProgressiveResponse]
```

**Benef√≠cios para Desenvolvedores:**
- **Flexibilidade:** Escolha a abordagem mais adequada para cada caso de uso.
- **Performance:** M√©todos async aproveitam melhor os recursos do sistema para I/O.
- **Simplicidade:** M√©todos sync mant√™m a simplicidade para processamento local.
- **UX Melhorada:** Respostas progressivas oferecem feedback imediato ao usu√°rio.
- **Compatibilidade:** C√≥digo existente continua funcionando sem modifica√ß√µes.
- **Tipagem:** Suporte completo a type hints para melhor experi√™ncia de desenvolvimento.

---

## 0.2.4 - 2025-01-17 - Corre√ß√£o Definitiva de Concorr√™ncia com Monitoramento de Tasks

### Corre√ß√µes (Fixed)

**üîß Corre√ß√£o Definitiva do Problema de Concorr√™ncia:**
- Substitu√≠da a l√≥gica falha de `_run_async_processing` que reexecutava a l√≥gica de neg√≥cio.
- Implementado novo m√©todo `_handle_async_response` que **monitora** a task original em vez de recriar o trabalho.
- **Resultado:** Elimina√ß√£o completa da duplica√ß√£o de execu√ß√£o e respostas inconsistentes.

**üéØ Nova Arquitetura de Monitoramento:**
- Quando ocorre timeout, a task original continua executando em background.
- Uma thread "monitora" aguarda o resultado da task original usando `future.result()`.
- A l√≥gica de neg√≥cio (`_process_event`) √© executada **apenas uma vez** por evento.
- Resposta imediata "Processando..." seguida de atualiza√ß√£o com resultado final.

**‚ö° Melhorias na Robustez:**
- Adicionada convers√£o autom√°tica `str()` nos resultados para prevenir TypeError.
- Tratamento aprimorado de exce√ß√µes durante o monitoramento de tasks.
- Logs mais detalhados para debugging do fluxo ass√≠ncrono.

---

## 0.2.3 - 2025-04-24 - Corre√ß√µes de Concorr√™ncia, Timeout e Tipo de Resposta

### Corre√ß√µes (Fixed)

**Manuseio de Timeout e Concorr√™ncia:**
- Problema: O uso anterior de `with ThreadPoolExecutor()` no `handle_request` causava um bloqueio (`shutdown(wait=True)`) no handler HTTP quando o `sync_timeout` era atingido. Isso levava o Google Chat a reenviar o evento, resultando em m√∫ltiplas threads e respostas duplicadas.
- Solu√ß√£o: Substitu√≠do por instancia√ß√£o manual do `ThreadPoolExecutor` e chamada expl√≠cita `executor.shutdown(wait=False)` no caso de timeout, liberando o handler HTTP imediatamente. A thread `_run_async_processing` para a resposta ass√≠ncrona agora √© iniciada apenas uma vez por evento original.
- Resultado: Resposta HTTP 200 OK imediata em caso de timeout, sem bloqueios e sem respostas duplicadas.

**Preven√ß√£o de TypeError na Resposta:**
- Problema: Potencial `TypeError: bad argument type for built-in operation` poderia ocorrer durante a cria√ß√£o/atualiza√ß√£o do card de resposta se os m√©todos de processamento da subclasse (`_process_message`, `_process_slash_command`) retornassem valores n√£o-string (ex: None, n√∫meros).
- Solu√ß√£o: Adicionada convers√£o autom√°tica para string (`str()`) ao resultado dentro do m√©todo `GChatBot._process_event` antes de ser usado.
- Resultado: Garante que o texto da resposta seja sempre uma string, prevenindo o TypeError e aumentando a robustez da classe base.

---

## Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT. Veja o arquivo [LICENSE](LICENSE) para mais detalhes.

## Contribui√ß√µes

Contribui√ß√µes s√£o bem-vindas! Por favor, abra uma issue ou envie um pull request.

## Suporte

Se voc√™ encontrar problemas ou tiver d√∫vidas:

1. Verifique a documenta√ß√£o acima
2. Consulte os exemplos fornecidos
3. Abra uma issue no reposit√≥rio do projeto

---

**Desenvolvido com ‚ù§Ô∏è para simplificar o desenvolvimento de bots Google Chat em Python.**
