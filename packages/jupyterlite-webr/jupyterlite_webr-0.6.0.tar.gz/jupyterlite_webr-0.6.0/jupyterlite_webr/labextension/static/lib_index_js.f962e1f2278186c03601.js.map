{"version":3,"file":"lib_index_js.f962e1f2278186c03601.js","mappings":";;;;;;;;;;;;;;;;;;;;;;AAAmD;AACQ;AAChB;AACkC;AACA;AACjB;AAC5D;AACA;AACA;AACA;AACA,eAAe,6DAAY;AAC3B,eAAe,sEAAqB;AACpC;AACA,kCAAkC,6DAAU,uCAAuC;AACnF;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,kCAAkC,yDAAM;AACxC;AACA;AACA,kCAAkC,yDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,gCAAgC;AAChC,iBAAiB;AACjB;AACA,kCAAkC,yFAAM;AACxC,kCAAkC,yFAAM;AACxC,iBAAiB;AACjB,aAAa;AACb;AACA,2BAA2B,oDAAU,GAAG,YAAY;AACpD,aAAa;AACb,SAAS;AACT,KAAK;AACL;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;ACrDvB,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAI,IAAI,SAAI;AAC1C;AACA;AACA;AACA;AACA;AACiD;AAClB;AAC/B;AACO,yBAAyB,2DAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,yCAAO;AACzE;AACA;AACA,oDAAoD,yBAAyB;AAC7E,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,2FAA2F;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,6BAA6B,aAAa,OAAO,aAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uBAAuB,oBAAoB;AAC3C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,sCAAsC,uCAAuC;AAC7E;AACA;AACA,sCAAsC,uCAAuC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,SAAS;AAC7B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA,0BAA0B,iDAAiD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,IAAI;AACxB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,kEAAkE,GAAG,mEAAmE;AACvL;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChPA,iEAAe,qBAAuB,yCAAyC;;;;;;;;;;;;;;ACA/E,iEAAe,qBAAuB,yCAAyC","sources":["webpack://@r-wasm/jupyterlite-webr-kernel/./lib/index.js","webpack://@r-wasm/jupyterlite-webr-kernel/./lib/webr_kernel.js","webpack://@r-wasm/jupyterlite-webr-kernel/./style/logos/r-logo-32x32.png","webpack://@r-wasm/jupyterlite-webr-kernel/./style/logos/r-logo-64x64.png"],"sourcesContent":["import { IKernelSpecs } from '@jupyterlite/kernel';\nimport { PageConfig, URLExt } from '@jupyterlab/coreutils';\nimport { WebRKernel } from './webr_kernel';\nimport logo32 from '!!file-loader?context=.!../style/logos/r-logo-32x32.png';\nimport logo64 from '!!file-loader?context=.!../style/logos/r-logo-64x64.png';\nimport { IServiceWorkerManager } from '@jupyterlite/server';\nconst PLUGIN_ID = '@r-wasm/webr-kernel-extension:kernel';\nconst server_kernel = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    requires: [IKernelSpecs],\n    optional: [IServiceWorkerManager],\n    activate: (app, kernelspecs, serviceWorkerManager) => {\n        const config = JSON.parse(PageConfig.getOption('litePluginSettings') || '{}')[PLUGIN_ID] || {};\n        const webROptions = {\n            REnv: {\n                R_HOME: '/usr/lib/R',\n                FONTCONFIG_PATH: '/etc/fonts',\n                R_ENABLE_JIT: '0',\n            },\n        };\n        if (config.baseUrl) {\n            webROptions.baseUrl = URLExt.parse(config.baseUrl).href;\n        }\n        if (config.repoUrl) {\n            webROptions.repoUrl = URLExt.parse(config.repoUrl).href;\n        }\n        kernelspecs.register({\n            spec: {\n                name: 'webR',\n                display_name: 'R (webR)',\n                language: 'R',\n                argv: [],\n                spec: {\n                    argv: [],\n                    env: {},\n                    display_name: 'R (webR)',\n                    language: 'R',\n                    interrupt_mode: 'message',\n                    metadata: {},\n                },\n                resources: {\n                    'logo-32x32': logo32,\n                    'logo-64x64': logo64,\n                },\n            },\n            create: async (options) => {\n                return new WebRKernel({ ...options }, webROptions, serviceWorkerManager);\n            },\n        });\n    },\n};\nconst plugins = [server_kernel];\nexport default plugins;\n","var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _WebRKernel_webRConsole, _WebRKernel_bitmapCanvas, _WebRKernel_lastPlot;\nimport { BaseKernel } from '@jupyterlite/kernel';\nimport { Console } from 'webr';\nconst protocolVersion = \"5.3\";\nexport class WebRKernel extends BaseKernel {\n    constructor(options, webROptions, serviceWorkerManager) {\n        super(options);\n        this.serviceWorkerManager = serviceWorkerManager;\n        _WebRKernel_webRConsole.set(this, void 0);\n        _WebRKernel_bitmapCanvas.set(this, void 0);\n        _WebRKernel_lastPlot.set(this, null);\n        __classPrivateFieldSet(this, _WebRKernel_webRConsole, new Console({\n            stdout: (line) => console.log(line),\n            stderr: (line) => console.error(line),\n            prompt: (prompt) => this.inputRequest({ prompt, password: false }),\n        }, webROptions), \"f\");\n        this.webR = __classPrivateFieldGet(this, _WebRKernel_webRConsole, \"f\").webR;\n        this.init = this.setupEnvironment();\n        __classPrivateFieldSet(this, _WebRKernel_bitmapCanvas, document.createElement('canvas'), \"f\");\n    }\n    async setupEnvironment() {\n        var _a;\n        await this.webR.init();\n        this.shelter = await new this.webR.Shelter();\n        // Enable dev.control to allow active plots to be copied\n        await this.webR.evalRVoid(`\n      options(device = function(...){\n        webr::canvas(...)\n        dev.control(\"enable\")\n      }, webr.plot.new = FALSE)\n    `);\n        // Create a signal when there is a new plot to be shown in JupyterLite\n        await this.webR.evalRVoid(`\n      setHook(\"grid.newpage\", function() {\n        options(webr.plot.new = TRUE)\n      }, \"replace\")\n      setHook(\"plot.new\", function() {\n        options(webr.plot.new = TRUE)\n      }, \"replace\")\n    `);\n        // Default figure size\n        await this.webR.evalRVoid(`\n      options(webr.fig.width = 7, webr.fig.height = 5.25)\n    `);\n        // Install package management shims\n        await this.webR.evalRVoid(`\n      webr::shim_install()\n    `);\n        // Mount Jupyterlite storage and set the CWD\n        await this.webR.evalRVoid(`\n      options(webr.drivefs.browsingContextId = \"${(_a = this.serviceWorkerManager) === null || _a === void 0 ? void 0 : _a.browsingContextId}\")\n      webr::mount(\"/drive\", type=\"DRIVEFS\")\n      setwd(\"/drive\")\n    `);\n    }\n    inputReply(content) {\n        if (content.status === 'ok') {\n            __classPrivateFieldGet(this, _WebRKernel_webRConsole, \"f\").stdin(content.value);\n        }\n    }\n    async kernelInfoRequest() {\n        await this.init;\n        const webRVersion = this.webR.version;\n        const baseRVersion = await this.webR.evalRString(\"as.character(getRversion())\");\n        const content = {\n            status: 'ok',\n            protocol_version: protocolVersion,\n            implementation: 'webr',\n            implementation_version: webRVersion,\n            language_info: {\n                name: 'R',\n                version: baseRVersion,\n                mimetype: 'text/x-rsrc',\n                file_extension: '.R',\n            },\n            banner: `webR v${webRVersion} - R v${baseRVersion}`,\n            help_links: [\n                {\n                    text: 'WebAssembly R Kernel',\n                    url: 'https://github.com/r-wasm/jupyterlite-webr-kernel',\n                }\n            ],\n        };\n        return content;\n    }\n    async executeRequest(content) {\n        await this.init;\n        try {\n            const exec = await this.shelter.captureR(`\n        withVisible({\n          eval(parse(text = code), envir = globalenv())\n        })\n      `, {\n                env: { code: content.code },\n                captureGraphics: false, // We handle graphics capture, to support incremental plotting\n            });\n            const output = exec.output;\n            // Deal with showing stream and condition outputs\n            output.forEach(async (out) => {\n                switch (out.type) {\n                    case 'stdout':\n                        this.stream({ name: 'stdout', text: out.data + '\\n' });\n                        break;\n                    case 'stderr':\n                        this.stream({ name: 'stderr', text: out.data + '\\n' });\n                        break;\n                    case 'message': {\n                        const cnd = out.data;\n                        const message = (await cnd.get('message'));\n                        this.stream({\n                            name: 'stderr',\n                            text: (await message.toString()) + '\\n',\n                        });\n                        break;\n                    }\n                    case 'warning': {\n                        const cnd = out.data;\n                        const message = (await cnd.get('message'));\n                        this.stream({\n                            name: 'stderr',\n                            text: 'Warning message:\\n' + (await message.toString()) + '\\n',\n                        });\n                        break;\n                    }\n                }\n            });\n            // Send the result if it's visible\n            const visible = await exec.result.get('visible');\n            if (await visible.toBoolean()) {\n                const value = await exec.result.get('value');\n                const exec_result = await this.shelter.evalR(`\n          capture.output(print(value))\n        `, { env: { value } });\n                this.publishExecuteResult({\n                    execution_count: this.executionCount,\n                    data: {\n                        'text/plain': [await (await exec_result.toArray()).join('\\n')],\n                    },\n                    metadata: {}\n                });\n            }\n            // Send an R plot if there are changes to the graphics device\n            await this.plotOutput();\n            // Send success signal\n            return {\n                status: 'ok',\n                execution_count: this.executionCount,\n                user_expressions: {},\n            };\n        }\n        catch (e) {\n            const evalue = e.message;\n            this.stream({ name: 'stderr', text: 'Error: ' + evalue + '\\n' });\n            return {\n                status: 'error',\n                execution_count: this.executionCount,\n                ename: 'error',\n                evalue,\n                traceback: [],\n            };\n        }\n        finally {\n            await this.shelter.purge();\n        }\n    }\n    async plotOutput() {\n        var _a;\n        const dev = await this.webR.evalRNumber('dev.cur()');\n        const newPlot = await this.webR.evalRBoolean('getOption(\"webr.plot.new\")');\n        if (dev > 1) {\n            const capturePlot = await this.shelter.captureR(`\n        try({\n          w <- getOption(\"webr.fig.width\")\n          h <- getOption(\"webr.fig.height\")\n          webr::canvas(width = 72 * w, height = 72 * h, capture = TRUE)\n          capture_dev = dev.cur();\n\n          dev.set(${dev})\n          dev.copy(which = capture_dev)\n          dev.off(capture_dev)\n        }, silent = TRUE)\n      `);\n            const image = capturePlot.images[0];\n            __classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").width = image.width;\n            __classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").height = image.height;\n            (_a = __classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").getContext('bitmaprenderer')) === null || _a === void 0 ? void 0 : _a.transferFromImageBitmap(image);\n            const plotData = __classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").toDataURL('image/png');\n            if (newPlot || plotData !== __classPrivateFieldGet(this, _WebRKernel_lastPlot, \"f\")) {\n                __classPrivateFieldSet(this, _WebRKernel_lastPlot, plotData, \"f\");\n                this.displayData({\n                    data: {\n                        'image/png': plotData.split(\",\")[1],\n                        'text/plain': [\n                            `<Figure of size ${__classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").width}x${__classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").height}>`\n                        ]\n                    },\n                    metadata: {\n                        'image/png': {\n                            width: 3 * __classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").width / 4,\n                            height: 3 * __classPrivateFieldGet(this, _WebRKernel_bitmapCanvas, \"f\").height / 4,\n                        }\n                    },\n                });\n                await this.webR.evalRVoid('options(webr.plot.new = FALSE)');\n            }\n        }\n    }\n    async completeRequest() {\n        throw new Error('Unimplemented');\n    }\n    async inspectRequest() {\n        throw new Error('Unimplemented');\n    }\n    async isCompleteRequest() {\n        throw new Error('Unimplemented');\n    }\n    async commInfoRequest() {\n        throw new Error('Unimplemented');\n    }\n    async commOpen() {\n        throw new Error('Unimplemented');\n    }\n    async commMsg() {\n        throw new Error('Unimplemented');\n    }\n    async commClose() {\n        throw new Error('Unimplemented');\n    }\n}\n_WebRKernel_webRConsole = new WeakMap(), _WebRKernel_bitmapCanvas = new WeakMap(), _WebRKernel_lastPlot = new WeakMap();\n","export default __webpack_public_path__ + \"c0aaa09171ee16729b12a148c532baa8.png\";","export default __webpack_public_path__ + \"da1166e72a7daee41c4b332dd06e206d.png\";"],"names":[],"sourceRoot":""}