"use strict";
(self["webpackChunk_r_wasm_jupyterlite_webr_kernel"] = self["webpackChunk_r_wasm_jupyterlite_webr_kernel"] || []).push([["vendors-node_modules_jupyterlite_server_lib_index_js"],{

/***/ "./node_modules/@jupyterlite/contents/lib/drivecontents.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@jupyterlite/contents/lib/drivecontents.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DriveContentsProcessor: () => (/* binding */ DriveContentsProcessor)
/* harmony export */ });
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/coreutils */ "webpack/sharing/consume/default/@jupyterlab/coreutils");
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _drivefs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./drivefs */ "./node_modules/@jupyterlite/contents/lib/drivefs.js");
/* harmony import */ var _emscripten__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./emscripten */ "./node_modules/@jupyterlite/contents/lib/emscripten.js");



/**
 * Class for processing a drive request from the DriveFS.
 */
class DriveContentsProcessor {
    constructor(options) {
        this.contentsManager = options.contentsManager;
    }
    async processDriveRequest(request) {
        switch (request.method) {
            case 'readdir':
                return this.readdir(request);
            case 'rmdir':
                return this.rmdir(request);
            case 'rename':
                return this.rename(request);
            case 'getmode':
                return this.getmode(request);
            case 'lookup':
                return this.lookup(request);
            case 'mknod':
                return this.mknod(request);
            case 'getattr':
                return this.getattr(request);
            case 'get':
                return this.get(request);
            case 'put':
                return this.put(request);
        }
        throw `Drive request ${request.method} does not exist.`;
    }
    async readdir(request) {
        const model = await this.contentsManager.get(request.path, { content: true });
        let response = [];
        if (model.type === 'directory' && model.content) {
            response = model.content.map((subcontent) => subcontent.name);
        }
        return response;
    }
    async rmdir(request) {
        await this.contentsManager.delete(request.path);
        return null;
    }
    async rename(request) {
        await this.contentsManager.rename(request.path, request.data.newPath);
        return null;
    }
    async getmode(request) {
        const model = await this.contentsManager.get(request.path);
        let response;
        if (model.type === 'directory') {
            response = _emscripten__WEBPACK_IMPORTED_MODULE_1__.DIR_MODE;
        }
        else {
            response = _emscripten__WEBPACK_IMPORTED_MODULE_1__.FILE_MODE;
        }
        return response;
    }
    async lookup(request) {
        let response;
        try {
            const model = await this.contentsManager.get(request.path);
            response = {
                ok: true,
                mode: model.type === 'directory' ? _emscripten__WEBPACK_IMPORTED_MODULE_1__.DIR_MODE : _emscripten__WEBPACK_IMPORTED_MODULE_1__.FILE_MODE,
            };
        }
        catch (e) {
            response = { ok: false };
        }
        return response;
    }
    async mknod(request) {
        const model = await this.contentsManager.newUntitled({
            path: _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.PathExt.dirname(request.path),
            type: request.data.mode === _emscripten__WEBPACK_IMPORTED_MODULE_1__.DIR_MODE ? 'directory' : 'file',
            ext: _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.PathExt.extname(request.path),
        });
        await this.contentsManager.rename(model.path, request.path);
        return null;
    }
    async getattr(request) {
        const model = await this.contentsManager.get(request.path);
        // create a default date for drives that send incomplete information
        // for nested foldes and files
        const defaultDate = new Date(0).toISOString();
        return {
            dev: 1,
            nlink: 1,
            uid: 0,
            gid: 0,
            rdev: 0,
            size: model.size || 0,
            blksize: _drivefs__WEBPACK_IMPORTED_MODULE_2__.BLOCK_SIZE,
            blocks: Math.ceil(model.size || 0 / _drivefs__WEBPACK_IMPORTED_MODULE_2__.BLOCK_SIZE),
            atime: model.last_modified || defaultDate, // TODO Get the proper atime?
            mtime: model.last_modified || defaultDate,
            ctime: model.created || defaultDate,
            timestamp: 0,
        };
    }
    async get(request) {
        const model = await this.contentsManager.get(request.path, { content: true });
        let response;
        if (model.type !== 'directory') {
            response = {
                content: model.format === 'json' ? JSON.stringify(model.content) : model.content,
                format: model.format,
            };
        }
        return response;
    }
    async put(request) {
        await this.contentsManager.save(request.path, {
            content: request.data.format === 'json'
                ? JSON.parse(request.data.data)
                : request.data.data,
            type: 'file',
            format: request.data.format,
        });
        return null;
    }
}


/***/ }),

/***/ "./node_modules/@jupyterlite/contents/lib/drivefs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@jupyterlite/contents/lib/drivefs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BLOCK_SIZE: () => (/* binding */ BLOCK_SIZE),
/* harmony export */   ContentsAPI: () => (/* binding */ ContentsAPI),
/* harmony export */   DRIVE_SEPARATOR: () => (/* binding */ DRIVE_SEPARATOR),
/* harmony export */   DriveFS: () => (/* binding */ DriveFS),
/* harmony export */   DriveFSEmscriptenNodeOps: () => (/* binding */ DriveFSEmscriptenNodeOps),
/* harmony export */   DriveFSEmscriptenStreamOps: () => (/* binding */ DriveFSEmscriptenStreamOps),
/* harmony export */   ServiceWorkerContentsAPI: () => (/* binding */ ServiceWorkerContentsAPI)
/* harmony export */ });
/* harmony import */ var _emscripten__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./emscripten */ "./node_modules/@jupyterlite/contents/lib/emscripten.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.

const DRIVE_SEPARATOR = ':';
const BLOCK_SIZE = 4096;
const encoder = new TextEncoder();
const decoder = new TextDecoder('utf-8');
// Mapping flag -> do we need to overwrite the file upon closing it
const flagNeedsWrite = {
    0 /*O_RDONLY*/: false,
    1 /*O_WRONLY*/: true,
    2 /*O_RDWR*/: true,
    64 /*O_CREAT*/: true,
    65 /*O_WRONLY|O_CREAT*/: true,
    66 /*O_RDWR|O_CREAT*/: true,
    129 /*O_WRONLY|O_EXCL*/: true,
    193 /*O_WRONLY|O_CREAT|O_EXCL*/: true,
    514 /*O_RDWR|O_TRUNC*/: true,
    577 /*O_WRONLY|O_CREAT|O_TRUNC*/: true,
    578 /*O_CREAT|O_RDWR|O_TRUNC*/: true,
    705 /*O_WRONLY|O_CREAT|O_EXCL|O_TRUNC*/: true,
    706 /*O_RDWR|O_CREAT|O_EXCL|O_TRUNC*/: true,
    1024 /*O_APPEND*/: true,
    1025 /*O_WRONLY|O_APPEND*/: true,
    1026 /*O_RDWR|O_APPEND*/: true,
    1089 /*O_WRONLY|O_CREAT|O_APPEND*/: true,
    1090 /*O_RDWR|O_CREAT|O_APPEND*/: true,
    1153 /*O_WRONLY|O_EXCL|O_APPEND*/: true,
    1154 /*O_RDWR|O_EXCL|O_APPEND*/: true,
    1217 /*O_WRONLY|O_CREAT|O_EXCL|O_APPEND*/: true,
    1218 /*O_RDWR|O_CREAT|O_EXCL|O_APPEND*/: true,
    4096 /*O_RDONLY|O_DSYNC*/: true,
    4098 /*O_RDWR|O_DSYNC*/: true,
};
class DriveFSEmscriptenStreamOps {
    constructor(fs) {
        this.fs = fs;
    }
    open(stream) {
        const path = this.fs.realPath(stream.node);
        if (this.fs.FS.isFile(stream.node.mode)) {
            stream.file = this.fs.API.get(path);
        }
    }
    close(stream) {
        if (!this.fs.FS.isFile(stream.node.mode) || !stream.file) {
            return;
        }
        const path = this.fs.realPath(stream.node);
        const flags = stream.flags;
        let parsedFlags = typeof flags === 'string' ? parseInt(flags, 10) : flags;
        parsedFlags &= 0x1fff;
        let needsWrite = true;
        if (parsedFlags in flagNeedsWrite) {
            needsWrite = flagNeedsWrite[parsedFlags];
        }
        if (needsWrite) {
            this.fs.API.put(path, stream.file);
        }
        stream.file = undefined;
    }
    read(stream, buffer, offset, length, position) {
        if (length <= 0 ||
            stream.file === undefined ||
            position >= (stream.file.data.length || 0)) {
            return 0;
        }
        const size = Math.min(stream.file.data.length - position, length);
        buffer.set(stream.file.data.subarray(position, position + size), offset);
        return size;
    }
    write(stream, buffer, offset, length, position) {
        var _a;
        if (length <= 0 || stream.file === undefined) {
            return 0;
        }
        stream.node.timestamp = Date.now();
        if (position + length > (((_a = stream.file) === null || _a === void 0 ? void 0 : _a.data.length) || 0)) {
            const oldData = stream.file.data ? stream.file.data : new Uint8Array();
            stream.file.data = new Uint8Array(position + length);
            stream.file.data.set(oldData);
        }
        stream.file.data.set(buffer.subarray(offset, offset + length), position);
        return length;
    }
    llseek(stream, offset, whence) {
        let position = offset;
        if (whence === _emscripten__WEBPACK_IMPORTED_MODULE_0__.SEEK_CUR) {
            position += stream.position;
        }
        else if (whence === _emscripten__WEBPACK_IMPORTED_MODULE_0__.SEEK_END) {
            if (this.fs.FS.isFile(stream.node.mode)) {
                if (stream.file !== undefined) {
                    position += stream.file.data.length;
                }
                else {
                    throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EPERM);
                }
            }
        }
        if (position < 0) {
            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES.EINVAL);
        }
        return position;
    }
}
class DriveFSEmscriptenNodeOps {
    constructor(fs) {
        this.fs = fs;
    }
    node(nodeOrStream) {
        if ((0,_emscripten__WEBPACK_IMPORTED_MODULE_0__.instanceOfStream)(nodeOrStream)) {
            return nodeOrStream.node;
        }
        return nodeOrStream;
    }
    getattr(value) {
        const node = this.node(value);
        return {
            ...this.fs.API.getattr(this.fs.realPath(node)),
            mode: node.mode,
            ino: node.id,
        };
    }
    setattr(value, attr) {
        const node = this.node(value);
        for (const [key, value] of Object.entries(attr)) {
            switch (key) {
                case 'mode':
                    node.mode = value;
                    break;
                case 'timestamp':
                    node.timestamp = value;
                    break;
                case 'size': {
                    const size = value;
                    const path = this.fs.realPath(node);
                    if (this.fs.FS.isFile(node.mode) && size >= 0) {
                        const file = this.fs.API.get(path);
                        const oldData = file.data ? file.data : new Uint8Array();
                        if (size !== oldData.length) {
                            if (size < oldData.length) {
                                file.data = file.data.slice(0, size);
                            }
                            else {
                                file.data = new Uint8Array(size);
                                file.data.set(oldData);
                            }
                            this.fs.API.put(path, file);
                        }
                    }
                    else {
                        console.warn('setattr size of', size, 'on', node, 'not yet implemented');
                    }
                    break;
                }
                default:
                    console.warn('setattr', key, 'of', value, 'on', node, 'not yet implemented');
                    break;
            }
        }
    }
    lookup(parent, name) {
        const node = this.node(parent);
        const path = this.fs.PATH.join2(this.fs.realPath(node), name);
        const result = this.fs.API.lookup(path);
        if (!result.ok) {
            throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['ENOENT']);
        }
        return this.fs.createNode(node, name, result.mode, 0);
    }
    mknod(parent, name, mode, dev) {
        const node = this.node(parent);
        const path = this.fs.PATH.join2(this.fs.realPath(node), name);
        this.fs.API.mknod(path, mode);
        return this.fs.createNode(node, name, mode, dev);
    }
    rename(value, newDir, newName) {
        const oldNode = this.node(value);
        const newDirNode = this.node(newDir);
        this.fs.API.rename(oldNode.parent
            ? this.fs.PATH.join2(this.fs.realPath(oldNode.parent), oldNode.name)
            : oldNode.name, this.fs.PATH.join2(this.fs.realPath(newDirNode), newName));
        // Updating the in-memory node
        oldNode.name = newName;
        oldNode.parent = newDirNode;
    }
    unlink(parent, name) {
        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));
    }
    rmdir(parent, name) {
        this.fs.API.rmdir(this.fs.PATH.join2(this.fs.realPath(this.node(parent)), name));
    }
    readdir(value) {
        return this.fs.API.readdir(this.fs.realPath(this.node(value)));
    }
    symlink(parent, newName, oldPath) {
        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);
    }
    readlink(node) {
        throw new this.fs.FS.ErrnoError(this.fs.ERRNO_CODES['EPERM']);
    }
}
/**
 * ContentsAPI base class
 */
class ContentsAPI {
    constructor(options) {
        this._driveName = options.driveName;
        this._mountpoint = options.mountpoint;
        this.FS = options.FS;
        this.ERRNO_CODES = options.ERRNO_CODES;
    }
    lookup(path) {
        return this.request({ method: 'lookup', path: this.normalizePath(path) });
    }
    getmode(path) {
        return this.request({ method: 'getmode', path: this.normalizePath(path) });
    }
    mknod(path, mode) {
        return this.request({
            method: 'mknod',
            path: this.normalizePath(path),
            data: { mode },
        });
    }
    rename(oldPath, newPath) {
        return this.request({
            method: 'rename',
            path: this.normalizePath(oldPath),
            data: { newPath: this.normalizePath(newPath) },
        });
    }
    readdir(path) {
        const dirlist = this.request({
            method: 'readdir',
            path: this.normalizePath(path),
        });
        dirlist.push('.');
        dirlist.push('..');
        return dirlist;
    }
    rmdir(path) {
        return this.request({ method: 'rmdir', path: this.normalizePath(path) });
    }
    get(path) {
        const response = this.request({
            method: 'get',
            path: this.normalizePath(path),
        });
        if (!response) {
            throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);
        }
        const serializedContent = response.content;
        const format = response.format;
        switch (format) {
            case 'json':
            case 'text':
                return {
                    data: encoder.encode(serializedContent),
                    format,
                };
            case 'base64': {
                const binString = atob(serializedContent);
                const len = binString.length;
                const data = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    data[i] = binString.charCodeAt(i);
                }
                return {
                    data,
                    format,
                };
            }
            default:
                throw new this.FS.ErrnoError(this.ERRNO_CODES['ENOENT']);
        }
    }
    put(path, value) {
        switch (value.format) {
            case 'json':
            case 'text':
                return this.request({
                    method: 'put',
                    path: this.normalizePath(path),
                    data: {
                        format: value.format,
                        data: decoder.decode(value.data),
                    },
                });
            case 'base64': {
                let binary = '';
                for (let i = 0; i < value.data.byteLength; i++) {
                    binary += String.fromCharCode(value.data[i]);
                }
                return this.request({
                    method: 'put',
                    path: this.normalizePath(path),
                    data: {
                        format: value.format,
                        data: btoa(binary),
                    },
                });
            }
        }
    }
    getattr(path) {
        const stats = this.request({
            method: 'getattr',
            path: this.normalizePath(path),
        });
        // Turn datetimes into proper objects
        if (stats.atime) {
            stats.atime = new Date(stats.atime);
        }
        if (stats.mtime) {
            stats.mtime = new Date(stats.mtime);
        }
        if (stats.ctime) {
            stats.ctime = new Date(stats.ctime);
        }
        // ensure a non-undefined size (0 isn't great, though)
        stats.size = stats.size || 0;
        return stats;
    }
    /**
     * Normalize a Path by making it compliant for the content manager
     *
     * @param path: the path relatively to the Emscripten drive
     */
    normalizePath(path) {
        // Remove mountpoint prefix
        if (path.startsWith(this._mountpoint)) {
            path = path.slice(this._mountpoint.length);
        }
        // Add JupyterLab drive name
        if (this._driveName) {
            path = `${this._driveName}${DRIVE_SEPARATOR}${path}`;
        }
        return path;
    }
}
/**
 * An Emscripten-compatible synchronous Contents API using the service worker.
 */
class ServiceWorkerContentsAPI extends ContentsAPI {
    /**
     * Construct a new ServiceWorkerContentsAPI.
     */
    constructor(options) {
        super(options);
        this._baseUrl = options.baseUrl;
        this._browsingContextId = options.browsingContextId || '';
    }
    request(data) {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', encodeURI(this.endpoint), false);
        // Add the origin browsing context ID to the request
        const requestWithBrowsingContextId = {
            data,
            browsingContextId: this._browsingContextId,
        };
        try {
            xhr.send(JSON.stringify(requestWithBrowsingContextId));
        }
        catch (e) {
            console.error(e);
        }
        if (xhr.status >= 400) {
            throw new this.FS.ErrnoError(this.ERRNO_CODES['EINVAL']);
        }
        return JSON.parse(xhr.responseText);
    }
    /**
     * Get the api/drive endpoint
     */
    get endpoint() {
        return `${this._baseUrl}api/drive`;
    }
}
class DriveFS {
    constructor(options) {
        this.FS = options.FS;
        this.PATH = options.PATH;
        this.ERRNO_CODES = options.ERRNO_CODES;
        this.API = this.createAPI(options);
        this.driveName = options.driveName;
        this.node_ops = new DriveFSEmscriptenNodeOps(this);
        this.stream_ops = new DriveFSEmscriptenStreamOps(this);
    }
    /**
     * Create the ContentsAPI.
     *
     * This is supposed to be overwritten if needed.
     */
    createAPI(options) {
        if (!options.browsingContextId || !options.baseUrl) {
            throw new Error('Cannot create service-worker API without current browsingContextId');
        }
        return new ServiceWorkerContentsAPI(options);
    }
    mount(mount) {
        return this.createNode(null, mount.mountpoint, _emscripten__WEBPACK_IMPORTED_MODULE_0__.DIR_MODE | 511, 0);
    }
    createNode(parent, name, mode, dev) {
        const FS = this.FS;
        if (!FS.isDir(mode) && !FS.isFile(mode)) {
            throw new FS.ErrnoError(this.ERRNO_CODES['EINVAL']);
        }
        const node = FS.createNode(parent, name, mode, dev);
        node.node_ops = this.node_ops;
        node.stream_ops = this.stream_ops;
        return node;
    }
    getMode(path) {
        return this.API.getmode(path);
    }
    realPath(node) {
        const parts = [];
        let currentNode = node;
        parts.push(currentNode.name);
        while (currentNode.parent !== currentNode) {
            currentNode = currentNode.parent;
            parts.push(currentNode.name);
        }
        parts.reverse();
        return this.PATH.join.apply(null, parts);
    }
}


/***/ }),

/***/ "./node_modules/@jupyterlite/contents/lib/emscripten.js":
/*!**************************************************************!*\
  !*** ./node_modules/@jupyterlite/contents/lib/emscripten.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DIR_MODE: () => (/* binding */ DIR_MODE),
/* harmony export */   FILE_MODE: () => (/* binding */ FILE_MODE),
/* harmony export */   SEEK_CUR: () => (/* binding */ SEEK_CUR),
/* harmony export */   SEEK_END: () => (/* binding */ SEEK_END),
/* harmony export */   instanceOfStream: () => (/* binding */ instanceOfStream)
/* harmony export */ });
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
const DIR_MODE = 16895; // 040777
const FILE_MODE = 33206; // 100666
const SEEK_CUR = 1;
const SEEK_END = 2;
function instanceOfStream(nodeOrStream) {
    return 'node' in nodeOrStream;
}


/***/ }),

/***/ "./node_modules/@jupyterlite/server/lib/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@jupyterlite/server/lib/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IServiceWorkerManager: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_0__.IServiceWorkerManager),
/* harmony export */   SERVICE_WORKER_BROADCAST_CHANNEL_ID: () => (/* reexport safe */ _service_worker_manager__WEBPACK_IMPORTED_MODULE_1__.SERVICE_WORKER_BROADCAST_CHANNEL_ID),
/* harmony export */   ServiceWorkerManager: () => (/* reexport safe */ _service_worker_manager__WEBPACK_IMPORTED_MODULE_1__.ServiceWorkerManager),
/* harmony export */   WORKER_NAME: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_0__.WORKER_NAME)
/* harmony export */ });
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tokens */ "./node_modules/@jupyterlite/server/lib/tokens.js");
/* harmony import */ var _service_worker_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service-worker-manager */ "./node_modules/@jupyterlite/server/lib/service-worker-manager.js");
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.




/***/ }),

/***/ "./node_modules/@jupyterlite/server/lib/service-worker-manager.js":
/*!************************************************************************!*\
  !*** ./node_modules/@jupyterlite/server/lib/service-worker-manager.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SERVICE_WORKER_BROADCAST_CHANNEL_ID: () => (/* binding */ SERVICE_WORKER_BROADCAST_CHANNEL_ID),
/* harmony export */   ServiceWorkerManager: () => (/* binding */ ServiceWorkerManager)
/* harmony export */ });
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jupyterlab/coreutils */ "webpack/sharing/consume/default/@jupyterlab/coreutils");
/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _jupyterlite_contents__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @jupyterlite/contents */ "./node_modules/@jupyterlite/contents/lib/drivecontents.js");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lumino/signaling */ "webpack/sharing/consume/default/@lumino/signaling");
/* harmony import */ var _lumino_signaling__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lumino_signaling__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokens */ "./node_modules/@jupyterlite/server/lib/tokens.js");





/**
 * The service-worker broadcast channel id
 */
const SERVICE_WORKER_BROADCAST_CHANNEL_ID = '/sw-api.v1';
/**
 * The version of the app
 */
const VERSION = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.PageConfig.getOption('appVersion');
/**
 * Used to keep the service worker alive
 */
const SW_PING_ENDPOINT = '/api/service-worker-heartbeat';
/**
 * A class that manages the ServiceWorker registration and communication,
 * used for accessing the file system.
 */
class ServiceWorkerManager {
    /**
     * Construct a new ServiceWorkerManager.
     */
    constructor(options) {
        var _a;
        /**
         * Handle a message received on the BroadcastChannel
         *
         * Message data is `any` because it can either be a drive message of type `TDriveReqiest<T>`
         * or a stdin message of type `any` as ServiceWorkerManager passes it through to the
         * stdinHandler without understanding or altering it.
         */
        this._onBroadcastMessage = async (event) => {
            const { data, browsingContextId, pathname } = event.data;
            if (browsingContextId !== this._browsingContextId) {
                // Message is not meant for us
                return;
            }
            if (pathname.includes('/api/stdin/')) {
                this._onStdinMessage(pathname, data);
            }
            else {
                this._onDriveMessage(data);
            }
        };
        this._onDriveMessage = async (data) => {
            const response = await this._driveContentsProcessor.processDriveRequest(data);
            // pass the browsingContextId along so the Service Worker can identify the request
            this._broadcastChannel.postMessage({
                response,
                browsingContextId: this._browsingContextId,
            });
        };
        this._onStdinMessage = async (pathname, data) => {
            // Expecting pathname of the form '<optional something>/api/stdin/<suffix>' from which
            // suffix is used to identify which stdinHandler to call.
            // `data: any` because ServiceWorkerManager accepts any data and passes it through
            // to the stdinHandler without understanding or altering it.
            const suffix = pathname.slice(pathname.lastIndexOf('/') + 1);
            const stdinHandler = this._stdinHandlers.get(suffix);
            if (stdinHandler !== undefined) {
                const response = await stdinHandler(data);
                this._broadcastChannel.postMessage({
                    response,
                    browsingContextId: this._browsingContextId,
                });
            }
            else {
                console.warn(`No stdin handler registered for '${pathname}'`);
            }
        };
        this._registration = null;
        this._registrationChanged = new _lumino_signaling__WEBPACK_IMPORTED_MODULE_2__.Signal(this);
        this._ready = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.PromiseDelegate();
        this._stdinHandlers = new Map();
        const workerUrl = (_a = options.workerUrl) !== null && _a !== void 0 ? _a : _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.URLExt.join(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.PageConfig.getBaseUrl(), _tokens__WEBPACK_IMPORTED_MODULE_3__.WORKER_NAME);
        const fullWorkerUrl = new URL(workerUrl, window.location.href);
        const enableCache = _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_0__.PageConfig.getOption('enableServiceWorkerCache') || 'false';
        fullWorkerUrl.searchParams.set('enableCache', enableCache);
        // Initialize broadcast channel related properties
        this._browsingContextId = _lumino_coreutils__WEBPACK_IMPORTED_MODULE_1__.UUID.uuid4();
        this._contents = options.contents;
        this._broadcastChannel = new BroadcastChannel(SERVICE_WORKER_BROADCAST_CHANNEL_ID);
        this._broadcastChannel.addEventListener('message', this._onBroadcastMessage);
        this._driveContentsProcessor = new _jupyterlite_contents__WEBPACK_IMPORTED_MODULE_4__.DriveContentsProcessor({
            contentsManager: this._contents,
        });
        void this._initialize(fullWorkerUrl.href).catch(console.warn);
    }
    /**
     * A signal emitted when the registration changes.
     */
    get registrationChanged() {
        return this._registrationChanged;
    }
    /**
     * Whether the ServiceWorker is enabled or not.
     */
    get enabled() {
        return this._registration !== null;
    }
    /**
     * A unique id to identify the browsing context where the ServiceWorkerManager was instantiated.
     */
    get browsingContextId() {
        return this._browsingContextId;
    }
    /**
     * Whether the ServiceWorker is ready or not.
     */
    get ready() {
        return this._ready.promise;
    }
    /**
     * Register a handler for stdin requests received via ServiceWorker.
     * @param pathnameSuffix URL pathname suffix to match such as "kernel" or "terminal".
     * @param stdinHandler
     */
    registerStdinHandler(pathnameSuffix, stdinHandler) {
        this._stdinHandlers.set(pathnameSuffix, stdinHandler);
    }
    /**
     * Initialize the ServiceWorkerManager.
     */
    async _initialize(workerUrl) {
        const { serviceWorker } = navigator;
        let registration = null;
        if (!serviceWorker) {
            console.warn('ServiceWorkers not supported in this browser');
            return;
        }
        else if (serviceWorker.controller) {
            const scriptURL = serviceWorker.controller.scriptURL;
            await this._unregisterOldServiceWorkers(scriptURL);
            registration = (await serviceWorker.getRegistration(scriptURL)) || null;
            // eslint-disable-next-line no-console
            console.info('JupyterLite ServiceWorker was already registered');
        }
        if (!registration && serviceWorker) {
            try {
                // eslint-disable-next-line no-console
                console.info('Registering new JupyterLite ServiceWorker', workerUrl);
                registration = await serviceWorker.register(workerUrl);
                // eslint-disable-next-line no-console
                console.info('JupyterLite ServiceWorker was sucessfully registered');
            }
            catch (err) {
                console.warn(err);
                console.warn(`JupyterLite ServiceWorker registration unexpectedly failed: ${err}`);
            }
        }
        this._setRegistration(registration);
        if (!registration) {
            this._ready.reject(void 0);
        }
        else {
            this._ready.resolve(void 0);
            setTimeout(this._pingServiceWorker, 20000);
        }
    }
    /**
     * Unregister old service workers if the version has changed.
     */
    async _unregisterOldServiceWorkers(scriptURL) {
        const versionKey = `${scriptURL}-version`;
        // Check if we have an installed version. If we do, compare it to the current version
        // and unregister all service workers if they are different.
        const installedVersion = localStorage.getItem(versionKey);
        if ((installedVersion && installedVersion !== VERSION) || !installedVersion) {
            // eslint-disable-next-line no-console
            console.info('New version, unregistering existing service workers.');
            const registrations = await navigator.serviceWorker.getRegistrations();
            await Promise.all(registrations.map((registration) => registration.unregister()));
            // eslint-disable-next-line no-console
            console.info('All existing service workers have been unregistered.');
        }
        localStorage.setItem(versionKey, VERSION);
    }
    /**
     * Ping the service worker to keep it alive.
     */
    async _pingServiceWorker() {
        const response = await fetch(SW_PING_ENDPOINT);
        const text = await response.text();
        if (text === 'ok') {
            setTimeout(this._pingServiceWorker, 20000);
        }
    }
    /**
     * Set the registration and emit a signal.
     */
    _setRegistration(registration) {
        this._registration = registration;
        this._registrationChanged.emit(this._registration);
    }
}


/***/ }),

/***/ "./node_modules/@jupyterlite/server/lib/service-worker.js?text":
/*!*********************************************************************!*\
  !*** ./node_modules/@jupyterlite/server/lib/service-worker.js?text ***!
  \*********************************************************************/
/***/ (() => {


/**
 * The name of the cache
 */
const CACHE = 'precache';
/**
 * Communication channel with the main thread
 */
const broadcast = new BroadcastChannel('/sw-api.v1');
/**
 * Whether to enable the cache
 */
let enableCache = false;
/**
 * Install event listeners
 */
self.addEventListener('install', onInstall);
self.addEventListener('activate', onActivate);
self.addEventListener('fetch', onFetch);
// Event handlers
/**
 * Handle installation with the cache
 */
function onInstall(event) {
    void self.skipWaiting();
    event.waitUntil(cacheAll());
}
/**
 * Handle activation.
 */
function onActivate(event) {
    // check if we should enable the cache
    const searchParams = new URL(location.href).searchParams;
    enableCache = searchParams.get('enableCache') === 'true';
    event.waitUntil(self.clients.claim());
}
/**
 * Handle fetching a single resource.
 */
async function onFetch(event) {
    const { request } = event;
    const url = new URL(event.request.url);
    if (url.pathname === '/api/service-worker-heartbeat') {
        event.respondWith(new Response('ok'));
        return;
    }
    let responsePromise = null;
    if (shouldBroadcast(url)) {
        responsePromise = broadcastOne(request, url);
    }
    else if (!shouldDrop(request, url)) {
        responsePromise = maybeFromCache(event);
    }
    if (responsePromise) {
        event.respondWith(responsePromise);
    }
}
// utilities
/** Get a cached response, and update cache. */
async function maybeFromCache(event) {
    const { request } = event;
    if (!enableCache) {
        return await fetch(request);
    }
    let response = await fromCache(request);
    if (response) {
        event.waitUntil(refetch(request));
    }
    else {
        response = await fetch(request);
        event.waitUntil(updateCache(request, response.clone()));
    }
    return response;
}
/**
 * Restore a response from the cache based on the request.
 */
async function fromCache(request) {
    const cache = await openCache();
    const response = await cache.match(request);
    if (!response || response.status === 404) {
        return null;
    }
    return response;
}
/**
 * This is where we call the server to get the newest version of the
 * file to use the next time we show view
 */
async function refetch(request) {
    const fromServer = await fetch(request);
    await updateCache(request, fromServer);
    return fromServer;
}
/**
 * Whether a given URL should be broadcast
 */
function shouldBroadcast(url) {
    return (url.origin === location.origin &&
        (url.pathname.includes('/api/drive') || url.pathname.includes('/api/stdin/')));
}
/**
 * Whether the fallback behavior should be used
 */
function shouldDrop(request, url) {
    return (request.method !== 'GET' ||
        url.origin.match(/^http/) === null ||
        url.pathname.includes('/api/'));
}
/**
 * Forward request to main using the broadcast channel
 */
async function broadcastOne(request, url) {
    const message = await request.json();
    const promise = new Promise((resolve) => {
        const messageHandler = (event) => {
            const data = event.data;
            if (data.browsingContextId !== message.browsingContextId) {
                // bail if the message is not for us
                return;
            }
            const response = data.response;
            resolve(new Response(JSON.stringify(response)));
            broadcast.removeEventListener('message', messageHandler);
        };
        broadcast.addEventListener('message', messageHandler);
    });
    // Add URL pathname to message
    message.pathname = url.pathname;
    broadcast.postMessage(message);
    return await promise;
}
async function openCache() {
    return await caches.open(CACHE);
}
/**
 * Cache a request/response pair.
 */
async function updateCache(request, response) {
    const cache = await openCache();
    return cache.put(request, response);
}
/**
 * Add all to the cache
 *
 * this is where we should (try to) add all relevant files
 */
async function cacheAll() {
    const cache = await openCache();
    return await cache.addAll([]);
}


/***/ }),

/***/ "./node_modules/@jupyterlite/server/lib/tokens.js":
/*!********************************************************!*\
  !*** ./node_modules/@jupyterlite/server/lib/tokens.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IServiceWorkerManager: () => (/* binding */ IServiceWorkerManager),
/* harmony export */   WORKER_NAME: () => (/* binding */ WORKER_NAME)
/* harmony export */ });
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ "webpack/sharing/consume/default/@lumino/coreutils");
/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _service_worker_text__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./service-worker?text */ "./node_modules/@jupyterlite/server/lib/service-worker.js?text");
/* harmony import */ var _service_worker_text__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_service_worker_text__WEBPACK_IMPORTED_MODULE_1__);


/**
 * The token for the ServiceWorker.
 */
const IServiceWorkerManager = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlite/server:IServiceWorkerManager');
const WORKER_NAME = `${(_service_worker_text__WEBPACK_IMPORTED_MODULE_1___default())}`.split('/').slice(-1)[0];


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_jupyterlite_server_lib_index_js.0e6adbc28c789d135661.js.map