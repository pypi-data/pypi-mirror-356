import pytest
from copychat.core import scan_directory, DiffMode
from copychat.format import format_files


def test_basic_scan(sample_project):
    """Test basic file scanning functionality."""
    files = scan_directory(
        sample_project,
        include=["py", "js", "css"],
    )

    # Check we found the expected file types
    extensions = {f.suffix.lstrip(".") for f in files}
    assert extensions == {"py", "js", "css"}

    # Check we found files in nested directories
    assert any("utils" in str(f) for f in files)
    assert any("styles" in str(f) for f in files)


def test_gitignore_handling(sample_project):
    """Test that .gitignore patterns are respected."""
    files = scan_directory(sample_project, include=["py", "env"])

    # These should be excluded by .gitignore
    paths = {str(f) for f in files}
    assert not any(f.endswith(".pyc") for f in paths)
    assert not any("__pycache__" in f for f in paths)
    assert not any(f.endswith(".env") for f in paths)


def test_formatting_output(sample_project):
    """Test that output is formatted correctly."""
    # Get files and format them
    files = scan_directory(sample_project, include=["py", "js"])
    format_result = format_files([(f, f.read_text()) for f in files])
    result = str(format_result)

    # Check for file content without line numbers
    assert "def main():" in result  # Remove the "1|" prefix
    assert 'print("Hello from main!")' in result
    assert "function App()" in result
    assert "def calculate_total" in result


def test_different_file_types(sample_project):
    """Test handling of different file types."""
    files = scan_directory(
        sample_project,
        include=["yml", "sql", "ts", "md"],
    )
    # Convert files to (path, content) tuples
    files_with_content = [(f, f.read_text()) for f in files]
    format_result = format_files(files_with_content)
    result = str(format_result)

    # Check various file types are properly formatted
    assert 'language="yaml"' in result
    assert 'language="sql"' in result
    assert 'language="typescript"' in result
    assert 'language="markdown"' in result

    # Check content snippets from each type
    assert "CREATE TABLE users" in result
    assert "interface User" in result
    assert "TestApp" in result
    assert "# Test Project" in result


def test_exclusion_patterns(sample_project):
    """Test explicit exclusion patterns."""
    files = scan_directory(
        sample_project,
        include=["py", "js"],
        exclude_patterns=["**/utils/*"],  # Exclude utils directory
    )

    paths = {str(f) for f in files}
    assert not any("utils" in p for p in paths)
    assert any("main.py" in p for p in paths)


def test_empty_directory(tmp_path):
    """Test handling of empty directories."""
    files = scan_directory(tmp_path)
    format_result = format_files([(f, f.read_text()) for f in list(files)])
    result = str(format_result)
    assert "No files found" in result


def test_header_metadata(sample_project):
    """Test header metadata in formatted output."""
    files = scan_directory(sample_project, include=["py"])
    # Convert files to (path, content) tuples
    files_with_content = [(f, f.read_text()) for f in files]
    format_result = format_files(files_with_content)
    result = str(format_result)

    # Check header contains important metadata
    assert "Generated by copychat on" in result
    assert "Root path:" in result
    assert "Summary:" in result  # Changed from Files:

    # Check file path info in header table format
    assert "Path" in result
    assert "Tokens" in result
    assert "Lines" in result
    # Paths will be in table rows instead of list format


@pytest.mark.parametrize(
    "diff_mode",
    [
        DiffMode.FULL,
        DiffMode.FULL_WITH_DIFF,
        # Removing these modes for now as they require git setup
        # DiffMode.CHANGED_WITH_DIFF,
        # DiffMode.DIFF_ONLY,
    ],
)
def test_diff_modes(sample_project, diff_mode):
    """Test different diff modes."""
    files = scan_directory(
        sample_project,
        include=["py"],
        diff_mode=diff_mode,
    )
    assert len(files) > 0


def test_token_estimation(sample_project):
    """Test token estimation functionality."""
    files = scan_directory(sample_project, include=["py", "js"])
    # Convert files to (path, content) tuples
    files_with_content = [(f, f.read_text()) for f in files]
    format_result = format_files(files_with_content)
    result = str(format_result)

    # Result should include token info in header
    assert "tokens" in result.lower()

    # Basic sanity check - content should be non-empty
    assert len(result) > 0


def test_error_handling(sample_project, tmp_path):
    """Test error handling for problematic files."""
    try:
        # Create an unreadable file in the temporary directory
        bad_file = tmp_path / "bad.py"
        bad_file.write_text("def bad():\n    pass\n")
        bad_file.chmod(0o000)  # Remove read permissions

        # Include both the sample project and the tmp directory
        files = scan_directory(sample_project, include=["py"])
        files = list(files)
        files.append(bad_file)

        # Convert files to (path, content) tuples, handling potential read errors
        files_with_content = []
        for f in files:
            try:
                content = f.read_text()
                files_with_content.append((f, content))
            except (PermissionError, OSError):
                # Still include the file, but with empty content
                files_with_content.append((f, ""))

        format_result = format_files(files_with_content)
        result = str(format_result)

        # Check that the bad file is mentioned in the result
        assert "bad.py" in result

        # Should still process good files
        assert "main.py" in result
        assert "def main():" in result
    finally:
        # Cleanup
        try:
            bad_file.chmod(0o666)
            bad_file.unlink()
        except Exception:
            pass
