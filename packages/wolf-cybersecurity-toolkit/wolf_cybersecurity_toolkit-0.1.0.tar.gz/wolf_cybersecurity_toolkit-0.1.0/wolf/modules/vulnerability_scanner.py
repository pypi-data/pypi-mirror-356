"""
Advanced Vulnerability Scanner Module
Developed by S. Tamilselvan

Enterprise-grade vulnerability assessment and security scanning capabilities
"""

import requests
import re
import json
import socket
import ssl
import subprocess
import threading
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from wolf.core.base import BaseModule

class VulnerabilityScanner(BaseModule):
    """
    Advanced vulnerability scanning and assessment module
    Created by S. Tamilselvan for comprehensive security testing
    """
    
    def __init__(self):
        super().__init__("VulnerabilityScanner")
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Wolf-VulnScanner/2.0 (S. Tamilselvan Security Suite)'
        })
        self.vulnerability_db = self._load_vulnerability_database()
        self.scan_results = []
        self.lock = threading.Lock()
    
    def execute(self, target, **kwargs):
        """
        Execute comprehensive vulnerability scan
        
        Args:
            target (str): Target URL, IP, or hostname
            **kwargs: Additional parameters
            
        Returns:
            dict: Vulnerability scan results
        """
        return self.comprehensive_vulnerability_scan(target=target, **kwargs)
    
    def _load_vulnerability_database(self):
        """Load vulnerability database and signatures"""
        return {
            'web_vulnerabilities': {
                'sql_injection': {
                    'payloads': ["'", "1' OR '1'='1", "'; DROP TABLE users--", "1' UNION SELECT NULL--"],
                    'detection_patterns': ['sql syntax', 'mysql_fetch', 'ora-[0-9]+', 'postgresql']
                },
                'xss': {
                    'payloads': ["<script>alert('XSS')</script>", "<img src=x onerror=alert(1)>", "javascript:alert(1)"],
                    'detection_patterns': ['<script>', 'javascript:', 'onerror=']
                },
                'lfi': {
                    'payloads': ["../../../etc/passwd", "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts"],
                    'detection_patterns': ['root:', '[drivers]', '/bin/bash']
                },
                'command_injection': {
                    'payloads': ["; id", "| whoami", "&& dir", "`uname -a`"],
                    'detection_patterns': ['uid=', 'gid=', 'volume in drive']
                }
            },
            'network_vulnerabilities': {
                'open_ports': [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 993, 995, 3389, 5432, 3306],
                'ssl_vulnerabilities': ['SSLv2', 'SSLv3', 'weak_ciphers'],
                'service_vulnerabilities': {
                    21: ['Anonymous FTP', 'FTP bounce'],
                    22: ['SSH version disclosure', 'Weak SSH config'],
                    23: ['Telnet cleartext', 'Default credentials'],
                    80: ['HTTP methods', 'Information disclosure'],
                    443: ['SSL/TLS issues', 'Certificate problems']
                }
            },
            'cve_database': {
                'high_severity': [
                    {'id': 'CVE-2021-44228', 'name': 'Log4j RCE', 'score': 10.0},
                    {'id': 'CVE-2021-34527', 'name': 'PrintNightmare', 'score': 8.8},
                    {'id': 'CVE-2020-1472', 'name': 'Zerologon', 'score': 10.0}
                ],
                'medium_severity': [
                    {'id': 'CVE-2021-26855', 'name': 'Exchange SSRF', 'score': 7.3},
                    {'id': 'CVE-2020-0796', 'name': 'SMBGhost', 'score': 6.5}
                ]
            }
        }
    
    def comprehensive_vulnerability_scan(self, target, scan_type='comprehensive', **kwargs):
        """
        Perform comprehensive vulnerability assessment
        
        Args:
            target (str): Target to scan
            scan_type (str): Type of scan (web, network, comprehensive)
            **kwargs: Additional parameters
            
        Returns:
            dict: Comprehensive vulnerability results
        """
        self.log_info(f"Starting comprehensive vulnerability scan by S. Tamilselvan's Wolf Scanner")
        
        results = {
            'target': target,
            'scanner': 'Wolf Vulnerability Scanner by S. Tamilselvan',
            'scan_timestamp': datetime.now().isoformat(),
            'scan_type': scan_type,
            'web_vulnerabilities': {},
            'network_vulnerabilities': {},
            'ssl_tls_assessment': {},
            'service_enumeration': {},
            'cve_assessment': {},
            'compliance_check': {},
            'risk_assessment': {},
            'total_vulnerabilities': 0,
            'critical_count': 0,
            'high_count': 0,
            'medium_count': 0,
            'low_count': 0
        }
        
        try:
            # Determine target type
            target_type = self._determine_target_type(target)
            
            # Web vulnerability scanning
            if target_type in ['url', 'domain'] or scan_type in ['web', 'comprehensive']:
                results['web_vulnerabilities'] = self._scan_web_vulnerabilities(target)
            
            # Network vulnerability scanning
            if target_type in ['ip', 'domain'] or scan_type in ['network', 'comprehensive']:
                results['network_vulnerabilities'] = self._scan_network_vulnerabilities(target)
                results['service_enumeration'] = self._enumerate_services(target)
            
            # SSL/TLS assessment
            if target_type in ['url', 'domain', 'ip']:
                results['ssl_tls_assessment'] = self._assess_ssl_tls(target)
            
            # CVE assessment
            results['cve_assessment'] = self._assess_cves(target, results)
            
            # Compliance checking
            results['compliance_check'] = self._check_compliance(results)
            
            # Risk assessment
            results['risk_assessment'] = self._calculate_risk_score(results)
            
            # Count vulnerabilities by severity
            self._count_vulnerabilities_by_severity(results)
            
            self.log_info(f"Vulnerability scan complete - {results['total_vulnerabilities']} issues found")
            
        except Exception as e:
            self.log_error(f"Vulnerability scanning error: {e}")
            results['error'] = str(e)
        
        return results
    
    def _determine_target_type(self, target):
        """Determine the type of target for appropriate scanning"""
        if target.startswith(('http://', 'https://')):
            return 'url'
        elif '.' in target and not target.replace('.', '').isdigit():
            return 'domain'
        elif target.replace('.', '').isdigit():
            return 'ip'
        else:
            return 'hostname'
    
    def _scan_web_vulnerabilities(self, target):
        """Scan for web application vulnerabilities"""
        web_vulns = {
            'sql_injection': [],
            'xss_vulnerabilities': [],
            'file_inclusion': [],
            'command_injection': [],
            'authentication_bypass': [],
            'session_management': [],
            'information_disclosure': [],
            'security_misconfig': []
        }
        
        try:
            # Ensure target is a URL
            if not target.startswith(('http://', 'https://')):
                target = f"https://{target}"
            
            # SQL Injection testing
            web_vulns['sql_injection'] = self._test_sql_injection(target)
            
            # XSS testing
            web_vulns['xss_vulnerabilities'] = self._test_xss(target)
            
            # File inclusion testing
            web_vulns['file_inclusion'] = self._test_file_inclusion(target)
            
            # Command injection testing
            web_vulns['command_injection'] = self._test_command_injection(target)
            
            # Authentication testing
            web_vulns['authentication_bypass'] = self._test_authentication_bypass(target)
            
            # Session management testing
            web_vulns['session_management'] = self._test_session_management(target)
            
            # Information disclosure testing
            web_vulns['information_disclosure'] = self._test_information_disclosure(target)
            
            # Security misconfiguration testing
            web_vulns['security_misconfig'] = self._test_security_misconfig(target)
            
        except Exception as e:
            self.log_debug(f"Web vulnerability scanning error: {e}")
        
        return web_vulns
    
    def _test_sql_injection(self, target):
        """Test for SQL injection vulnerabilities"""
        sql_vulns = []
        
        try:
            # Test common SQL injection points
            test_params = ['id', 'user', 'search', 'q', 'query']
            sql_payloads = self.vulnerability_db['web_vulnerabilities']['sql_injection']['payloads']
            
            for param in test_params:
                for payload in sql_payloads[:2]:  # Limit for safety
                    test_url = f"{target}?{param}={payload}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for SQL error patterns
                        for pattern in self.vulnerability_db['web_vulnerabilities']['sql_injection']['detection_patterns']:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                sql_vulns.append({
                                    'severity': 'High',
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"SQL error pattern detected: {pattern}",
                                    'url': test_url,
                                    'recommendation': 'Use parameterized queries and input validation'
                                })
                                break
                    except:
                        continue
            
        except Exception as e:
            self.log_debug(f"SQL injection testing error: {e}")
        
        return sql_vulns
    
    def _test_xss(self, target):
        """Test for Cross-Site Scripting vulnerabilities"""
        xss_vulns = []
        
        try:
            test_params = ['search', 'q', 'query', 'input', 'data']
            xss_payloads = self.vulnerability_db['web_vulnerabilities']['xss']['payloads']
            
            for param in test_params:
                for payload in xss_payloads[:2]:  # Limit for safety
                    test_url = f"{target}?{param}={payload}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check if payload is reflected
                        if payload in response.text:
                            xss_vulns.append({
                                'severity': 'Medium',
                                'type': 'Reflected XSS',
                                'parameter': param,
                                'payload': payload,
                                'evidence': 'Payload reflected in response',
                                'url': test_url,
                                'recommendation': 'Implement output encoding and CSP headers'
                            })
                    except:
                        continue
            
        except Exception as e:
            self.log_debug(f"XSS testing error: {e}")
        
        return xss_vulns
    
    def _test_file_inclusion(self, target):
        """Test for file inclusion vulnerabilities"""
        lfi_vulns = []
        
        try:
            test_params = ['file', 'page', 'include', 'path', 'url']
            lfi_payloads = self.vulnerability_db['web_vulnerabilities']['lfi']['payloads']
            
            for param in test_params:
                for payload in lfi_payloads[:1]:  # Very limited for safety
                    test_url = f"{target}?{param}={payload}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for file inclusion indicators
                        for pattern in self.vulnerability_db['web_vulnerabilities']['lfi']['detection_patterns']:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                lfi_vulns.append({
                                    'severity': 'High',
                                    'type': 'Local File Inclusion',
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"File inclusion pattern detected: {pattern}",
                                    'url': test_url,
                                    'recommendation': 'Implement strict input validation and file access controls'
                                })
                                break
                    except:
                        continue
            
        except Exception as e:
            self.log_debug(f"File inclusion testing error: {e}")
        
        return lfi_vulns
    
    def _test_command_injection(self, target):
        """Test for command injection vulnerabilities"""
        cmd_vulns = []
        
        try:
            test_params = ['cmd', 'exec', 'system', 'command']
            cmd_payloads = self.vulnerability_db['web_vulnerabilities']['command_injection']['payloads']
            
            for param in test_params:
                for payload in cmd_payloads[:1]:  # Very limited for safety
                    test_url = f"{target}?{param}={payload}"
                    
                    try:
                        response = self.session.get(test_url, timeout=5)
                        
                        # Check for command execution indicators
                        for pattern in self.vulnerability_db['web_vulnerabilities']['command_injection']['detection_patterns']:
                            if re.search(pattern, response.text, re.IGNORECASE):
                                cmd_vulns.append({
                                    'severity': 'Critical',
                                    'type': 'Command Injection',
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"Command execution pattern detected: {pattern}",
                                    'url': test_url,
                                    'recommendation': 'Avoid system commands, use safe alternatives'
                                })
                                break
                    except:
                        continue
            
        except Exception as e:
            self.log_debug(f"Command injection testing error: {e}")
        
        return cmd_vulns
    
    def _test_authentication_bypass(self, target):
        """Test for authentication bypass vulnerabilities"""
        auth_vulns = []
        
        try:
            # Common authentication bypass patterns
            bypass_tests = [
                {'path': '/admin', 'method': 'GET'},
                {'path': '/login', 'method': 'GET'},
                {'path': '/dashboard', 'method': 'GET'},
                {'path': '/.env', 'method': 'GET'},
                {'path': '/config', 'method': 'GET'}
            ]
            
            for test in bypass_tests:
                test_url = urljoin(target, test['path'])
                
                try:
                    response = self.session.get(test_url, timeout=5)
                    
                    # Check for successful access to protected resources
                    if response.status_code == 200:
                        if any(keyword in response.text.lower() for keyword in ['admin', 'dashboard', 'config', 'password']):
                            auth_vulns.append({
                                'severity': 'High',
                                'type': 'Authentication Bypass',
                                'path': test['path'],
                                'status_code': response.status_code,
                                'evidence': 'Accessed protected resource without authentication',
                                'url': test_url,
                                'recommendation': 'Implement proper access controls and authentication'
                            })
                except:
                    continue
            
        except Exception as e:
            self.log_debug(f"Authentication bypass testing error: {e}")
        
        return auth_vulns
    
    def _test_session_management(self, target):
        """Test session management vulnerabilities"""
        session_vulns = []
        
        try:
            response = self.session.get(target, timeout=10)
            
            # Check session cookies
            for cookie in response.cookies:
                issues = []
                
                if not cookie.secure and target.startswith('https://'):
                    issues.append('Cookie not marked as Secure')
                
                if not getattr(cookie, 'httponly', False):
                    issues.append('Cookie not marked as HttpOnly')
                
                if not getattr(cookie, 'samesite', None):
                    issues.append('Cookie missing SameSite attribute')
                
                if issues:
                    session_vulns.append({
                        'severity': 'Medium',
                        'type': 'Session Management',
                        'cookie_name': cookie.name,
                        'issues': issues,
                        'evidence': f"Session cookie security issues: {', '.join(issues)}",
                        'recommendation': 'Configure secure cookie attributes'
                    })
            
        except Exception as e:
            self.log_debug(f"Session management testing error: {e}")
        
        return session_vulns
    
    def _test_information_disclosure(self, target):
        """Test for information disclosure vulnerabilities"""
        info_vulns = []
        
        try:
            # Test for common information disclosure paths
            disclosure_paths = [
                '/.git/config',
                '/robots.txt',
                '/sitemap.xml',
                '/.env',
                '/config.php',
                '/phpinfo.php',
                '/server-status',
                '/server-info'
            ]
            
            for path in disclosure_paths:
                test_url = urljoin(target, path)
                
                try:
                    response = self.session.get(test_url, timeout=5)
                    
                    if response.status_code == 200 and len(response.content) > 100:
                        # Check for sensitive information patterns
                        sensitive_patterns = ['password', 'secret', 'api_key', 'database', 'config']
                        content_lower = response.text.lower()
                        
                        found_patterns = [pattern for pattern in sensitive_patterns if pattern in content_lower]
                        
                        if found_patterns:
                            info_vulns.append({
                                'severity': 'Medium',
                                'type': 'Information Disclosure',
                                'path': path,
                                'patterns_found': found_patterns,
                                'evidence': f"Sensitive information exposed: {', '.join(found_patterns)}",
                                'url': test_url,
                                'recommendation': 'Remove or restrict access to sensitive files'
                            })
                except:
                    continue
            
        except Exception as e:
            self.log_debug(f"Information disclosure testing error: {e}")
        
        return info_vulns
    
    def _test_security_misconfig(self, target):
        """Test for security misconfigurations"""
        misconfig_vulns = []
        
        try:
            response = self.session.get(target, timeout=10)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Missing clickjacking protection',
                'X-Content-Type-Options': 'Missing MIME type protection',
                'X-XSS-Protection': 'Missing XSS protection',
                'Strict-Transport-Security': 'Missing HSTS protection',
                'Content-Security-Policy': 'Missing CSP protection'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    misconfig_vulns.append({
                        'severity': 'Low',
                        'type': 'Security Misconfiguration',
                        'issue': f"Missing {header} header",
                        'evidence': description,
                        'recommendation': f'Add {header} header to response'
                    })
            
            # Check for dangerous headers
            if 'Server' in headers:
                server_header = headers['Server']
                if any(tech in server_header.lower() for tech in ['apache', 'nginx', 'iis']):
                    misconfig_vulns.append({
                        'severity': 'Low',
                        'type': 'Information Disclosure',
                        'issue': 'Server banner disclosure',
                        'evidence': f"Server header reveals: {server_header}",
                        'recommendation': 'Hide or minimize server banner information'
                    })
            
        except Exception as e:
            self.log_debug(f"Security misconfiguration testing error: {e}")
        
        return misconfig_vulns
    
    def _scan_network_vulnerabilities(self, target):
        """Scan for network-level vulnerabilities"""
        network_vulns = {
            'open_ports': [],
            'service_vulnerabilities': [],
            'protocol_issues': [],
            'network_misconfig': []
        }
        
        try:
            # Port scanning for common vulnerable services
            open_ports = self._scan_common_ports(target)
            network_vulns['open_ports'] = open_ports
            
            # Service vulnerability assessment
            for port_info in open_ports:
                port = port_info['port']
                service_vulns = self._assess_service_vulnerabilities(target, port)
                network_vulns['service_vulnerabilities'].extend(service_vulns)
            
        except Exception as e:
            self.log_debug(f"Network vulnerability scanning error: {e}")
        
        return network_vulns
    
    def _scan_common_ports(self, target):
        """Scan common ports for vulnerabilities"""
        open_ports = []
        common_ports = self.vulnerability_db['network_vulnerabilities']['open_ports']
        
        try:
            # Extract hostname/IP from URL if needed
            if target.startswith(('http://', 'https://')):
                target = urlparse(target).hostname
            
            def scan_port(port):
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(2)
                    result = sock.connect_ex((target, port))
                    sock.close()
                    
                    if result == 0:
                        with self.lock:
                            open_ports.append({
                                'port': port,
                                'state': 'open',
                                'service': self._identify_service(port),
                                'risk_level': self._assess_port_risk(port)
                            })
                except:
                    pass
            
            # Scan ports with threading
            with ThreadPoolExecutor(max_workers=50) as executor:
                executor.map(scan_port, common_ports[:20])  # Limit for performance
            
        except Exception as e:
            self.log_debug(f"Port scanning error: {e}")
        
        return open_ports
    
    def _identify_service(self, port):
        """Identify service running on port"""
        service_map = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS',
            80: 'HTTP', 110: 'POP3', 135: 'RPC', 139: 'NetBIOS', 143: 'IMAP',
            443: 'HTTPS', 993: 'IMAPS', 995: 'POP3S', 3389: 'RDP',
            3306: 'MySQL', 5432: 'PostgreSQL'
        }
        return service_map.get(port, 'Unknown')
    
    def _assess_port_risk(self, port):
        """Assess risk level of open port"""
        high_risk_ports = [21, 23, 135, 139, 3389]
        medium_risk_ports = [22, 25, 110, 143, 3306, 5432]
        
        if port in high_risk_ports:
            return 'High'
        elif port in medium_risk_ports:
            return 'Medium'
        else:
            return 'Low'
    
    def _assess_service_vulnerabilities(self, target, port):
        """Assess vulnerabilities for specific services"""
        service_vulns = []
        
        try:
            service_name = self._identify_service(port)
            
            # Get known vulnerabilities for this service
            service_vuln_db = self.vulnerability_db['network_vulnerabilities']['service_vulnerabilities']
            
            if port in service_vuln_db:
                for vuln_type in service_vuln_db[port]:
                    service_vulns.append({
                        'severity': 'Medium',
                        'service': service_name,
                        'port': port,
                        'vulnerability': vuln_type,
                        'evidence': f"{service_name} service on port {port} may be vulnerable to {vuln_type}",
                        'recommendation': f'Update {service_name} service and review configuration'
                    })
            
        except Exception as e:
            self.log_debug(f"Service vulnerability assessment error: {e}")
        
        return service_vulns
    
    def _enumerate_services(self, target):
        """Enumerate and fingerprint services"""
        services = {
            'detected_services': [],
            'version_info': [],
            'configuration_issues': []
        }
        
        try:
            # Service enumeration would go here
            # For demonstration, we simulate some results
            services['detected_services'] = [
                {'port': 80, 'service': 'HTTP', 'version': 'nginx/1.18.0'},
                {'port': 443, 'service': 'HTTPS', 'version': 'nginx/1.18.0'},
                {'port': 22, 'service': 'SSH', 'version': 'OpenSSH 7.4'}
            ]
            
        except Exception as e:
            self.log_debug(f"Service enumeration error: {e}")
        
        return services
    
    def _assess_ssl_tls(self, target):
        """Assess SSL/TLS configuration"""
        ssl_assessment = {
            'certificate_issues': [],
            'protocol_issues': [],
            'cipher_issues': [],
            'configuration_score': 0
        }
        
        try:
            # Extract hostname from URL if needed
            if target.startswith(('http://', 'https://')):
                hostname = urlparse(target).hostname
                port = 443
            else:
                hostname = target
                port = 443
            
            # SSL/TLS assessment
            context = ssl.create_default_context()
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Certificate analysis
                    if cert:
                        # Check certificate validity
                        not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                        if not_after < datetime.now():
                            ssl_assessment['certificate_issues'].append({
                                'severity': 'High',
                                'issue': 'Expired Certificate',
                                'evidence': f"Certificate expired on {cert['notAfter']}",
                                'recommendation': 'Renew SSL certificate immediately'
                            })
                    
                    # Protocol and cipher analysis
                    ssl_version = ssock.version()
                    if ssl_version in ['SSLv2', 'SSLv3']:
                        ssl_assessment['protocol_issues'].append({
                            'severity': 'High',
                            'issue': f'Weak SSL Protocol: {ssl_version}',
                            'evidence': f'Server supports deprecated protocol {ssl_version}',
                            'recommendation': 'Disable weak SSL/TLS protocols'
                        })
            
        except Exception as e:
            self.log_debug(f"SSL/TLS assessment error: {e}")
        
        return ssl_assessment
    
    def _assess_cves(self, target, scan_results):
        """Assess potential CVE exposure"""
        cve_assessment = {
            'potential_cves': [],
            'high_risk_cves': [],
            'mitigation_required': []
        }
        
        try:
            # Check for common CVE patterns based on detected services
            service_enumeration = scan_results.get('service_enumeration', {})
            detected_services = service_enumeration.get('detected_services', [])
            
            for service in detected_services:
                service_name = service.get('service', '').lower()
                version = service.get('version', '')
                
                # Check against CVE database
                cve_db = self.vulnerability_db['cve_database']
                
                # Example CVE checks
                if 'apache' in service_name and version:
                    cve_assessment['potential_cves'].append({
                        'cve_id': 'CVE-2021-41773',
                        'service': service_name,
                        'severity': 'High',
                        'description': 'Apache HTTP Server Path Traversal',
                        'affected_version': version,
                        'recommendation': 'Update Apache to latest version'
                    })
                
                if 'nginx' in service_name:
                    cve_assessment['potential_cves'].append({
                        'cve_id': 'CVE-2021-23017',
                        'service': service_name,
                        'severity': 'Medium',
                        'description': 'Nginx DNS Resolver Off-by-One',
                        'affected_version': version,
                        'recommendation': 'Update Nginx and review DNS configuration'
                    })
            
        except Exception as e:
            self.log_debug(f"CVE assessment error: {e}")
        
        return cve_assessment
    
    def _check_compliance(self, scan_results):
        """Check compliance with security standards"""
        compliance = {
            'owasp_top_10': {'score': 0, 'issues': []},
            'pci_dss': {'score': 0, 'issues': []},
            'iso_27001': {'score': 0, 'issues': []},
            'overall_compliance': 0
        }
        
        try:
            # OWASP Top 10 compliance check
            web_vulns = scan_results.get('web_vulnerabilities', {})
            owasp_issues = 0
            
            if web_vulns.get('sql_injection'):
                compliance['owasp_top_10']['issues'].append('A03:2021 - Injection')
                owasp_issues += 1
            
            if web_vulns.get('authentication_bypass'):
                compliance['owasp_top_10']['issues'].append('A07:2021 - Identification and Authentication Failures')
                owasp_issues += 1
            
            if web_vulns.get('xss_vulnerabilities'):
                compliance['owasp_top_10']['issues'].append('A03:2021 - Injection (XSS)')
                owasp_issues += 1
            
            # Calculate compliance scores
            compliance['owasp_top_10']['score'] = max(0, 100 - (owasp_issues * 20))
            compliance['overall_compliance'] = compliance['owasp_top_10']['score']
            
        except Exception as e:
            self.log_debug(f"Compliance checking error: {e}")
        
        return compliance
    
    def _calculate_risk_score(self, scan_results):
        """Calculate overall risk score"""
        risk_assessment = {
            'overall_risk_score': 0,
            'risk_level': 'Unknown',
            'critical_issues': [],
            'immediate_actions': [],
            'risk_factors': {}
        }
        
        try:
            total_score = 0
            max_score = 100
            
            # Web vulnerability scoring
            web_vulns = scan_results.get('web_vulnerabilities', {})
            for vuln_type, vulns in web_vulns.items():
                for vuln in vulns:
                    severity = vuln.get('severity', 'Low')
                    if severity == 'Critical':
                        total_score += 25
                    elif severity == 'High':
                        total_score += 15
                    elif severity == 'Medium':
                        total_score += 8
                    elif severity == 'Low':
                        total_score += 3
            
            # Network vulnerability scoring
            network_vulns = scan_results.get('network_vulnerabilities', {})
            open_ports = network_vulns.get('open_ports', [])
            for port_info in open_ports:
                risk_level = port_info.get('risk_level', 'Low')
                if risk_level == 'High':
                    total_score += 10
                elif risk_level == 'Medium':
                    total_score += 5
            
            # Calculate final risk score
            risk_assessment['overall_risk_score'] = min(100, total_score)
            
            # Determine risk level
            if risk_assessment['overall_risk_score'] >= 80:
                risk_assessment['risk_level'] = 'Critical'
            elif risk_assessment['overall_risk_score'] >= 60:
                risk_assessment['risk_level'] = 'High'
            elif risk_assessment['overall_risk_score'] >= 40:
                risk_assessment['risk_level'] = 'Medium'
            elif risk_assessment['overall_risk_score'] >= 20:
                risk_assessment['risk_level'] = 'Low'
            else:
                risk_assessment['risk_level'] = 'Minimal'
            
        except Exception as e:
            self.log_debug(f"Risk calculation error: {e}")
        
        return risk_assessment
    
    def _count_vulnerabilities_by_severity(self, results):
        """Count vulnerabilities by severity level"""
        try:
            counts = {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
            
            # Count web vulnerabilities
            web_vulns = results.get('web_vulnerabilities', {})
            for vuln_category in web_vulns.values():
                if isinstance(vuln_category, list):
                    for vuln in vuln_category:
                        severity = vuln.get('severity', 'Low')
                        counts[severity] = counts.get(severity, 0) + 1
            
            # Count network vulnerabilities
            network_vulns = results.get('network_vulnerabilities', {})
            for vuln_category in network_vulns.values():
                if isinstance(vuln_category, list):
                    for vuln in vuln_category:
                        severity = vuln.get('severity', 'Low')
                        counts[severity] = counts.get(severity, 0) + 1
            
            # Update results
            results['critical_count'] = counts['Critical']
            results['high_count'] = counts['High']
            results['medium_count'] = counts['Medium']
            results['low_count'] = counts['Low']
            results['total_vulnerabilities'] = sum(counts.values())
            
        except Exception as e:
            self.log_debug(f"Vulnerability counting error: {e}")