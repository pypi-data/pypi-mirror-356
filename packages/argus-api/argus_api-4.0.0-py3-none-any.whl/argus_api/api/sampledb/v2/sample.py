"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def add_analysis(
    sha256: str,
    analysisResult: dict,
    analysisScore: int,
    customer: str,
    tlp: str,
    userAgent: dict,
    acl: str = None,
    executedWithInternetAccess: bool = None,
    possibleDetections: int = None,
    profile: str = None,
    tags: dict = None,
    triggeredDetections: dict = None,
    verdictStatusOverride: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Adds an analysis to a sample (INTERNAL)

    :param str sha256: Sha256 of sample to add analysis result to
    :param dict analysisResult:
    :param int analysisScore: The score for this analysis. The value is a score from \-1 to 100 and is an indication of how certain the analyzer is that the sample is malicious. A value of \-1 indicates no findings.
    :param str customer: The shortname or ID of customer the analysis belongs to
    :param str tlp: The TLP level of the analysis
    :param dict userAgent: The user agent used in add requests
    :param list acl: The shortname or IDs of users or groups that will be given explicit access
    :param bool executedWithInternetAccess: A boolean to indicate whether the analysis have been executed with internet access or not
    :param int possibleDetections: The maximum number of possible detections
    :param str profile: The execution profile of the worker
    :param list tags: The tags for the analysis
    :param list triggeredDetections: The triggered detections for this analysis
    :param str verdictStatusOverride: Can be set to signify that the worker posting the analysis result is 100\% certain that the sample is malicious or benign. The verdict engine will consider this field and use as an override for the verdict status. If there are contradicting overrides\, the verdict engine will set the verdict status to \'unknown\' instead
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis".format(sha256=sha256)
    headers = {}

    body = body or {}
    # Only send acl if the argument was provided, don't send null values
    if acl is not None:
        body.update({"acl": acl})
    # Only send analysisResult if the argument was provided, don't send null values
    if analysisResult is not None:
        body.update({"analysisResult": analysisResult})
    # Only send analysisScore if the argument was provided, don't send null values
    if analysisScore is not None:
        body.update({"analysisScore": analysisScore})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send executedWithInternetAccess if the argument was provided, don't send null values
    if executedWithInternetAccess is not None:
        body.update({"executedWithInternetAccess": executedWithInternetAccess})
    # Only send possibleDetections if the argument was provided, don't send null values
    if possibleDetections is not None:
        body.update({"possibleDetections": possibleDetections})
    # Only send profile if the argument was provided, don't send null values
    if profile is not None:
        body.update({"profile": profile})
    # Only send tags if the argument was provided, don't send null values
    if tags is not None:
        body.update({"tags": tags})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send triggeredDetections if the argument was provided, don't send null values
    if triggeredDetections is not None:
        body.update({"triggeredDetections": triggeredDetections})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send verdictStatusOverride if the argument was provided, don't send null values
    if verdictStatusOverride is not None:
        body.update({"verdictStatusOverride": verdictStatusOverride})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def add_link(
    sha256: str,
    reference: str,
    tlp: str,
    type: str,
    userAgent: dict,
    acl: str = None,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Adds an link to a sample (INTERNAL)

    :param str sha256: Sha256 of sample to add link to
    :param str reference: The ID of the sample the link references
    :param str tlp: The TLP level of the link
    :param str type: The nature of the link between the two samples
    :param dict userAgent: The user agent used in add requests
    :param list acl: The shortname or IDs of users or groups that will be given explicit access
    :param str customer: The shortname or ID of customer the link belongs to
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link".format(sha256=sha256)
    headers = {}

    body = body or {}
    # Only send acl if the argument was provided, don't send null values
    if acl is not None:
        body.update({"acl": acl})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send reference if the argument was provided, don't send null values
    if reference is not None:
        body.update({"reference": reference})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def add_sample(
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Upload a new sample file (INTERNAL)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample".format()
    headers = {}

    body = body or {}

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def add_static_fact(
    sha256: str,
    key: str,
    userAgent: dict,
    value: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Endpoint for registering a new static fact (DEV)

    :param str sha256: Sha256 of the sample to add the static fact to
    :param str key: The static fact key
    :param dict userAgent: The user agent used in add requests
    :param str value: The static fact value
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/fact".format(sha256=sha256)
    headers = {}

    body = body or {}
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        body.update({"key": key})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})
    # Only send value if the argument was provided, don't send null values
    if value is not None:
        body.update({"value": value})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def add_submission(
    sha256: str,
    challengeToken: dict,
    fileName: str,
    userAgent: dict,
    acl: str = None,
    customer: str = None,
    observedTimestamp: int = None,
    retention: str = None,
    metaData: dict = None,
    mimeType: str = "application/octet-stream",
    tlp: str = "amber",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add a new sample submission. Requires a challenge token. A challenge token is a solution to a challenge generated by the challenge endpoint (INTERNAL)

    :param str sha256: Sha256 of sample to add submission for
    :param dict challengeToken: Request containing the answer to a challenge
    :param str fileName: The filename of the sample
    :param dict userAgent: The user agent used in add requests
    :param list acl: List of user IDs or shortnames that are given explicit access to the submission
    :param str customer: The shortname or ID of customer the submission belongs to. Default value is the currernt user\'s customer
    :param int observedTimestamp: The timestamp of when the sample was observed. Defaults to the current time
    :param str retention: Only retain the submission until the specified time. The submission will be deleted after this time\, unless the sample is malicious. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/api\/general\_integration\_guide\/08\-time\_fields.html\#api\-iguide\-general\-time\-search  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param dict metaData: Meta data about the sample
    :param str mimeType: The sample mime type
    :param str tlp: TLP color of the submission. Submissions with TLP Red will be rejected as Sample Service does not support submissions with TLP redDefaults to amber
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/submission".format(sha256=sha256)
    headers = {}

    body = body or {}
    # Only send acl if the argument was provided, don't send null values
    if acl is not None:
        body.update({"acl": acl})
    # Only send challengeToken if the argument was provided, don't send null values
    if challengeToken is not None:
        body.update({"challengeToken": challengeToken})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send fileName if the argument was provided, don't send null values
    if fileName is not None:
        body.update({"fileName": fileName})
    # Only send metaData if the argument was provided, don't send null values
    if metaData is not None:
        body.update({"metaData": metaData})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send observedTimestamp if the argument was provided, don't send null values
    if observedTimestamp is not None:
        body.update({"observedTimestamp": observedTimestamp})
    # Only send retention if the argument was provided, don't send null values
    if retention is not None:
        body.update({"retention": retention})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send userAgent if the argument was provided, don't send null values
    if userAgent is not None:
        body.update({"userAgent": userAgent})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def add_verdict(
    sha256: str,
    comment: str,
    statusOverride: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Manually add a verdict to a sample (INTERNAL)

    :param str sha256:
    :param str comment: A comment providing information or context to the verdict
    :param str statusOverride: Field for manually overriding the status of the sample. If this field is set\, this overrides the future event generations and verdicts for this sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/verdict".format(sha256=sha256)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send statusOverride if the argument was provided, don't send null values
    if statusOverride is not None:
        body.update({"statusOverride": statusOverride})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def advanced_search(
    analysis: dict = None,
    classification: dict = None,
    customer: str = None,
    endTimestamp: str = None,
    fact: dict = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    keywords: str = None,
    link: dict = None,
    md5: str = None,
    sha1: str = None,
    sha256: str = None,
    sha512: str = None,
    startTimestamp: str = None,
    subCriteria: dict = None,
    submission: dict = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    tlp: str = None,
    user: str = None,
    userFieldStrategy: str = None,
    userMatchStrategy: str = None,
    verdict: dict = None,
    indexEndTimestamp: str = "now",
    indexStartTimestamp: str = "now - 1 month",
    limit: int = 25,
    offset: int = None,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Advanced search for samples (PUBLIC)

    :param list analysis: Search criteria for analysis
    :param list classification: Search criteria for classifications
    :param list customer: Restrict the search to samples containing submissions owned by certain customers
    :param str endTimestamp: Restrict the search to resources \(indicated by timeFieldStrategy\) timestamped before this timestamp.Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list fact: Search criteria for static facts
    :param list keywordFieldStrategy: Restrict to search only in the selected keyword fields
    :param str keywordMatchStrategy: Whether all or any \(default\) of the fields must match one or more of the keywords
    :param list keywords: A set of keywords to search for
    :param list link: Search criteria for links
    :param list md5: Restrict to search only in samples with these md5 hashes
    :param list sha1: Restrict to search only in samples with these sha1 hashes
    :param list sha256: Restrict to search only in the selected sample sha256 IDs
    :param list sha512: Restrict to search only in samples with these sha512 hashes
    :param str startTimestamp: Restrict the search to resources \(indicated by timeFieldStrategy\) timestamped after this timestamp. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list subCriteria: Search sub criteria
    :param list submission: Search criteria for submissions
    :param list timeFieldStrategy: Restrict the search by timestamp \(indicated by startTimestamp and endTimestamp\) to these fields. Default is \'all\'
    :param str timeMatchStrategy: Whether all or any \(default\) of the fields must match the time period \(indicated by startTimestamp and endTimestamp\)
    :param list tlp: Restrict the search to samples where the sample contains one or more submission\, analysis\, or link with any of the defined TLPs
    :param list user: Restrict the search to samples containing resources \(indicated by userFieldStrategy\) submitted by users
    :param list userFieldStrategy: Define what resources to apply the user criteria to. Defaults to \'all\'
    :param str userMatchStrategy:  Whether all or any \(default\) of the fields must match the user criteria
    :param list verdict: Search criteria for verdicts
    :param str indexEndTimestamp: Restrict search to data before this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str indexStartTimestamp: Restrict search to data after this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param int limit: Limit the number of search results
    :param int offset: Skip a number of search results
    :param list sortBy: Specify sort ordering for returned samples
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/search".format()
    headers = {}

    body = body or {}
    # Only send analysis if the argument was provided, don't send null values
    if analysis is not None:
        body.update({"analysis": analysis})
    # Only send classification if the argument was provided, don't send null values
    if classification is not None:
        body.update({"classification": classification})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send fact if the argument was provided, don't send null values
    if fact is not None:
        body.update({"fact": fact})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        body.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        body.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send link if the argument was provided, don't send null values
    if link is not None:
        body.update({"link": link})
    # Only send md5 if the argument was provided, don't send null values
    if md5 is not None:
        body.update({"md5": md5})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sha1 if the argument was provided, don't send null values
    if sha1 is not None:
        body.update({"sha1": sha1})
    # Only send sha256 if the argument was provided, don't send null values
    if sha256 is not None:
        body.update({"sha256": sha256})
    # Only send sha512 if the argument was provided, don't send null values
    if sha512 is not None:
        body.update({"sha512": sha512})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send submission if the argument was provided, don't send null values
    if submission is not None:
        body.update({"submission": submission})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send tlp if the argument was provided, don't send null values
    if tlp is not None:
        body.update({"tlp": tlp})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})
    # Only send verdict if the argument was provided, don't send null values
    if verdict is not None:
        body.update({"verdict": verdict})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def delete_sample(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete a sample and all of its resources including submissions, analyses, links, classifications, verdicts, and jobs async. A minimal metadata record will be left behind (DEV)

    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}".format(sha256=sha256)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def download_raw_sample(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Download a raw sample file. Warning: The file returned may be malicious. Take caution (INTERNAL)

    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/sampledb/v2/sample/{sha256}/raw".format(sha256=sha256)
    headers = {}
    headers["content"] = None

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def download_safe_sample(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Download a zipped sample file, password protected with the password "infected". Warning: The zipped file may be malicious. Take caution (INTERNAL)

    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/sampledb/v2/sample/{sha256}/safe".format(sha256=sha256)
    headers = {}
    headers["content"] = None

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_analysis(
    sha256: str,
    analysisID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches the analysis for the sample with the given ID (PUBLIC)

    :param str sha256: Sha256 of sample to fetch the analysis from
    :param str analysisID: ID of the analysis to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}".format(
        sha256=sha256, analysisID=analysisID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_analysis_summary(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Get a summary of all analysis results for a given sample (DEV)

    :param str sha256: Sha256 of sample to fetch the analysis summary from
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/summary".format(sha256=sha256)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_evidence(
    sha256: str,
    analysisID: str,
    evidenceID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches the evidence metadata for the analysis for the sample with the given ID (PUBLIC)

    :param str sha256: Sha256 of sample to fetch the analysis from
    :param str analysisID: ID of the analysis the evidence is for
    :param str evidenceID: ID of the evidence to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence/{evidenceID}".format(
        sha256=sha256, analysisID=analysisID, evidenceID=evidenceID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_evidence_data(
    sha256: str,
    analysisID: str,
    evidenceID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Returns the evidence file. (PUBLIC)

    :param str sha256: Sha256 of sample the analysis is from
    :param str analysisID: The ID of the analysis you want to fetch evidence from
    :param str evidenceID: The ID of the evidence data you want to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence/{evidenceID}/download".format(
        sha256=sha256, analysisID=analysisID, evidenceID=evidenceID
    )
    headers = {}
    headers["content"] = None

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_link(
    sha256: str,
    linkID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches the link for the sample with the given ID (PUBLIC)

    :param str sha256: Sha256 of sample to fetch the link from
    :param str linkID: ID of the link to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link/{linkID}".format(
        sha256=sha256, linkID=linkID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_link_summary(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Get a summary of up to 1000 links for a given sample (DEV)

    :param str sha256: Sha256 of the sample to fetch the links summary from
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link/summary".format(sha256=sha256)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_sample_meta_data(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch meta data about a sample file (PUBLIC)

    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}".format(sha256=sha256)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_submission(
    sha256: str,
    submissionID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch a submission for the sample with the given ID (PUBLIC)

    :param str sha256: Sha256 of the sample the submission belongs to
    :param str submissionID: The ID of the submission to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises TheSampleCouldNotBeFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/submission/{submissionID}".format(
        sha256=sha256, submissionID=submissionID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def get_upload_challenge(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Generate a new challenge for a sample. The solution of the challenge is SHA256(x) where x is 'length' bytes of data starting from 'offset' bytes into the sample file (INTERNAL)

    :param str sha256: Sha256 of sample to get submission challenge for
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises TheSampleCouldNotBeFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises TheSampleFileIsTooSmall.UploadTheFullSampleAndUseTheChallengeTokenReturnedInThatResponseAsProofException: on 422
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/challenge".format(sha256=sha256)
    headers = {}

    body = body or {}

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_analysis(
    sha256: str,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Lists the analysis for the sample (PUBLIC)

    :param str sha256: Sha256 of sample to fetch the analysis from
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis".format(sha256=sha256)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_classifications(
    sha256: str,
    limit: int = 25,
    offset: int = 0,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch all classifications for a sample (PUBLIC)

    :param str sha256: Sha256 of the sample
    :param int limit: The maximum number of classifications to return
    :param int offset: Skip a number of results
    :param list sortBy: The field on which to sort the classifications. Prefix with \'\-\' to sort descending
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/classification".format(sha256=sha256)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_evidence(
    sha256: str,
    analysisID: str,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Lists the evidence metadata for the analysis (PUBLIC)

    :param str sha256: Sha256 of sample the analysis is from
    :param str analysisID: The ID of the analysis you want to list evidence from
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence".format(
        sha256=sha256, analysisID=analysisID
    )
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_links(
    sha256: str,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Lists the links for the sample (PUBLIC)

    :param str sha256: Sha256 of sample to fetch the link from
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/link".format(sha256=sha256)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_static_fact(
    sha256: str,
    key: str = None,
    limit: int = 25,
    offset: int = 0,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Endpoint for listing the static facts for a sample (DEV)

    :param str sha256: Sha256 of the sample the static facts are for
    :param list key: A set of keys to search for
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param list sortBy: Sort order of returned results. Prefix with \'\-\' to sort descending
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/fact".format(sha256=sha256)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_submissions(
    sha256: str,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List all the submissions for a sample (PUBLIC)

    :param str sha256: Sha256 of the sample to fetch submissions for
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises TheSampleCouldNotBeFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/submission".format(sha256=sha256)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def list_verdicts(
    sha256: str,
    limit: int = 25,
    offset: int = 0,
    sortBy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List all verdicts for a sample (PUBLIC)

    :param str sha256: Sha256 of the sample to fetch verdicts for
    :param int limit: Maximum number of returned results
    :param int offset: Skip a number of results
    :param list sortBy: The field on which to sort the verdicts. Prefix any of the allowed values with \'\-\' to sort descending
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises NotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/verdict".format(sha256=sha256)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def reanalyse_sample(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Triggering reanalysis of a Sample without having to upload a new submission. (INTERNAL)

    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises AnErrorOccurredException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/reanalyse".format(sha256=sha256)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def reclassify_sample(
    sha256: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Manually reclassify an existing sample (INTERNAL)

    :param str sha256: Sha256 of the sample
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample/{sha256}/reclassify".format(sha256=sha256)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def simple_search(
    keywords: str = None,
    offset: int = 0,
    limit: int = 25,
    sortBy: str = None,
    indexStartTimestamp: str = "now - 1 month",
    indexEndTimestamp: str = "now",
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "any",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Simple search for samples (PUBLIC)

    :param list keywords: A set of keywords to search for
    :param int offset: Number of results to skip
    :param int limit: Maximum number of returned results
    :param list sortBy: The fields to sort the results by. Prefix with \'\-\' to sort descending
    :param str indexStartTimestamp: Restrict search to data after this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param str indexEndTimestamp: Restrict search to data before this time. Timestamps can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details
    :param list keywordFieldStrategy: Which fields to search on
    :param str keywordMatchStrategy: Whether the keywords must match all or any of the keyword fields
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/sampledb/v2/sample".format()
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    # Only send indexStartTimestamp if the argument was provided, don't send null values
    if indexStartTimestamp is not None:
        query_parameters.update({"indexStartTimestamp": indexStartTimestamp})
    # Only send indexEndTimestamp if the argument was provided, don't send null values
    if indexEndTimestamp is not None:
        query_parameters.update({"indexEndTimestamp": indexEndTimestamp})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("sampledb", "v2", "sample"), module=argus_cli_module)
def upload_evidence(
    sha256: str,
    analysisID: str,
    fileName: str,
    internal: bool = None,
    potentiallyMalicious: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Uploads an evidence file (INTERNAL)

    :param str sha256: Sha256 of sample that holds the analysis
    :param str analysisID: UUID of analysis to add evidence to
    :param str fileName: The name of the evidence file to upload \=\> \[a\-zA\-Z0\-9\_\:\\\-\\.\]\*
    :param bool internal: If the evidence is internal
    :param bool potentiallyMalicious: If the evidence is potentially malicious
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = (
        "/sampledb/v2/sample/{sha256}/analysis/{analysisID}/evidence/{fileName}".format(
            sha256=sha256, analysisID=analysisID, fileName=fileName
        )
    )
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send internal if the argument was provided, don't send null values
    if internal is not None:
        query_parameters.update({"internal": internal})
    # Only send potentiallyMalicious if the argument was provided, don't send null values
    if potentiallyMalicious is not None:
        query_parameters.update({"potentiallyMalicious": potentiallyMalicious})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
