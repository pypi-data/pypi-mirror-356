"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def bind_category(
    serviceID: str,
    caseTypes: str,
    category: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Bind category to service (PUBLIC)

    :param str serviceID: ID or shortname of service to bind category to
    :param list caseTypes: Case types to bind category for
    :param str category: Shortname or ID of category to bind
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{serviceID}/categories".format(serviceID=serviceID)
    headers = {}

    body = body or {}
    # Only send caseTypes if the argument was provided, don't send null values
    if caseTypes is not None:
        body.update({"caseTypes": caseTypes})
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def create_service(
    adminFunction: str,
    caseTypes: str,
    createFunction: str,
    defineFunction: str,
    description: str,
    domain: str,
    iconURL: str,
    name: str,
    notificationEmail: str,
    readFunction: str,
    shortName: str,
    techFunction: str,
    writeFunction: str,
    assignDefaultTech: bool = None,
    assignDefaultUser: bool = None,
    eventEnabled: bool = None,
    fieldPolicy: str = None,
    handledBySoc: bool = None,
    listFunction: str = None,
    localizedDescriptions: dict = None,
    localizedNames: dict = None,
    monitoredBySocOutsideOfficeHours: bool = None,
    notifyFullFormat: bool = None,
    notifyOnClose: bool = None,
    notifyOnCreate: bool = None,
    notifyOnUpdate: bool = None,
    workflows: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Define a new service (INTERNAL)

    :param str adminFunction: The name or ID of the function to set as ADMIN function for this service.
    :param list caseTypes: The case types to enable for this service.
    :param str createFunction: The name or ID of the function to set as CREATE function for this service.
    :param str defineFunction: The name or ID of the function to set as DEFINE function for this service.
    :param str description: Longer description of service.
    :param str domain: Name or ID of domain to bind service to.
    :param str iconURL: An image data\-URL on the form data\:image\/png\;base64\,BASE64IMAGEDATA
    :param str name: Descriptive name of service.
    :param str notificationEmail: The service notification email address. \[format\:email\]
    :param str readFunction: The name or ID of the function to set as READ function for this service.
    :param str shortName: Shortname of service. This must be unique within a domain.
    :param str techFunction: The name or ID of the function to set as TECH function for this service.
    :param str writeFunction: The name or ID of the function to set as WRITE function for this service.
    :param bool assignDefaultTech: If true\, cases created for this service will be automatically assign tech to the executing user \(if tech\).
    :param bool assignDefaultUser: If true\, cases created for this service will be automatically assign user to the executing user \(if not tech\).
    :param bool eventEnabled: If true\, this service is integrated with events.
    :param str fieldPolicy: The ID of a field policy to set for this service. Default is no policy.
    :param bool handledBySoc: If true\, this service is handled by SOC 24\/7. Default is false.
    :param str listFunction: The name or ID of the function to set as LIST function for this service. Default is the same as \'readFunction\'.
    :param dict localizedDescriptions: Localized descriptions. If not set\, locales will fallback to main description.
    :param dict localizedNames: Localized names. If not set\, locales will fallback to main name.
    :param bool monitoredBySocOutsideOfficeHours: If true\, this service is monitored by SOC outside office hours. Default is false.
    :param bool notifyFullFormat: If true\, use the full format when notifying to the service notification email. Default is false.
    :param bool notifyOnClose: If true\, notify the service notification email address on closed cases. Default is false.
    :param bool notifyOnCreate: If true\, notify the service notification email address on created cases. Default is false.
    :param bool notifyOnUpdate: If true\, notify the service notification email address on updated cases. Default is false.
    :param dict workflows: If set\, define workflows to enable for this service.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service".format()
    headers = {}

    body = body or {}
    # Only send adminFunction if the argument was provided, don't send null values
    if adminFunction is not None:
        body.update({"adminFunction": adminFunction})
    # Only send assignDefaultTech if the argument was provided, don't send null values
    if assignDefaultTech is not None:
        body.update({"assignDefaultTech": assignDefaultTech})
    # Only send assignDefaultUser if the argument was provided, don't send null values
    if assignDefaultUser is not None:
        body.update({"assignDefaultUser": assignDefaultUser})
    # Only send caseTypes if the argument was provided, don't send null values
    if caseTypes is not None:
        body.update({"caseTypes": caseTypes})
    # Only send createFunction if the argument was provided, don't send null values
    if createFunction is not None:
        body.update({"createFunction": createFunction})
    # Only send defineFunction if the argument was provided, don't send null values
    if defineFunction is not None:
        body.update({"defineFunction": defineFunction})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send eventEnabled if the argument was provided, don't send null values
    if eventEnabled is not None:
        body.update({"eventEnabled": eventEnabled})
    # Only send fieldPolicy if the argument was provided, don't send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})
    # Only send handledBySoc if the argument was provided, don't send null values
    if handledBySoc is not None:
        body.update({"handledBySoc": handledBySoc})
    # Only send iconURL if the argument was provided, don't send null values
    if iconURL is not None:
        body.update({"iconURL": iconURL})
    # Only send listFunction if the argument was provided, don't send null values
    if listFunction is not None:
        body.update({"listFunction": listFunction})
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send localizedNames if the argument was provided, don't send null values
    if localizedNames is not None:
        body.update({"localizedNames": localizedNames})
    # Only send monitoredBySocOutsideOfficeHours if the argument was provided, don't send null values
    if monitoredBySocOutsideOfficeHours is not None:
        body.update(
            {"monitoredBySocOutsideOfficeHours": monitoredBySocOutsideOfficeHours}
        )
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send notificationEmail if the argument was provided, don't send null values
    if notificationEmail is not None:
        body.update({"notificationEmail": notificationEmail})
    # Only send notifyFullFormat if the argument was provided, don't send null values
    if notifyFullFormat is not None:
        body.update({"notifyFullFormat": notifyFullFormat})
    # Only send notifyOnClose if the argument was provided, don't send null values
    if notifyOnClose is not None:
        body.update({"notifyOnClose": notifyOnClose})
    # Only send notifyOnCreate if the argument was provided, don't send null values
    if notifyOnCreate is not None:
        body.update({"notifyOnCreate": notifyOnCreate})
    # Only send notifyOnUpdate if the argument was provided, don't send null values
    if notifyOnUpdate is not None:
        body.update({"notifyOnUpdate": notifyOnUpdate})
    # Only send readFunction if the argument was provided, don't send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send techFunction if the argument was provided, don't send null values
    if techFunction is not None:
        body.update({"techFunction": techFunction})
    # Only send workflows if the argument was provided, don't send null values
    if workflows is not None:
        body.update({"workflows": workflows})
    # Only send writeFunction if the argument was provided, don't send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def delete_service(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete service (INTERNAL)

    :param str id: ID or shortname of service to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}".format(id=id)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def get_field_policy_by_service(
    service: str,
    customer: str = None,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch policy descriptor by service and customer (INTERNAL)

    :param str service: ID or shortname of service to fetch policy for
    :param str customer: ID or shortname of customer to fetch policy for
    :param str domain: Domain to lookup service and customer in \(when using shortnames\). Defaults to the current users domain.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{service}/fieldpolicy".format(service=service)
    headers = {}

    query_parameters = {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def get_service(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch service (INTERNAL)

    :param str id: ID or shortname of service
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}".format(id=id)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def get_service_logo(
    id: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Fetch service logo (INTERNAL)

    :param str id: ID or shortname of service
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/cases/v2/service/{id}/logo".format(id=id)
    headers = {}
    headers["content"] = None

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def list_categories_by_service(
    id: str,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List categories bound to service (PUBLIC)

    :param str id: ID or shortname of service
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}/categories".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def list_services(
    id: int = None,
    shortName: str = None,
    keywords: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List services (INTERNAL)

    :param list id: List of IDs to match
    :param list shortName: List of shortnames to match
    :param list keywords: Limit by matching keywords
    :param list sortBy: Sort order \(see \/cases\/v2\/service\/search documentation for details\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service".format()
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send id if the argument was provided, don't send null values
    if id is not None:
        query_parameters.update({"id": id})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        query_parameters.update({"shortName": shortName})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def search_services(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    id: int = None,
    shortName: str = None,
    fieldPolicy: str = None,
    keywords: str = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Search services (INTERNAL)

    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param list subCriteria: Set additional criterias which are applied using a logical OR.
    :param bool exclude: Only relevant for subcriteria. If set to true\, objects matching this subcriteria object will be excluded.
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param list id: Limit search to services with the specified numeric ID\`s.
    :param list shortName: Limit search to services with the specified shortnames
    :param list fieldPolicy: Limit search to services bound to specified field policies \(by UUID or name\)
    :param list keywords: Limit search to services matching the given keywords \(by name or shortname\)
    :param list sortBy: List of properties to sort by \(prefix with \"\-\" to sort descending\).
    :param list includeFlags: Only include objects which have includeFlags set.
    :param list excludeFlags: Exclude objects which have excludeFlags set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/search".format()
    headers = {}

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send id if the argument was provided, don't send null values
    if id is not None:
        body.update({"id": id})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send fieldPolicy if the argument was provided, don't send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def unbind_category(
    serviceID: str,
    categoryID: str,
    caseType: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Unbind category from service. If caseType is specified, only unbind specific casetype. Default is to unbind all casetypes, disallowing the category for use on this service. (PUBLIC)

    :param str serviceID: ID or shortname of service to unbind category from
    :param str categoryID: ID or shortname of category to unbind
    :param list caseType: Casetypes to unbind \(default is all\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{serviceID}/categories/{categoryID}".format(
        serviceID=serviceID, categoryID=categoryID
    )
    headers = {}

    query_parameters = {}
    # Only send caseType if the argument was provided, don't send null values
    if caseType is not None:
        query_parameters.update({"caseType": caseType})

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "service"), module=argus_cli_module)
def update_service(
    id: str,
    adminFunction: str = None,
    assignDefaultTech: bool = None,
    assignDefaultUser: bool = None,
    caseTypesToAdd: str = None,
    caseTypesToRemove: str = None,
    caseTypesToSet: str = None,
    createFunction: str = None,
    defineFunction: str = None,
    deprecated: bool = None,
    description: str = None,
    eventEnabled: bool = None,
    fieldPolicy: str = None,
    handledBySoc: bool = None,
    iconURL: str = None,
    listFunction: str = None,
    localizedDescriptions: dict = None,
    localizedNames: dict = None,
    monitoredBySocOutsideOfficeHours: bool = None,
    name: str = None,
    notificationEmail: str = None,
    notifyFullFormat: bool = None,
    notifyOnClose: bool = None,
    notifyOnCreate: bool = None,
    notifyOnUpdate: bool = None,
    readFunction: str = None,
    shortName: str = None,
    techFunction: str = None,
    workflows: dict = None,
    writeFunction: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update an existing service (INTERNAL)

    :param str id: Service id or shortname
    :param str adminFunction: If set\, change the ADMIN function for this service\, identified by function ID or shortname.
    :param bool assignDefaultTech: If set\, change whether cases created for this service will be automatically assign tech to the executing user \(if tech\).
    :param bool assignDefaultUser: If set\, change whether cases created for this service will be automatically assign user to the executing user \(if not tech\).
    :param list caseTypesToAdd: If set\, enable the requested case type for this service.
    :param list caseTypesToRemove: If set\, disable the requested case type for this service. This will be rejected if any non\-deleted cases exist which are bound to this service and casetype.
    :param list caseTypesToSet: If set\, override existing case types for this service. If this causes the service to remove a case type which has non\-deleted cases bound to it\, this will be rejected.
    :param str createFunction: If set\, change the CREATE function for this service\, identified by function ID or shortname.
    :param str defineFunction: If set\, change the DEFINE function for this service\, identified by function ID or shortname.
    :param bool deprecated: If set\, enable\/disable the deprecated flag for this service. Default is no change.
    :param str description: If set\, change the longer description of the service.
    :param bool eventEnabled: If set\, set whether service is integrated with events.
    :param str fieldPolicy: If set\, change the field policy for this service. Changing the field policy will affect new cases and future updates to existing cases\, but will not change fields set on existing cases.
    :param bool handledBySoc: If set\, set whether this service is handled by SOC 24\/7.
    :param str iconURL: If set\, replace the icon for the service. An image data\-URL on the form data\:image\/png\;base64\,BASE64IMAGEDATA
    :param str listFunction: If set\, change the LIST function for this service\, identified by function ID or shortname.
    :param dict localizedDescriptions: Set localized descriptions to override description for specified language. Only specified languages are changed.
    :param dict localizedNames: Set localized names to override name for specified language. Only specified languages are changed.
    :param bool monitoredBySocOutsideOfficeHours: If set\, set whether this service is monitored by SOC outside office hours.
    :param str name: If set\, change the descriptive name of the service.
    :param str notificationEmail: If set\, change the service notification email address. \[format\:email\]
    :param bool notifyFullFormat: If set\, change the format settings for notifying to the service notification email.
    :param bool notifyOnClose: If set\, change settings for notifying the service notification email address on closed cases.
    :param bool notifyOnCreate: If set\, change settings for notifying the service notification email address on created cases.
    :param bool notifyOnUpdate: If set\, change settings for notifying the service notification email address on updated cases.
    :param str readFunction: If set\, change the READ function for this service\, identified by function ID or shortname.
    :param str shortName: If set\, change the shortname of this service. This must be unique within a domain. WARNING\: This may affect scripts using shortname as service identifier.
    :param str techFunction: If set\, change the TECH function for this service\, identified by function ID or shortname.
    :param dict workflows: If set\, modify workflows enabled for this service.
    :param str writeFunction: If set\, change the WRITE function for this service\, identified by function ID or shortname.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/service/{id}".format(id=id)
    headers = {}

    body = body or {}
    # Only send adminFunction if the argument was provided, don't send null values
    if adminFunction is not None:
        body.update({"adminFunction": adminFunction})
    # Only send assignDefaultTech if the argument was provided, don't send null values
    if assignDefaultTech is not None:
        body.update({"assignDefaultTech": assignDefaultTech})
    # Only send assignDefaultUser if the argument was provided, don't send null values
    if assignDefaultUser is not None:
        body.update({"assignDefaultUser": assignDefaultUser})
    # Only send caseTypesToAdd if the argument was provided, don't send null values
    if caseTypesToAdd is not None:
        body.update({"caseTypesToAdd": caseTypesToAdd})
    # Only send caseTypesToRemove if the argument was provided, don't send null values
    if caseTypesToRemove is not None:
        body.update({"caseTypesToRemove": caseTypesToRemove})
    # Only send caseTypesToSet if the argument was provided, don't send null values
    if caseTypesToSet is not None:
        body.update({"caseTypesToSet": caseTypesToSet})
    # Only send createFunction if the argument was provided, don't send null values
    if createFunction is not None:
        body.update({"createFunction": createFunction})
    # Only send defineFunction if the argument was provided, don't send null values
    if defineFunction is not None:
        body.update({"defineFunction": defineFunction})
    # Only send deprecated if the argument was provided, don't send null values
    if deprecated is not None:
        body.update({"deprecated": deprecated})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send eventEnabled if the argument was provided, don't send null values
    if eventEnabled is not None:
        body.update({"eventEnabled": eventEnabled})
    # Only send fieldPolicy if the argument was provided, don't send null values
    if fieldPolicy is not None:
        body.update({"fieldPolicy": fieldPolicy})
    # Only send handledBySoc if the argument was provided, don't send null values
    if handledBySoc is not None:
        body.update({"handledBySoc": handledBySoc})
    # Only send iconURL if the argument was provided, don't send null values
    if iconURL is not None:
        body.update({"iconURL": iconURL})
    # Only send listFunction if the argument was provided, don't send null values
    if listFunction is not None:
        body.update({"listFunction": listFunction})
    # Only send localizedDescriptions if the argument was provided, don't send null values
    if localizedDescriptions is not None:
        body.update({"localizedDescriptions": localizedDescriptions})
    # Only send localizedNames if the argument was provided, don't send null values
    if localizedNames is not None:
        body.update({"localizedNames": localizedNames})
    # Only send monitoredBySocOutsideOfficeHours if the argument was provided, don't send null values
    if monitoredBySocOutsideOfficeHours is not None:
        body.update(
            {"monitoredBySocOutsideOfficeHours": monitoredBySocOutsideOfficeHours}
        )
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send notificationEmail if the argument was provided, don't send null values
    if notificationEmail is not None:
        body.update({"notificationEmail": notificationEmail})
    # Only send notifyFullFormat if the argument was provided, don't send null values
    if notifyFullFormat is not None:
        body.update({"notifyFullFormat": notifyFullFormat})
    # Only send notifyOnClose if the argument was provided, don't send null values
    if notifyOnClose is not None:
        body.update({"notifyOnClose": notifyOnClose})
    # Only send notifyOnCreate if the argument was provided, don't send null values
    if notifyOnCreate is not None:
        body.update({"notifyOnCreate": notifyOnCreate})
    # Only send notifyOnUpdate if the argument was provided, don't send null values
    if notifyOnUpdate is not None:
        body.update({"notifyOnUpdate": notifyOnUpdate})
    # Only send readFunction if the argument was provided, don't send null values
    if readFunction is not None:
        body.update({"readFunction": readFunction})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send techFunction if the argument was provided, don't send null values
    if techFunction is not None:
        body.update({"techFunction": techFunction})
    # Only send workflows if the argument was provided, don't send null values
    if workflows is not None:
        body.update({"workflows": workflows})
    # Only send writeFunction if the argument was provided, don't send null values
    if writeFunction is not None:
        body.update({"writeFunction": writeFunction})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
