"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def abort_fragmented_upload(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Abort fragmented upload of an attachment (PUBLIC)

    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/abort".format(
        caseID=caseID, attachmentID=attachmentID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def abort_prepared_case(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Abort a prepared case. This removes the prepared (non-created) case entry from the database. (PUBLIC)

    :param int caseID: ID of prepared case
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/prepare/{caseID}".format(caseID=caseID)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def acknowledge_workflow(
    caseID: int,
    workflow: str,
    comment: str = None,
    publicComment: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Acknowledge workflow on case (PUBLIC)

    :param int caseID: Case ID
    :param str workflow: Workflow to acknowledge
    :param str comment: Optional acknowledgement comment to add. Html is allowed\, will be sanitized.
    :param bool publicComment: If true\, the comment is marked as public\, and is made visible to customer.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows/{workflow}/acknowledge".format(
        caseID=caseID, workflow=workflow
    )
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send publicComment if the argument was provided, don't send null values
    if publicComment is not None:
        body.update({"publicComment": publicComment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def add_attachment(
    caseID: int,
    data: str,
    mimeType: str,
    name: str,
    encryptedZip: bool = None,
    internal: bool = None,
    notification: dict = None,
    originEmailAddress: str = None,
    encryptedZipMode: str = "none",
    encryptedZipPassword: str = "argus",
    prepared: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add new attachment (PUBLIC)

    :param int caseID: Case ID
    :param str data:
    :param str mimeType: MimeType for attachment to add.
    :param str name: Name of attachment to add.
    :param bool encryptedZip: This option is deprecated\, use encryptedZipMode instead
    :param bool internal: If set\, the attachment will be marked as internal. This is only allowed by tech users. Internal attachments are only readable by tech users.
    :param dict notification:
    :param str originEmailAddress: If update is made from an email\, specify origin email address here \[format\:email\]
    :param str encryptedZipMode: If set to \'server\'\, the server will zip\-encrypt the file using encryptedZipPassword\, and set the outer mimetype to application\/zip. If set to \'client\'\, the server will mark this attachment as already encrypted zip \(document the password using property encryptedZipPassword\).
    :param str encryptedZipPassword: If encryptedZipMode is set\, use this property to encrypt\/document the password set on the zipfile.
    :param bool prepared: If set the attachment will be uploaded in a \"prepared\" state\, in which they are not visible to other users until the connected comment is published.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send data if the argument was provided, don't send null values
    if data is not None:
        body.update({"data": data})
    # Only send encryptedZip if the argument was provided, don't send null values
    if encryptedZip is not None:
        body.update({"encryptedZip": encryptedZip})
    # Only send encryptedZipMode if the argument was provided, don't send null values
    if encryptedZipMode is not None:
        body.update({"encryptedZipMode": encryptedZipMode})
    # Only send encryptedZipPassword if the argument was provided, don't send null values
    if encryptedZipPassword is not None:
        body.update({"encryptedZipPassword": encryptedZipPassword})
    # Only send internal if the argument was provided, don't send null values
    if internal is not None:
        body.update({"internal": internal})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send prepared if the argument was provided, don't send null values
    if prepared is not None:
        body.update({"prepared": prepared})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def add_case_link(
    caseID: int,
    linkToCaseID: int,
    type: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add link to case (PUBLIC)

    :param int caseID: ID of case to link from
    :param int linkToCaseID: ID of case to link to
    :param str type: Type of link to add
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/links/{linkToCaseID}".format(
        caseID=caseID, linkToCaseID=linkToCaseID
    )
    headers = {}

    body = body or {}
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def add_case_tag(
    caseID: int,
    tags: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add tag to case (PUBLIC)

    :param int caseID: Case ID
    :param list tags: Add multiple tags as key\/value strings or JSON objects
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send tags if the argument was provided, don't send null values
    if tags is not None:
        body.update({"tags": tags})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def add_case_watcher(
    caseID: int,
    type: str = "email",
    destination: str = None,
    subjectID: int = None,
    userOrGroup: str = None,
    verbose: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add watcher to case (PUBLIC)

    :param int caseID: Case ID
    :param str type: Type of watcher to add
    :param str destination: Contact information to add as watcher \(email address or phone number\). If subject is specified\, this is ignored.
    :param int subjectID:
    :param str userOrGroup: User or group to add watcher for\, by ID or shortname. Shortname will be resolved in current users domain.
    :param bool verbose: If set\, explicitly set verbosity for watcher \(will override default settings on subject\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send destination if the argument was provided, don't send null values
    if destination is not None:
        body.update({"destination": destination})
    # Only send subjectID if the argument was provided, don't send null values
    if subjectID is not None:
        body.update({"subjectID": subjectID})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send userOrGroup if the argument was provided, don't send null values
    if userOrGroup is not None:
        body.update({"userOrGroup": userOrGroup})
    # Only send verbose if the argument was provided, don't send null values
    if verbose is not None:
        body.update({"verbose": verbose})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def add_comment(
    caseID: int,
    comment: str,
    asReplyTo: str = None,
    associatedAttachmentID: str = None,
    internal: bool = None,
    notification: dict = None,
    originEmailAddress: str = None,
    status: str = None,
    textFormat: str = "html",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Submit new comment to case (PUBLIC)

    :param int caseID: Case ID
    :param str comment: Comment to add. Html is allowed\, will be sanitized.
    :param str asReplyTo: Optional ID of comment to reply to.
    :param list associatedAttachmentID: If set\, associate this comment with the listed attachments.
    :param bool internal: If true\, mark comment as internal\, only visible to service techs. Default is false.
    :param dict notification:
    :param str originEmailAddress: If comment is added from an email\, specify origin email address here. \[format\:email\]
    :param str status: If set\, change the status of the case.
    :param str textFormat: Specify the text format of this comment. Setting plainText gives other consumers a hint that contents does not require a HTML renderer.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send asReplyTo if the argument was provided, don't send null values
    if asReplyTo is not None:
        body.update({"asReplyTo": asReplyTo})
    # Only send associatedAttachmentID if the argument was provided, don't send null values
    if associatedAttachmentID is not None:
        body.update({"associatedAttachmentID": associatedAttachmentID})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send internal if the argument was provided, don't send null values
    if internal is not None:
        body.update({"internal": internal})
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})
    # Only send textFormat if the argument was provided, don't send null values
    if textFormat is not None:
        body.update({"textFormat": textFormat})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def advanced_case_search(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    subCriteria: dict = None,
    exclude: bool = None,
    required: bool = None,
    customerID: int = None,
    caseID: int = None,
    customer: str = None,
    type: str = None,
    service: str = None,
    serviceCriteria: dict = None,
    category: str = None,
    status: str = None,
    initialStatus: str = None,
    priority: str = None,
    initialPriority: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    assetID: str = None,
    tag: dict = None,
    workflow: dict = None,
    field: dict = None,
    keywords: str = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    user: str = None,
    userID: int = None,
    userFieldStrategy: str = None,
    userAssigned: bool = None,
    techAssigned: bool = None,
    includeWorkflows: bool = None,
    includeDescription: bool = None,
    accessMode: str = None,
    explicitAccess: dict = None,
    includeTestData: bool = None,
    productionCustomers: bool = None,
    sortBy: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Returns cases matching the defined CaseSearchCriteria (PUBLIC)

    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param list subCriteria: Set additional criterias which are applied using a logical OR.
    :param bool exclude: Only relevant for subcriteria. If set to true\, objects matching this subcriteria object will be excluded.
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param list customerID: Restrict search to data belonging to specified customers.
    :param list caseID: Restrict search to specific cases \(by ID\).
    :param list customer: Restrict search to specific customers \(by ID or shortname\).
    :param list type: Restrict search to entries of one of these types.
    :param list service: This option is deprecated\, use serviceCriteria instead.
    :param dict serviceCriteria:
    :param list category: Restrict search to entries of one of these categories \(by category shortname or ID\).
    :param list status: Restrict search to entries of one of these statuses.
    :param list initialStatus: Restrict search to entries where the initial status is one of these statuses.
    :param list priority: Restrict search to entries with given priorties
    :param list initialPriority: Restrict search to entries where the initial priority is one of these priorties
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list assetID: Restrict search to cases associated with specified assets \(hosts\, services or processes\)
    :param list tag: Restrict search to entries matching the given tag criteria.
    :param list workflow: Restrict search to entries matching the given workflow criteria.
    :param list field: Restrict search to entries matching the given field criteria.
    :param list keywords: Search for keywords.
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default all\).
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\).
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords \(default match all keywords\).
    :param list user: Restrict search to cases associated with these users or user groups \(by ID or shortname\).
    :param list userID: This field is deprecated. Use field \'user\' instead.
    :param list userFieldStrategy: Defines which user fields will be searched \(default match all user fields\).
    :param bool userAssigned: If set\, limit search to cases where assignedUser field is set\/unset
    :param bool techAssigned: If set\, limit search to cases where assignedTech field is set\/unset
    :param bool includeWorkflows: If true\, include list of workflows in result. Default is false \(not present\).
    :param bool includeDescription: If false\, omit description from response. Default is true \(description is present\).
    :param list accessMode: If set\, only match cases which is set to one of these access modes
    :param list explicitAccess: If set\, only match cases which have explicit access grants matching the specified criteria
    :param bool includeTestData: If true\, also include cases marked as TEST\_DATA in search result. This option is restricted to users with permission viewCaseTestData. Default is false \(excluded\).
    :param bool productionCustomers: If set\, apply a customer filter for customers marked as \'not in production\'. If true\, EXCLUDE customers \'not in production\'. If false\, REQUIRE customers \'not in production\'. Default is unset \(no filter on production customers\).
    :param list sortBy:
    :param list includeFlags: Only include objects which have includeFlags set.
    :param list excludeFlags: Exclude objects which have excludeFlags set.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/cases/v2/case/search".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send caseID if the argument was provided, don't send null values
    if caseID is not None:
        body.update({"caseID": caseID})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send serviceCriteria if the argument was provided, don't send null values
    if serviceCriteria is not None:
        body.update({"serviceCriteria": serviceCriteria})
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})
    # Only send initialStatus if the argument was provided, don't send null values
    if initialStatus is not None:
        body.update({"initialStatus": initialStatus})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send initialPriority if the argument was provided, don't send null values
    if initialPriority is not None:
        body.update({"initialPriority": initialPriority})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send assetID if the argument was provided, don't send null values
    if assetID is not None:
        body.update({"assetID": assetID})
    # Only send tag if the argument was provided, don't send null values
    if tag is not None:
        body.update({"tag": tag})
    # Only send workflow if the argument was provided, don't send null values
    if workflow is not None:
        body.update({"workflow": workflow})
    # Only send field if the argument was provided, don't send null values
    if field is not None:
        body.update({"field": field})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userID if the argument was provided, don't send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userAssigned if the argument was provided, don't send null values
    if userAssigned is not None:
        body.update({"userAssigned": userAssigned})
    # Only send techAssigned if the argument was provided, don't send null values
    if techAssigned is not None:
        body.update({"techAssigned": techAssigned})
    # Only send includeWorkflows if the argument was provided, don't send null values
    if includeWorkflows is not None:
        body.update({"includeWorkflows": includeWorkflows})
    # Only send includeDescription if the argument was provided, don't send null values
    if includeDescription is not None:
        body.update({"includeDescription": includeDescription})
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send explicitAccess if the argument was provided, don't send null values
    if explicitAccess is not None:
        body.update({"explicitAccess": explicitAccess})
    # Only send includeTestData if the argument was provided, don't send null values
    if includeTestData is not None:
        body.update({"includeTestData": includeTestData})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def answer_enquiry(
    caseID: int,
    enquiryID: str,
    answer: dict,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Answer a case enquiry (INTERNAL)

    :param int caseID: Case ID
    :param str enquiryID: Enquiry ID
    :param dict answer:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/enquiries/{enquiryID}/answer".format(
        caseID=caseID, enquiryID=enquiryID
    )
    headers = {}

    body = body or {}
    # Only send answer if the argument was provided, don't send null values
    if answer is not None:
        body.update({"answer": answer})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def change_access_settings(
    caseID: int,
    accessMode: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Change general access settings (PUBLIC)

    :param int caseID: Case ID
    :param str accessMode: If set\, this will alter the access mode of the case.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def clear_field(
    caseID: int,
    field: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Clear specific field for a case, by either field ID or field name. For multivalue fields, the field may contain multiple values. (INTERNAL)

    :param int caseID: ID of the case to clear fields for
    :param str field: ID or fieldName of the field to clear
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields/{field}".format(caseID=caseID, field=field)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def close_case(
    caseID: int,
    comment: str = None,
    internalComment: bool = None,
    notification: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Close an open case (PUBLIC)

    :param int caseID: Case ID
    :param str comment: Closing comment to add to case. May use HTML\, will be sanitized.
    :param bool internalComment: If true\, mark comment as internal\, only visible to service techs. Default is false.
    :param dict notification:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/close".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send internalComment if the argument was provided, don't send null values
    if internalComment is not None:
        body.update({"internalComment": internalComment})
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def complete_fragmented_upload(
    caseID: int,
    attachmentID: str,
    sha256: str,
    notification: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Complete fragmented upload of an attachment (PUBLIC)

    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param str sha256: The sha256 of the entire document.
    :param dict notification:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/complete".format(
        caseID=caseID, attachmentID=attachmentID
    )
    headers = {}

    body = body or {}
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send sha256 if the argument was provided, don't send null values
    if sha256 is not None:
        body.update({"sha256": sha256})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def create_case(
    description: str,
    service: str,
    subject: str,
    type: str,
    accessMode: str = "roleBased",
    priority: str = "medium",
    aclMembers: dict = None,
    assignedTech: str = None,
    assignedUser: str = None,
    category: str = None,
    customer: str = None,
    customerID: int = None,
    customerReference: str = None,
    fields: dict = None,
    notification: dict = None,
    originEmailAddress: str = None,
    status: str = None,
    tags: dict = None,
    testData: bool = None,
    triggers: dict = None,
    watchers: dict = None,
    defaultWatchers: bool = True,
    descriptionTextFormat: str = "html",
    publish: bool = True,
    rejectCreateWithoutNotification: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Create a new case defined by CaseCreateRequest (PUBLIC)

    :param str description: Case description. May use HTML\, which will be sanitized.
    :param str service: ID of service to create case for
    :param str subject: Subject of case to create.
    :param str type: Type of case to create
    :param str accessMode: Access mode for new case.
    :param str priority: Priority of case to create.
    :param list aclMembers: Explicit ACL members to add to case.
    :param str assignedTech: If set\, assign given technical user \(solution engineer\) to case \(by ID or shortname\). Shortname will be resolved in the current users domain.
    :param str assignedUser: If set\, assign given user to case \(by ID or shortname\). Shortname will be resolved in the current users domain.
    :param str category: If set\, assign given category to new case \(by category shortname\). Deprecated categories can\'t be used.
    :param str customer: ID or shortname of customer to create case for. Defaults to current users customer
    :param int customerID: DEPRECATED. Use customer instead
    :param str customerReference: Customer reference for case.
    :param list fields: Fields to set on case creation. Fields in the policy for requested service and customer specifies fields available. If any of the fields in the policy are required on create\, and do not have a default value\,those fields must be set in the case create request\, or the request will fail.
    :param dict notification:
    :param str originEmailAddress: If case is created from an email\, specify origin email address here \[format\:email\]
    :param str status: Status of case to create. If not set\, system will select automatically. Creating a new case with status closed is not permitted.
    :param list tags: Tags to add on case creation.
    :param bool testData: If true\, this case will be marked as TEST\_DATA. TEST\_DATA cases are excluded from search results by default.
    :param dict triggers:
    :param list watchers: Explicit watchers to add to this case.
    :param bool defaultWatchers: Whether to enable default watchers for this case. If set to false\, default watchers will not be enabled\, and will not be notified upon creation of this case.
    :param str descriptionTextFormat: Set the text format of the description. Setting plainText gives other consumers a hint that contents does not require a HTML renderer.
    :param bool publish: Whether to publish new case. Creating an unpublished case requires special permission.
    :param bool rejectCreateWithoutNotification: If set to true and there are no default or explicit watchers added to the case\, fails the request with 412.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case".format()
    headers = {}

    body = body or {}
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send aclMembers if the argument was provided, don't send null values
    if aclMembers is not None:
        body.update({"aclMembers": aclMembers})
    # Only send assignedTech if the argument was provided, don't send null values
    if assignedTech is not None:
        body.update({"assignedTech": assignedTech})
    # Only send assignedUser if the argument was provided, don't send null values
    if assignedUser is not None:
        body.update({"assignedUser": assignedUser})
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send customerReference if the argument was provided, don't send null values
    if customerReference is not None:
        body.update({"customerReference": customerReference})
    # Only send defaultWatchers if the argument was provided, don't send null values
    if defaultWatchers is not None:
        body.update({"defaultWatchers": defaultWatchers})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send descriptionTextFormat if the argument was provided, don't send null values
    if descriptionTextFormat is not None:
        body.update({"descriptionTextFormat": descriptionTextFormat})
    # Only send fields if the argument was provided, don't send null values
    if fields is not None:
        body.update({"fields": fields})
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send publish if the argument was provided, don't send null values
    if publish is not None:
        body.update({"publish": publish})
    # Only send rejectCreateWithoutNotification if the argument was provided, don't send null values
    if rejectCreateWithoutNotification is not None:
        body.update(
            {"rejectCreateWithoutNotification": rejectCreateWithoutNotification}
        )
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send tags if the argument was provided, don't send null values
    if tags is not None:
        body.update({"tags": tags})
    # Only send testData if the argument was provided, don't send null values
    if testData is not None:
        body.update({"testData": testData})
    # Only send triggers if the argument was provided, don't send null values
    if triggers is not None:
        body.update({"triggers": triggers})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send watchers if the argument was provided, don't send null values
    if watchers is not None:
        body.update({"watchers": watchers})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def create_enquiry(
    caseID: int,
    querySchema: dict,
    title: str,
    readRole: str = "tech",
    writeRole: str = "tech",
    description: str = None,
    flowName: str = None,
    queryLayout: dict = None,
    uischema: dict = None,
    mandatory: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Create a new case enquiry (INTERNAL)

    :param int caseID: Case ID
    :param dict querySchema:
    :param str title: Human readable title of the case enquiry
    :param str readRole: Required role for read access to the case enquiry
    :param str writeRole: Required role for write access to the case enquiry
    :param str description: Description of the case enquiry\, may contain HTML which will be sanitized
    :param str flowName: Machine readable shortname to identify the case enquiry
    :param list queryLayout: List of layout elements\/widgets used in this case enquiry. Deprecated\, use uiSchema\-field instead.
    :param dict uischema:
    :param bool mandatory: Boolean flag that indicates whether the case enquiry is mandatory or not
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/enquiries".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send flowName if the argument was provided, don't send null values
    if flowName is not None:
        body.update({"flowName": flowName})
    # Only send mandatory if the argument was provided, don't send null values
    if mandatory is not None:
        body.update({"mandatory": mandatory})
    # Only send queryLayout if the argument was provided, don't send null values
    if queryLayout is not None:
        body.update({"queryLayout": queryLayout})
    # Only send querySchema if the argument was provided, don't send null values
    if querySchema is not None:
        body.update({"querySchema": querySchema})
    # Only send readRole if the argument was provided, don't send null values
    if readRole is not None:
        body.update({"readRole": readRole})
    # Only send title if the argument was provided, don't send null values
    if title is not None:
        body.update({"title": title})
    # Only send uischema if the argument was provided, don't send null values
    if uischema is not None:
        body.update({"uischema": uischema})
    # Only send writeRole if the argument was provided, don't send null values
    if writeRole is not None:
        body.update({"writeRole": writeRole})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def create_prepared_case(
    caseID: int,
    description: str,
    service: str,
    subject: str,
    type: str,
    accessMode: str = "roleBased",
    priority: str = "medium",
    aclMembers: dict = None,
    assignedTech: str = None,
    assignedUser: str = None,
    category: str = None,
    customer: str = None,
    customerID: int = None,
    customerReference: str = None,
    fields: dict = None,
    notification: dict = None,
    originEmailAddress: str = None,
    status: str = None,
    tags: dict = None,
    testData: bool = None,
    triggers: dict = None,
    watchers: dict = None,
    defaultWatchers: bool = True,
    descriptionTextFormat: str = "html",
    publish: bool = True,
    rejectCreateWithoutNotification: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Create a prepared case. This finalizes the creation of the case prepared using /case/prepare (PUBLIC)

    :param int caseID: ID of prepared case
    :param str description: Case description. May use HTML\, which will be sanitized.
    :param str service: ID of service to create case for
    :param str subject: Subject of case to create.
    :param str type: Type of case to create
    :param str accessMode: Access mode for new case.
    :param str priority: Priority of case to create.
    :param list aclMembers: Explicit ACL members to add to case.
    :param str assignedTech: If set\, assign given technical user \(solution engineer\) to case \(by ID or shortname\). Shortname will be resolved in the current users domain.
    :param str assignedUser: If set\, assign given user to case \(by ID or shortname\). Shortname will be resolved in the current users domain.
    :param str category: If set\, assign given category to new case \(by category shortname\). Deprecated categories can\'t be used.
    :param str customer: ID or shortname of customer to create case for. Defaults to current users customer
    :param int customerID: DEPRECATED. Use customer instead
    :param str customerReference: Customer reference for case.
    :param list fields: Fields to set on case creation. Fields in the policy for requested service and customer specifies fields available. If any of the fields in the policy are required on create\, and do not have a default value\,those fields must be set in the case create request\, or the request will fail.
    :param dict notification:
    :param str originEmailAddress: If case is created from an email\, specify origin email address here \[format\:email\]
    :param str status: Status of case to create. If not set\, system will select automatically. Creating a new case with status closed is not permitted.
    :param list tags: Tags to add on case creation.
    :param bool testData: If true\, this case will be marked as TEST\_DATA. TEST\_DATA cases are excluded from search results by default.
    :param dict triggers:
    :param list watchers: Explicit watchers to add to this case.
    :param bool defaultWatchers: Whether to enable default watchers for this case. If set to false\, default watchers will not be enabled\, and will not be notified upon creation of this case.
    :param str descriptionTextFormat: Set the text format of the description. Setting plainText gives other consumers a hint that contents does not require a HTML renderer.
    :param bool publish: Whether to publish new case. Creating an unpublished case requires special permission.
    :param bool rejectCreateWithoutNotification: If set to true and there are no default or explicit watchers added to the case\, fails the request with 412.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send aclMembers if the argument was provided, don't send null values
    if aclMembers is not None:
        body.update({"aclMembers": aclMembers})
    # Only send assignedTech if the argument was provided, don't send null values
    if assignedTech is not None:
        body.update({"assignedTech": assignedTech})
    # Only send assignedUser if the argument was provided, don't send null values
    if assignedUser is not None:
        body.update({"assignedUser": assignedUser})
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send customerReference if the argument was provided, don't send null values
    if customerReference is not None:
        body.update({"customerReference": customerReference})
    # Only send defaultWatchers if the argument was provided, don't send null values
    if defaultWatchers is not None:
        body.update({"defaultWatchers": defaultWatchers})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send descriptionTextFormat if the argument was provided, don't send null values
    if descriptionTextFormat is not None:
        body.update({"descriptionTextFormat": descriptionTextFormat})
    # Only send fields if the argument was provided, don't send null values
    if fields is not None:
        body.update({"fields": fields})
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send publish if the argument was provided, don't send null values
    if publish is not None:
        body.update({"publish": publish})
    # Only send rejectCreateWithoutNotification if the argument was provided, don't send null values
    if rejectCreateWithoutNotification is not None:
        body.update(
            {"rejectCreateWithoutNotification": rejectCreateWithoutNotification}
        )
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send tags if the argument was provided, don't send null values
    if tags is not None:
        body.update({"tags": tags})
    # Only send testData if the argument was provided, don't send null values
    if testData is not None:
        body.update({"testData": testData})
    # Only send triggers if the argument was provided, don't send null values
    if triggers is not None:
        body.update({"triggers": triggers})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send watchers if the argument was provided, don't send null values
    if watchers is not None:
        body.update({"watchers": watchers})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def current_user_watcher_status(
    caseID: int,
    email: bool = None,
    sms: bool = None,
    verbose: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Query and set watcher status for the current user on this case (PUBLIC)

    :param int caseID: Case ID
    :param bool email: If true\, enable email notification for current user. If false\, disable email. Default is no change.
    :param bool sms: If true\, enable SMS notification for current user. If false\, disable SMS. Default is no change.
    :param bool verbose: If set\, explicitly set verbosity for watcher for enabled contact methods \(will override default settings on current user\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watch".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send email if the argument was provided, don't send null values
    if email is not None:
        body.update({"email": email})
    # Only send sms if the argument was provided, don't send null values
    if sms is not None:
        body.update({"sms": sms})
    # Only send verbose if the argument was provided, don't send null values
    if verbose is not None:
        body.update({"verbose": verbose})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def delete_attachment(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete specified attachment from case (PUBLIC)

    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}".format(
        caseID=caseID, attachmentID=attachmentID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def delete_case(
    caseID: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Mark existing case as deleted (PUBLIC)

    :param int caseID: Case ID
    :param str comment: Optional comment to add to the case as internal comment. Will be appended to associated events.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        query_parameters.update({"comment": comment})

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def delete_case_link(
    caseID: int,
    linkID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Remove existing case link (PUBLIC)

    :param int caseID: Case ID
    :param str linkID: Link ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/links/{linkID}".format(
        caseID=caseID, linkID=linkID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def delete_comment(
    caseID: int,
    commentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Mark existing comment as deleted (PUBLIC)

    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}".format(
        caseID=caseID, commentID=commentID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def delete_enquiry(
    caseID: int,
    enquiryID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Delete a case enquiry (INTERNAL)

    :param int caseID: Case ID
    :param str enquiryID: Enquiry ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/enquiries/{enquiryID}".format(
        caseID=caseID, enquiryID=enquiryID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def download_attachment(
    caseID: int,
    attachmentID: str,
    inline: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Download specific attachment contents. (PUBLIC)

    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param bool inline: Content Disposition Inline
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/download".format(
        caseID=caseID, attachmentID=attachmentID
    )
    headers = {}
    headers["content"] = None

    query_parameters = {}
    # Only send inline if the argument was provided, don't send null values
    if inline is not None:
        query_parameters.update({"inline": inline})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def edit_comment(
    caseID: int,
    commentID: str,
    comment: str,
    associatedAttachmentID: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Edit existing comment (PUBLIC)

    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param str comment: Updated comment
    :param list associatedAttachmentID: If set\, associate this comment with the listed attachments.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}".format(
        caseID=caseID, commentID=commentID
    )
    headers = {}

    body = body or {}
    # Only send associatedAttachmentID if the argument was provided, don't send null values
    if associatedAttachmentID is not None:
        body.update({"associatedAttachmentID": associatedAttachmentID})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_attachment(
    caseID: int,
    attachmentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch specific attachment metadata (PUBLIC)

    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}".format(
        caseID=caseID, attachmentID=attachmentID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_case_comment(
    caseID: int,
    commentID: str,
    resolveLatest: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch specific comment (PUBLIC)

    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param bool resolveLatest: If true\, attempt to resolve latest version of comment\, if it has been updated
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}".format(
        caseID=caseID, commentID=commentID
    )
    headers = {}

    query_parameters = {}
    # Only send resolveLatest if the argument was provided, don't send null values
    if resolveLatest is not None:
        query_parameters.update({"resolveLatest": resolveLatest})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_case_comment_notifications(
    caseID: int,
    commentID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch notifications recorded for specified comment (PUBLIC)

    :param int caseID: Case ID
    :param str commentID: Comment ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments/{commentID}/notifications".format(
        caseID=caseID, commentID=commentID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_case_metadata_by_id(
    id: int,
    skipRedirect: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns the basic case descriptor for the case identified by ID (PUBLIC)

    :param int id: Case ID
    :param bool skipRedirect: If true\, skip automatic redirect \(for merged cases\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send skipRedirect if the argument was provided, don't send null values
    if skipRedirect is not None:
        query_parameters.update({"skipRedirect": skipRedirect})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_case_service(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns the service descriptor for the case identified by ID (PUBLIC)

    :param int id: Case ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}/service".format(id=id)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_case_transaction(
    caseID: int,
    transactionID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns a single case transaction transactions (PUBLIC)

    :param int caseID: Case ID
    :param str transactionID: Transaction ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/history/{transactionID}".format(
        caseID=caseID, transactionID=transactionID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_enquiry(
    caseID: int,
    enquiryID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches a case enquiry (INTERNAL)

    :param int caseID: Case ID
    :param str enquiryID: Enquiry ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/enquiries/{enquiryID}".format(
        caseID=caseID, enquiryID=enquiryID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_enquiry_client_validation_code(
    enquiryID: str,
    caseID: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Fetches a case enquiry client validation code (in JavaScript) (INTERNAL)

    :param str enquiryID: Enquiry ID
    :param int caseID: Case ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ClientValidationCodeGenerationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/cases/v2/case/enquiries/clientValidationCode".format()
    headers = {}
    headers["content"] = None

    query_parameters = {}
    # Only send caseID if the argument was provided, don't send null values
    if caseID is not None:
        query_parameters.update({"caseID": caseID})
    # Only send enquiryID if the argument was provided, don't send null values
    if enquiryID is not None:
        query_parameters.update({"enquiryID": enquiryID})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_field(
    caseID: int,
    field: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch specific field for a case, by either field ID or field name. For multivalue fields, the field may contain multiple values. (INTERNAL)

    :param int caseID: ID of the case to fetch fields for
    :param str field: ID or fieldName of the field to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises CaseNotFoundException: on 404
    :raises InvalidFieldSpecifiedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields/{field}".format(caseID=caseID, field=field)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_field_policy_by_case(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetch field policy for a specific case (INTERNAL)

    :param int caseID: ID of case to fetch policy for
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fieldpolicy".format(caseID=caseID)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def get_reindex_bulk_case_status(
    taskID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Get the status of case bulk reindexing task (INTERNAL)

    :param str taskID: Task ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/reindex/{taskID}".format(taskID=taskID)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def grant_access(
    caseID: int,
    userOrGroup: str,
    addWatcher: bool = True,
    level: str = "read",
    subjectID: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Grant access to a case (PUBLIC)

    :param int caseID: Case ID
    :param str userOrGroup: ID or shortname of user or group to grant access to. Shortname will be resolved in current users domain.
    :param bool addWatcher: If true\, also add the granted subject as watcher for this case.
    :param str level: Level to grant for subject.
    :param int subjectID: This field is deprecated. Use field \'userOrGroup\' instead.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send addWatcher if the argument was provided, don't send null values
    if addWatcher is not None:
        body.update({"addWatcher": addWatcher})
    # Only send level if the argument was provided, don't send null values
    if level is not None:
        body.update({"level": level})
    # Only send subjectID if the argument was provided, don't send null values
    if subjectID is not None:
        body.update({"subjectID": subjectID})
    # Only send userOrGroup if the argument was provided, don't send null values
    if userOrGroup is not None:
        body.update({"userOrGroup": userOrGroup})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_acl(
    caseID: int,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List ACL entries for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_attachments(
    caseID: int,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List attachments for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_comments(
    caseID: int,
    beforeComment: str = None,
    afterComment: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List comments for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param str beforeComment: Limit to comments before this comment ID \(in sort order\)
    :param str afterComment: Limit to comments after this comment ID \(in sort order\)
    :param list sortBy: Sort ordering. Default is addedTimestamp \(ascending\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/comments".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send beforeComment if the argument was provided, don't send null values
    if beforeComment is not None:
        query_parameters.update({"beforeComment": beforeComment})
    # Only send afterComment if the argument was provided, don't send null values
    if afterComment is not None:
        query_parameters.update({"afterComment": afterComment})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_history(
    caseID: int,
    type: str = None,
    operation: str = None,
    field: str = None,
    userID: int = None,
    user: str = None,
    transactionID: str = None,
    beforeTransaction: str = None,
    afterTransaction: str = None,
    startTimestamp: str = None,
    endTimestamp: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns the history of case transactions (PUBLIC)

    :param int caseID: Case ID
    :param list type: Transaction types to fetch
    :param list operation: Include operations
    :param list field: Include fields
    :param list userID: Use the \'user\' parameter instead
    :param list user: Filter out transactions by specified users
    :param list transactionID: Filter out specific transactions
    :param str beforeTransaction: Limit to transactions before this transaction \(in sort order\)
    :param str afterTransaction: Limit to transactions after this transaction \(in sort order\)
    :param str startTimestamp: Limit to transactions after this timestamp
    :param str endTimestamp: Limit to transactions before this timestamp
    :param list sortBy: Sort ordering. Default is timestamp \(ascending\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/history".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        query_parameters.update({"type": type})
    # Only send operation if the argument was provided, don't send null values
    if operation is not None:
        query_parameters.update({"operation": operation})
    # Only send field if the argument was provided, don't send null values
    if field is not None:
        query_parameters.update({"field": field})
    # Only send userID if the argument was provided, don't send null values
    if userID is not None:
        query_parameters.update({"userID": userID})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        query_parameters.update({"user": user})
    # Only send transactionID if the argument was provided, don't send null values
    if transactionID is not None:
        query_parameters.update({"transactionID": transactionID})
    # Only send beforeTransaction if the argument was provided, don't send null values
    if beforeTransaction is not None:
        query_parameters.update({"beforeTransaction": beforeTransaction})
    # Only send afterTransaction if the argument was provided, don't send null values
    if afterTransaction is not None:
        query_parameters.update({"afterTransaction": afterTransaction})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_links(
    caseID: int,
    direction: str = None,
    type: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List links for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param str direction: Specify direction of links to fetch \(default all\)
    :param list type: Specify link types to fetch \(default all\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/links".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send direction if the argument was provided, don't send null values
    if direction is not None:
        query_parameters.update({"direction": direction})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        query_parameters.update({"type": type})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_seen(
    caseID: int,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List 'last seen' status for a case (PUBLIC)

    :param int caseID: Case ID
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/seen".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_tags(
    caseID: int,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List tags for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_case_watchers(
    caseID: int,
    offset: int = 0,
    limit: int = 25,
    includeExplicit: bool = True,
    includeDefault: bool = True,
    includeDisabled: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List watchers for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param bool includeExplicit: Include explicit watchers \(default true\)
    :param bool includeDefault: Include default watchers \(default true\)
    :param bool includeDisabled: Include disabled watchers \(default false\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeExplicit if the argument was provided, don't send null values
    if includeExplicit is not None:
        query_parameters.update({"includeExplicit": includeExplicit})
    # Only send includeDefault if the argument was provided, don't send null values
    if includeDefault is not None:
        query_parameters.update({"includeDefault": includeDefault})
    # Only send includeDisabled if the argument was provided, don't send null values
    if includeDisabled is not None:
        query_parameters.update({"includeDisabled": includeDisabled})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_enquiries(
    caseID: int,
    state: str = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    includeDeleted: bool = False,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Fetches case enquiries (INTERNAL)

    :param int caseID: Case ID
    :param list state: Filter enquiries by state
    :param list includeFlags: Filter enquiries by include flags \(all of the specified flags have to be present\)
    :param list excludeFlags: Filter enquiries by exclude flags \(none of the specified flags have to be present\)
    :param bool includeDeleted: Whether to include deleted enquiries
    :param int offset: The amount of items to skip from the beginning
    :param int limit: Maximum amount of items to return \(0 means no limit\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/enquiries".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send state if the argument was provided, don't send null values
    if state is not None:
        query_parameters.update({"state": state})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        query_parameters.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        query_parameters.update({"excludeFlags": excludeFlags})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_fields(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List fields on case. Each field represents a defined field which has a value set for this case. For multivalue fields, the field may contain multiple values. (INTERNAL)

    :param int caseID: ID of the case to fetch fields for
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises CaseNotFoundException: on 404
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields".format(caseID=caseID)
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_transaction_notifications(
    caseID: int,
    transactionID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns the notifications of a specified transaction (PUBLIC)

    :param int caseID: Case ID
    :param str transactionID: Transaction ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/history/{transactionID}/notifications".format(
        caseID=caseID, transactionID=transactionID
    )
    headers = {}

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def list_workflows(
    caseID: int,
    includeDeleted: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List workflows for an existing case (PUBLIC)

    :param int caseID: Case ID
    :param bool includeDeleted: If true\, include deleted workflows
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows".format(caseID=caseID)
    headers = {}

    query_parameters = {}
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def merge_cases(
    mergeInto: int,
    mergeFrom: int,
    description: str = None,
    priority: str = None,
    status: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Merge two cases (PUBLIC)

    :param int mergeInto: ID of case to merge into
    :param int mergeFrom: ID of case to merge
    :param str description: Case description of merged case. May use HTML\, which will be sanitized. If not set\, the description of both cases will be combined.
    :param str priority: Priority of merged case. If not set\, keep priority of mergeInto case.
    :param str status: Status of merged case. If not set\, keep status of mergeInto case.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{mergeInto}/merge/{mergeFrom}".format(
        mergeInto=mergeInto, mergeFrom=mergeFrom
    )
    headers = {}

    body = body or {}
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def move_case(
    id: int,
    category: str = None,
    customer: str = None,
    customerID: int = None,
    service: str = None,
    type: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Move a case to a differnet category, service or customer (PUBLIC)

    :param int id: Case ID
    :param str category: If set\, assign given category to specified category \(by category id or shortname\). Set value to empty string to unset category.
    :param str customer: If set\, move case to specified customer \(id or shortname\).
    :param int customerID: DEPRECATED. Use customer instead
    :param str service: If set\, move case to specified service \(id or shortname\).
    :param str type: If set\, move case to specified type.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}/move".format(id=id)
    headers = {}

    body = body or {}
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def prepare_attachment_upload(
    caseID: int,
    mimeType: str,
    name: str,
    encryptedZip: bool = None,
    internal: bool = None,
    originEmailAddress: str = None,
    encryptedZipMode: str = "none",
    encryptedZipPassword: str = "argus",
    prepared: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Prepare new fragmentedattachment upload (PUBLIC)

    :param int caseID: Case ID
    :param str mimeType: MimeType for attachment to add.
    :param str name: Name of attachment to add.
    :param bool encryptedZip: This option is deprecated\, use encryptedZipMode instead
    :param bool internal: If set\, the attachment will be marked as internal. This is only allowed by tech users. Internal attachments are only readable by tech users.
    :param str originEmailAddress: If update is made from an email\, specify origin email address here \[format\:email\]
    :param str encryptedZipMode: If set to \'server\'\, the server will zip\-encrypt the file using encryptedZipPassword\, and set the outer mimetype to application\/zip. If set to \'client\'\, the server will mark this attachment as already encrypted zip \(document the password using property encryptedZipPassword\).
    :param str encryptedZipPassword: If encryptedZipMode is set\, use this property to encrypt\/document the password set on the zipfile.
    :param bool prepared: If set the attachment will be uploaded in a \"prepared\" state\, in which they are not visible to other users until the connected comment is published.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/prepare".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send encryptedZip if the argument was provided, don't send null values
    if encryptedZip is not None:
        body.update({"encryptedZip": encryptedZip})
    # Only send encryptedZipMode if the argument was provided, don't send null values
    if encryptedZipMode is not None:
        body.update({"encryptedZipMode": encryptedZipMode})
    # Only send encryptedZipPassword if the argument was provided, don't send null values
    if encryptedZipPassword is not None:
        body.update({"encryptedZipPassword": encryptedZipPassword})
    # Only send internal if the argument was provided, don't send null values
    if internal is not None:
        body.update({"internal": internal})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send prepared if the argument was provided, don't send null values
    if prepared is not None:
        body.update({"prepared": prepared})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def prepare_case(
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Prepare a new case object, to allow adding collections before properly creating it (PUBLIC)

    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/prepare".format()
    headers = {}

    body = body or {}

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def publish_case(
    caseID: int,
    notification: dict = None,
    status: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Publish existing case not marked as published (PUBLIC)

    :param int caseID: Case ID
    :param dict notification:
    :param str status: If set\, change status of case
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/publish".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def register_case_seen(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Register 'last seen' status for a case (PUBLIC)

    :param int caseID: Case ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/seen".format(caseID=caseID)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def reindex_bulk_case(
    correlationID: str = None,
    customer: str = None,
    endTimestamp: int = None,
    startTimestamp: int = None,
    timeFieldStrategy: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Force reindexing of a bulk of cases using service tasks (INTERNAL)

    :param str correlationID: An optional correlation ID for making it easier to trace the task and its subtasks in the logs.
    :param list customer: Limit reindexing to the cases of the specified customers.
    :param int endTimestamp: Timestamp of the range to end reindexing with \(inclusive\).
    :param int startTimestamp: Timestamp of the range to start reindexing with \(inclusive\).
    :param str timeFieldStrategy: Which time field to use for timestamp\-based limiting.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/reindex".format()
    headers = {}

    body = body or {}
    # Only send correlationID if the argument was provided, don't send null values
    if correlationID is not None:
        body.update({"correlationID": correlationID})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def reindex_case(
    caseID: int,
    refresh: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Force reindexing of case (INTERNAL)

    :param int caseID: Case ID
    :param bool refresh: If true\, force immediate refresh before returning
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/reindex".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send refresh if the argument was provided, don't send null values
    if refresh is not None:
        body.update({"refresh": refresh})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def reject_enquiry(
    caseID: int,
    enquiryID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Reject a case enquiry (INTERNAL)

    :param int caseID: Case ID
    :param str enquiryID: Enquiry ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/enquiries/{enquiryID}/reject".format(
        caseID=caseID, enquiryID=enquiryID
    )
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def remove_access(
    caseID: int,
    aclEntryID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Revoke access from a case (PUBLIC)

    :param int caseID: Case ID
    :param str aclEntryID: ACL entry to revoke
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/access/{aclEntryID}".format(
        caseID=caseID, aclEntryID=aclEntryID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def remove_case_contact_watcher(
    caseID: int,
    contactID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Remove a specific contact listed in the default watchers from watching this case (PUBLIC)

    :param int caseID: Case ID
    :param int contactID: Contact ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers/contact/{contactID}".format(
        caseID=caseID, contactID=contactID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def remove_case_tag_by_id(
    caseID: int,
    tagID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Remove existing tag (PUBLIC)

    :param int caseID: Case ID
    :param str tagID: Tag ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags/{tagID}".format(caseID=caseID, tagID=tagID)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def remove_case_tag_by_key_value(
    caseID: int,
    tagKey: str,
    tagValue: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Remove existing tag (PUBLIC)

    :param int caseID: Case ID
    :param str tagKey: Tag Key
    :param str tagValue: Tag Value
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/tags/{tagKey}/{tagValue}".format(
        caseID=caseID, tagKey=tagKey, tagValue=tagValue
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def remove_case_watcher(
    caseID: int,
    watcherID: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Remove specific watcher from a case (PUBLIC)

    :param int caseID: Case ID
    :param str watcherID: Watcher ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers/{watcherID}".format(
        caseID=caseID, watcherID=watcherID
    )
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def remove_current_user_watcher(
    caseID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Remove the current user from the watchlist of this case.If the currentuser is a contact, this will override the contact settings for the current user for this case. (PUBLIC)

    :param int caseID: Case ID
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watch".format(caseID=caseID)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def request_workflow(
    caseID: int,
    workflow: str,
    comment: str = None,
    externalReference: str = None,
    publicComment: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Request new workflow on case (PUBLIC)

    :param int caseID: Case ID
    :param str workflow: Workflow to request
    :param str comment: Optional comment to add. Html is allowed\, will be sanitized.
    :param str externalReference: Optional external reference to add. Should be a link or an issue number.
    :param bool publicComment: If true\, the comment is marked as public\, and is made visible to customer.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows/{workflow}/request".format(
        caseID=caseID, workflow=workflow
    )
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send externalReference if the argument was provided, don't send null values
    if externalReference is not None:
        body.update({"externalReference": externalReference})
    # Only send publicComment if the argument was provided, don't send null values
    if publicComment is not None:
        body.update({"publicComment": publicComment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def search_case_statistics(
    accessMode: str = None,
    assetID: str = None,
    caseID: int = None,
    category: str = None,
    customer: str = None,
    customerID: int = None,
    cutoff: int = None,
    cutoffFields: dict = None,
    cutoffValue: str = None,
    endTimestamp: str = None,
    exclude: bool = None,
    excludeFlags: str = None,
    explicitAccess: dict = None,
    field: dict = None,
    groupBy: dict = None,
    includeDeleted: bool = None,
    includeDescription: bool = None,
    includeFlags: str = None,
    includeOthers: bool = None,
    includeTestData: bool = None,
    includeWorkflows: bool = None,
    initialPriority: str = None,
    initialStatus: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    keywords: str = None,
    limit: int = None,
    offset: int = None,
    priority: str = None,
    productionCustomers: bool = None,
    required: bool = None,
    resolution: int = None,
    service: str = None,
    serviceCriteria: dict = None,
    sortBy: str = None,
    sortByField: str = None,
    sortByValue: str = None,
    startTimestamp: str = None,
    status: str = None,
    subCriteria: dict = None,
    tag: dict = None,
    techAssigned: bool = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = None,
    type: str = None,
    user: str = None,
    userAssigned: bool = None,
    userFieldStrategy: str = None,
    userID: int = None,
    values: str = None,
    workflow: dict = None,
    resolutionUnit: str = "milliseconds",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Returns statistics data matching the defined CaseStatsSearchCriteria (PUBLIC)

    :param list accessMode: If set\, only match cases which is set to one of these access modes
    :param list assetID: Restrict search to cases associated with specified assets \(hosts\, services or processes\)
    :param list caseID: Restrict search to specific cases \(by ID\).
    :param list category: Restrict search to entries of one of these categories \(by category shortname or ID\).
    :param list customer: Restrict search to specific customers \(by ID or shortname\).
    :param list customerID: Restrict search to data belonging to specified customers.
    :param int cutoff: DEPRECATED. Use cutoff in groupBy instead.
    :param dict cutoffFields: DEPRECATED. Use field\/cutoff in groupBy instead. Reduce stats keys to max amount of distinct values per field. Fields which are not listed will not be reduced.
    :param str cutoffValue: DEPRECATED. Use cutoffValue in groupBy instead. Specify which value to be cutoff on \(default created\).
    :param str endTimestamp: Restrict search to data before this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param bool exclude: Only relevant for subcriteria. If set to true\, objects matching this subcriteria object will be excluded.
    :param list excludeFlags: Exclude objects which have excludeFlags set.
    :param list explicitAccess: If set\, only match cases which have explicit access grants matching the specified criteria
    :param list field: Restrict search to entries matching the given field criteria.
    :param list groupBy: Specify which keys\/fields will be used for grouping by in stats and which cutoffs\/cutoffValues will be applied
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param bool includeDescription: If false\, omit description from response. Default is true \(description is present\).
    :param list includeFlags: Only include objects which have includeFlags set.
    :param bool includeOthers: If reduce \(cutoff\>0\)\, true means remaining keys \(other than cutoff keys\) are collected into an \"other\" key\, default false
    :param bool includeTestData: If true\, also include cases marked as TEST\_DATA in search result. This option is restricted to users with permission viewCaseTestData. Default is false \(excluded\).
    :param bool includeWorkflows: If true\, include list of workflows in result. Default is false \(not present\).
    :param list initialPriority: Restrict search to entries where the initial priority is one of these priorties
    :param list initialStatus: Restrict search to entries where the initial status is one of these statuses.
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\).
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords \(default match all keywords\).
    :param list keywords: Search for keywords.
    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param list priority: Restrict search to entries with given priorties
    :param bool productionCustomers: If set\, apply a customer filter for customers marked as \'not in production\'. If true\, EXCLUDE customers \'not in production\'. If false\, REQUIRE customers \'not in production\'. Default is unset \(no filter on production customers\).
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param int resolution: DEPRECATED. Timeline queries are no longer supported by this api. Stats resolution period \(unit specified by resolutionUnit\)\, if is 0 means to generate non\-timeline statistics
    :param list service: This option is deprecated\, use serviceCriteria instead.
    :param dict serviceCriteria:
    :param list sortBy:
    :param str sortByField: If set\, sort by this field. The returned field must be in the groupBy list. If not set\, the container will be sorted by value.
    :param str sortByValue: If set\, sort by this value \(descending by value\). The specified value must be in the values list. If not set\, it defaults to the first returned value. This field cannot be set if sortByField id set..
    :param str startTimestamp: Restrict search to data after this time \(epoch millis\) according to selected TimeFieldStrategies. Allows unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time specifies. See https\:\/\/docs.mnemonic.no\/x\/AQDXAQ  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param list status: Restrict search to entries of one of these statuses.
    :param list subCriteria: Set additional criterias which are applied using a logical OR.
    :param list tag: Restrict search to entries matching the given tag criteria.
    :param bool techAssigned: If set\, limit search to cases where assignedTech field is set\/unset
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default all\).
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list type: Restrict search to entries of one of these types.
    :param list user: Restrict search to cases associated with these users or user groups \(by ID or shortname\).
    :param bool userAssigned: If set\, limit search to cases where assignedUser field is set\/unset
    :param list userFieldStrategy: Defines which user fields will be searched \(default match all user fields\).
    :param list userID: This field is deprecated. Use field \'user\' instead.
    :param list values: Specify which values will be included in stats \(default created\)
    :param list workflow: Restrict search to entries matching the given workflow criteria.
    :param str resolutionUnit: DEPRECATED. Timeline queries are no longer supported by this api. Stats resolution period time unit.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/stats".format()
    headers = {}

    body = body or {}
    # Only send accessMode if the argument was provided, don't send null values
    if accessMode is not None:
        body.update({"accessMode": accessMode})
    # Only send assetID if the argument was provided, don't send null values
    if assetID is not None:
        body.update({"assetID": assetID})
    # Only send caseID if the argument was provided, don't send null values
    if caseID is not None:
        body.update({"caseID": caseID})
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send cutoff if the argument was provided, don't send null values
    if cutoff is not None:
        body.update({"cutoff": cutoff})
    # Only send cutoffFields if the argument was provided, don't send null values
    if cutoffFields is not None:
        body.update({"cutoffFields": cutoffFields})
    # Only send cutoffValue if the argument was provided, don't send null values
    if cutoffValue is not None:
        body.update({"cutoffValue": cutoffValue})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send explicitAccess if the argument was provided, don't send null values
    if explicitAccess is not None:
        body.update({"explicitAccess": explicitAccess})
    # Only send field if the argument was provided, don't send null values
    if field is not None:
        body.update({"field": field})
    # Only send groupBy if the argument was provided, don't send null values
    if groupBy is not None:
        body.update({"groupBy": groupBy})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeDescription if the argument was provided, don't send null values
    if includeDescription is not None:
        body.update({"includeDescription": includeDescription})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send includeOthers if the argument was provided, don't send null values
    if includeOthers is not None:
        body.update({"includeOthers": includeOthers})
    # Only send includeTestData if the argument was provided, don't send null values
    if includeTestData is not None:
        body.update({"includeTestData": includeTestData})
    # Only send includeWorkflows if the argument was provided, don't send null values
    if includeWorkflows is not None:
        body.update({"includeWorkflows": includeWorkflows})
    # Only send initialPriority if the argument was provided, don't send null values
    if initialPriority is not None:
        body.update({"initialPriority": initialPriority})
    # Only send initialStatus if the argument was provided, don't send null values
    if initialStatus is not None:
        body.update({"initialStatus": initialStatus})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send resolution if the argument was provided, don't send null values
    if resolution is not None:
        body.update({"resolution": resolution})
    # Only send resolutionUnit if the argument was provided, don't send null values
    if resolutionUnit is not None:
        body.update({"resolutionUnit": resolutionUnit})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        body.update({"service": service})
    # Only send serviceCriteria if the argument was provided, don't send null values
    if serviceCriteria is not None:
        body.update({"serviceCriteria": serviceCriteria})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send sortByField if the argument was provided, don't send null values
    if sortByField is not None:
        body.update({"sortByField": sortByField})
    # Only send sortByValue if the argument was provided, don't send null values
    if sortByValue is not None:
        body.update({"sortByValue": sortByValue})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send tag if the argument was provided, don't send null values
    if tag is not None:
        body.update({"tag": tag})
    # Only send techAssigned if the argument was provided, don't send null values
    if techAssigned is not None:
        body.update({"techAssigned": techAssigned})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userAssigned if the argument was provided, don't send null values
    if userAssigned is not None:
        body.update({"userAssigned": userAssigned})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userID if the argument was provided, don't send null values
    if userID is not None:
        body.update({"userID": userID})
    # Only send values if the argument was provided, don't send null values
    if values is not None:
        body.update({"values": values})
    # Only send workflow if the argument was provided, don't send null values
    if workflow is not None:
        body.update({"workflow": workflow})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def set_field(
    caseID: int,
    field: str,
    source: str = None,
    value: str = None,
    valuesToAdd: str = None,
    valuesToRemove: str = None,
    valuesToSet: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Set specific field for a case, by either field ID or field name. For multivalue fields, the field may contain multiple values. (INTERNAL)

    :param int caseID: ID of the case to set fields for
    :param str field: ID or fieldName of the field to set
    :param str source: An origin source string to set on the added value\(s\).
    :param str value: Value to set on field. Multivalue fields will reject requests using this parameter.
    :param list valuesToAdd: Value to add to a multivalue field. Existing values will be retained. Singlevalue fields will reject requests using this parameter.
    :param list valuesToRemove: Value to remove from a multivalue field. Singlevalue fields will reject requests using this parameter. May be the exact value\, or reference using the value ID.
    :param list valuesToSet: Value to set on a multivalue field. Existing values will be discarded. Singlevalue fields will reject requests using this parameter.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/fields/{field}".format(caseID=caseID, field=field)
    headers = {}

    body = body or {}
    # Only send source if the argument was provided, don't send null values
    if source is not None:
        body.update({"source": source})
    # Only send value if the argument was provided, don't send null values
    if value is not None:
        body.update({"value": value})
    # Only send valuesToAdd if the argument was provided, don't send null values
    if valuesToAdd is not None:
        body.update({"valuesToAdd": valuesToAdd})
    # Only send valuesToRemove if the argument was provided, don't send null values
    if valuesToRemove is not None:
        body.update({"valuesToRemove": valuesToRemove})
    # Only send valuesToSet if the argument was provided, don't send null values
    if valuesToSet is not None:
        body.update({"valuesToSet": valuesToSet})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def simple_case_search(
    customerID: int = None,
    customer: str = None,
    service: str = None,
    status: str = None,
    type: str = None,
    keywords: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns cases matching the query parameters (PUBLIC)

    :param list customerID: DEPRECATED. Use customer instead
    :param list customer: Limit result to specified customers \(by id or shortname\)
    :param list service: Limit result to specified services \(service shortname\)
    :param list status: Limit result to specified statuses
    :param list type: Limit result to specified types
    :param list keywords: Search by keywords
    :param list sortBy: Sort order \(see \/cases\/v2\/case\/search documentation for details\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/cases/v2/case".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send service if the argument was provided, don't send null values
    if service is not None:
        query_parameters.update({"service": service})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        query_parameters.update({"status": status})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        query_parameters.update({"type": type})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def update_case(
    id: int,
    subject: str = None,
    description: str = None,
    status: str = None,
    priority: str = None,
    category: str = None,
    reporter: str = None,
    assignedUser: str = None,
    assignedTech: str = None,
    customerDueTimestamp: int = None,
    techDueTimestamp: int = None,
    customerReference: str = None,
    comment: str = None,
    notification: dict = None,
    originEmailAddress: str = None,
    triggers: dict = None,
    hasEvents: bool = None,
    reporterID: dict = None,
    assignedUserID: dict = None,
    assignedTechID: dict = None,
    internalComment: bool = None,
    textFormat: str = "html",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Request changes to basic fields of an existing case (PUBLIC)

    :param int id: Case ID
    :param str subject: If set\, change subject of case.
    :param str description: If set\, change description of case. May use HTML\, will be sanitized.
    :param str status: If set\, change status of case
    :param str priority: If set\, change priority of case.
    :param str category: If set\, assign given category to specified category \(by category shortname\). Set value to empty string to unset category. Deprecated categories can\'t be used as a new value.
    :param str reporter: If set\, set given user as reporter for case \(by ID or shortname\). Shortname will be resolved in the current users domain.
    :param str assignedUser: If set\, assign given user to case \(by ID or shortname\). Shortname will be resolved in the current users domain. If blank\, this will unset assignedUser.
    :param str assignedTech: If set\, assign given technical user \(solution engineer\) to case \(by ID or shortname\). Shortname will be resolved in the current users domain. If blank\, this will unset assignedTech.
    :param int customerDueTimestamp:
    :param int techDueTimestamp:
    :param str customerReference: If set\, change customer reference for case.
    :param str comment: If set\, add comment to case. May use HTML\, will be sanitized.
    :param dict notification:
    :param str originEmailAddress: If update is made from an email\, specify origin email address here \[format\:email\]
    :param dict triggers:
    :param bool hasEvents: If set\, update the hasEvents flag for this case\, signalling that this case may have events associated to it.
    :param dict reporterID:
    :param dict assignedUserID:
    :param dict assignedTechID:
    :param bool internalComment: If true\, add comment as internal.
    :param str textFormat: Specify the text format of this comment. Setting plainText gives other consumers a hint that contents does not require a HTML renderer.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{id}".format(id=id)
    headers = {}

    body = body or {}
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send status if the argument was provided, don't send null values
    if status is not None:
        body.update({"status": status})
    # Only send priority if the argument was provided, don't send null values
    if priority is not None:
        body.update({"priority": priority})
    # Only send category if the argument was provided, don't send null values
    if category is not None:
        body.update({"category": category})
    # Only send reporter if the argument was provided, don't send null values
    if reporter is not None:
        body.update({"reporter": reporter})
    # Only send assignedUser if the argument was provided, don't send null values
    if assignedUser is not None:
        body.update({"assignedUser": assignedUser})
    # Only send assignedTech if the argument was provided, don't send null values
    if assignedTech is not None:
        body.update({"assignedTech": assignedTech})
    # Only send customerDueTimestamp if the argument was provided, don't send null values
    if customerDueTimestamp is not None:
        body.update({"customerDueTimestamp": customerDueTimestamp})
    # Only send techDueTimestamp if the argument was provided, don't send null values
    if techDueTimestamp is not None:
        body.update({"techDueTimestamp": techDueTimestamp})
    # Only send customerReference if the argument was provided, don't send null values
    if customerReference is not None:
        body.update({"customerReference": customerReference})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send internalComment if the argument was provided, don't send null values
    if internalComment is not None:
        body.update({"internalComment": internalComment})
    # Only send notification if the argument was provided, don't send null values
    if notification is not None:
        body.update({"notification": notification})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        body.update({"originEmailAddress": originEmailAddress})
    # Only send triggers if the argument was provided, don't send null values
    if triggers is not None:
        body.update({"triggers": triggers})
    # Only send hasEvents if the argument was provided, don't send null values
    if hasEvents is not None:
        body.update({"hasEvents": hasEvents})
    # Only send textFormat if the argument was provided, don't send null values
    if textFormat is not None:
        body.update({"textFormat": textFormat})
    # Only send reporterID if the argument was provided, don't send null values
    if reporterID is not None:
        body.update({"reporterID": reporterID})
    # Only send assignedUserID if the argument was provided, don't send null values
    if assignedUserID is not None:
        body.update({"assignedUserID": assignedUserID})
    # Only send assignedTechID if the argument was provided, don't send null values
    if assignedTechID is not None:
        body.update({"assignedTechID": assignedTechID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def update_case_watcher(
    caseID: int,
    watcherID: str,
    verbose: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update settings for a specific watcher on a case (PUBLIC)

    :param int caseID: Case ID
    :param str watcherID: Watcher ID
    :param bool verbose: If set\, will enable\/disable verbose status for this watcher.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers/{watcherID}".format(
        caseID=caseID, watcherID=watcherID
    )
    headers = {}

    body = body or {}
    # Only send verbose if the argument was provided, don't send null values
    if verbose is not None:
        body.update({"verbose": verbose})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def update_watcher_settings(
    caseID: int,
    defaultWatchers: bool,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update general watcher settings on a case (PUBLIC)

    :param int caseID: Case ID
    :param bool defaultWatchers: If set\, will enable\/disable use of default watchers on this case.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/watchers".format(caseID=caseID)
    headers = {}

    body = body or {}
    # Only send defaultWatchers if the argument was provided, don't send null values
    if defaultWatchers is not None:
        body.update({"defaultWatchers": defaultWatchers})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def update_workflow(
    caseID: int,
    workflow: str,
    acknowledgedComment: str = None,
    externalReference: str = None,
    requestComment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update workflow on case (PUBLIC)

    :param int caseID: Case ID
    :param str workflow: Workflow to update
    :param str acknowledgedComment: If set\, modify acknowledged comment. Html is allowed\, will be sanitized. \[format\:html\]
    :param str externalReference: If set\, modify external reference. Should be a link or an issue number. Empty string will delete existing reference.
    :param str requestComment: If set\, modify request comment. Html is allowed\, will be sanitized. \[format\:html\]
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/workflows/{workflow}".format(
        caseID=caseID, workflow=workflow
    )
    headers = {}

    body = body or {}
    # Only send acknowledgedComment if the argument was provided, don't send null values
    if acknowledgedComment is not None:
        body.update({"acknowledgedComment": acknowledgedComment})
    # Only send externalReference if the argument was provided, don't send null values
    if externalReference is not None:
        body.update({"externalReference": externalReference})
    # Only send requestComment if the argument was provided, don't send null values
    if requestComment is not None:
        body.update({"requestComment": requestComment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def upload_attachment_fragment(
    caseID: int,
    attachmentID: str,
    idx: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Upload fragment of an attachment (PUBLIC)

    :param int caseID: Case ID
    :param str attachmentID: Attachment ID
    :param int idx: Attachment Fragment Index
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/{attachmentID}/fragment/{idx}".format(
        caseID=caseID, attachmentID=attachmentID, idx=idx
    )
    headers = {}

    body = body or {}

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("cases", "v2", "case"), module=argus_cli_module)
def upload_streaming_attachment(
    caseID: int,
    filename: str,
    encryptedZip: bool = None,
    skipNotification: bool = None,
    originEmailAddress: str = None,
    encryptedZipMode: str = "none",
    encryptedZipPassword: str = "argus",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add new attachment (PUBLIC)

    :param int caseID: Case ID
    :param str filename: Attachment filename
    :param bool encryptedZip: This option is deprecated\, use encryptedZipMode instead
    :param bool skipNotification: If true\, skip notification
    :param str originEmailAddress: If set\, mark attachment with this origin email address
    :param str encryptedZipMode: Use mode \'client\' to mark attachment as an encrypted zipfile. Use mode \'server\' to request server\-side encryption
    :param str encryptedZipPassword: Use this to document the password used for zip encryption
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/cases/v2/case/{caseID}/attachments/upload/{filename}".format(
        caseID=caseID, filename=filename
    )
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send encryptedZipMode if the argument was provided, don't send null values
    if encryptedZipMode is not None:
        query_parameters.update({"encryptedZipMode": encryptedZipMode})
    # Only send encryptedZipPassword if the argument was provided, don't send null values
    if encryptedZipPassword is not None:
        query_parameters.update({"encryptedZipPassword": encryptedZipPassword})
    # Only send encryptedZip if the argument was provided, don't send null values
    if encryptedZip is not None:
        query_parameters.update({"encryptedZip": encryptedZip})
    # Only send skipNotification if the argument was provided, don't send null values
    if skipNotification is not None:
        query_parameters.update({"skipNotification": skipNotification})
    # Only send originEmailAddress if the argument was provided, don't send null values
    if originEmailAddress is not None:
        query_parameters.update({"originEmailAddress": originEmailAddress})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
