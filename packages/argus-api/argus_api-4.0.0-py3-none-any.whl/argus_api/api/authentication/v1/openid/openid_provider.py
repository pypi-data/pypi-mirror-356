"""Autogenerated API"""
from argus_api import session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
log = logging.getLogger(__name__)


@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def add_open_id_provider(
    shortName: str = None,
    name: str = None,
    clientID: str = None,
    customer: str = None,
    certificate: str = None,
    providerURI: str = None,
    claimsMapping: dict = None,
    responseType: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Define new OpenID provider (DEV)
    
    :param str shortName: Set a shortname for this provider  \=\> \[a\-zA\-Z0\-9\_\\\-\\.\]\*
    :param str name: The name of this provider  \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str clientID: The OAuth ClientID of this provider 
    :param str customer: The id or shortname of the customer this provider is bound to 
    :param str certificate: A valid X509 certificate which can be used to verify OpenID tokens 
    :param str providerURI: The URI to redirect to to initiate OpenID authentication flow  \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param dict claimsMapping: 
    :param str responseType: Define response type to request from provider \(default idToken\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises InvalidArgumentException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send clientID if the argument was provided, dont send null values
    if clientID is not None:
        body.update({"clientID": clientID})
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send certificate if the argument was provided, dont send null values
    if certificate is not None:
        body.update({"certificate": certificate})
    # Only send providerURI if the argument was provided, dont send null values
    if providerURI is not None:
        body.update({"providerURI": providerURI})
    # Only send claimsMapping if the argument was provided, dont send null values
    if claimsMapping is not None:
        body.update({"claimsMapping": claimsMapping})
    # Only send responseType if the argument was provided, dont send null values
    if responseType is not None:
        body.update({"responseType": responseType})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def delete_open_id_provider(
    idOrShortname: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Delete OpenID provider (DEV)
    
    :param str idOrShortname: ID or shortname of provider to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}".format(idOrShortname=idOrShortname)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    log.debug("DELETE %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def get_open_id_provider(
    idOrShortname: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Fetch OpenID provider (DEV)
    
    :param str idOrShortname: ID or shortname of provider to fetch
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}".format(idOrShortname=idOrShortname)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def list_open_id_providers(
    customer: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """List OpenID providers (DEV)
    
    :param list customer: Limit results to providers for this customer \(or subcustomers\)
    :param list keywords: Limit results to providers matching these keywords
    :param list sortBy: Specify sort order
    :param int limit: Limit number of results
    :param int offset: Skip a number of results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider".format(limit=limit,
        customer=customer,
        keywords=keywords,
        sortBy=sortBy,
        offset=offset)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})
    
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def open_id_authentication(
    provider: str,
    idToken: str = None,
    requestedAuthorizations: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Submit OpenID token for validation to create a new user session (DEV)
    
    :param str provider: ID or shortname of OpenID provider
    :param str idToken: ID token from provider 
    :param list requestedAuthorizations: Allow client to request authorizations as part of the authentication transaction. The client is not guaranteed to get the requested authorizations. The setPassword authorization is only returned if the current user has the FORCE\_PW\_CHANGE flag set. 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{provider}/authentication".format(provider=provider)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send idToken if the argument was provided, dont send null values
    if idToken is not None:
        body.update({"idToken": idToken})
    # Only send requestedAuthorizations if the argument was provided, dont send null values
    if requestedAuthorizations is not None:
        body.update({"requestedAuthorizations": requestedAuthorizations})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def open_id_pre_authentication(
    provider: str,
    state: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Request redirect URI to OpenID provider (DEV)
    
    :param str provider: ID or shortname of OpenID provider
    :param str state: State to retain
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises InvalidArgumentException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{provider}/authentication".format(provider=provider,
        state=state)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}

    query_parameters = {}
    # Only send state if the argument was provided, dont send null values
    if state is not None:
        query_parameters.update({"state": state})
    
    log.debug("GET %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def search_open_id_providers(
    customer: str = None,
    keywords: str = None,
    sortBy: str = None,
    limit: int = 25,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Search OpenID providers (DEV)
    
    :param list customer: Limit result by customer ID or shortname 
    :param list keywords: Match providers by keywords 
    :param list sortBy: Specify sort order \(default shortName\)
    :param int limit: Limit the number of results \(default 25\)
    :param int offset: Skip the first results\, in sort order \(default 0\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/search".format()

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send customer if the argument was provided, dont send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send keywords if the argument was provided, dont send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, dont send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, dont send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, dont send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})

    query_parameters = {}
    log.debug("POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.post(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response

@register_command(
    extending=("authentication", "v1", "openid", "provider"),
    module=argus_cli_module
)
def update_open_id_provider(
    idOrShortname: str,
    shortName: str = None,
    name: str = None,
    clientID: str = None,
    certificate: str = None,
    providerURI: str = None,
    responseType: str = None,
    claimsMapping: dict = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    """Update OpenID provider (DEV)
    
    :param str idOrShortname: ID or shortname of provider to update
    :param str shortName: If set\, update the shortname for this provider  \=\> \[a\-zA\-Z0\-9\_\\\-\\.\]\*
    :param str name: If set\, update the name for this provider  \=\> \[\\s\\w\\\{\\\}\\\$\\\-\\\(\\\)\\.\\\[\\\]\"\\\'\_\/\\\\\,\\\*\\\+\\\#\:\@\!\?\;\=\]\*
    :param str clientID: If set\, update the OAuth ClientID for this provider 
    :param str certificate: If set\, update the X509 certificate for this provider 
    :param str providerURI: If set\, update the URI for this provider  \=\> \(\(https\?\|ftp\|gopher\|telnet\|file\)\:\(\(\/\)\|\(\\\\\)\)\+\[\\w\\d\:\\\#\@\%\/\;\$\(\)\~\_\?\\\\\+\-\=\\\\\\.\&\]\*\)
    :param str responseType: If set\, update the response type to request from provider 
    :param dict claimsMapping: 
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises InvalidArgumentsException: on 412
    :raises ArgusException: on other status codes
    
    :returns: dictionary translated from JSON
    """

    route = "/authentication/v1/openid/provider/{idOrShortname}".format(idOrShortname=idOrShortname)

    headers = {
        'User-Agent': 'ArgusToolbelt/',
    }

    body = body or {}
    # Only send shortName if the argument was provided, dont send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send name if the argument was provided, dont send null values
    if name is not None:
        body.update({"name": name})
    # Only send clientID if the argument was provided, dont send null values
    if clientID is not None:
        body.update({"clientID": clientID})
    # Only send certificate if the argument was provided, dont send null values
    if certificate is not None:
        body.update({"certificate": certificate})
    # Only send providerURI if the argument was provided, dont send null values
    if providerURI is not None:
        body.update({"providerURI": providerURI})
    # Only send responseType if the argument was provided, dont send null values
    if responseType is not None:
        body.update({"responseType": responseType})
    # Only send claimsMapping if the argument was provided, dont send null values
    if claimsMapping is not None:
        body.update({"claimsMapping": claimsMapping})

    query_parameters = {}
    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
