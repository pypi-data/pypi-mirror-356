"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("events", "v1", "nids"), module=argus_cli_module)
def find_nids_events(
    limit: int = None,
    offset: int = None,
    includeDeleted: bool = None,
    customerID: int = None,
    exclude: bool = None,
    required: bool = None,
    eventIdentifier: dict = None,
    locationID: int = None,
    severity: str = None,
    customer: str = None,
    alarmID: int = None,
    attackCategoryID: int = None,
    sourceGeoCountry: str = None,
    destinationGeoCountry: str = None,
    geoCountry: str = None,
    domain: str = None,
    properties: dict = None,
    productionCustomers: bool = None,
    sensorID: int = None,
    subCriteria: dict = None,
    timeFieldStrategy: str = None,
    signature: str = None,
    endTimestamp: int = None,
    startTimestamp: int = None,
    sortBy: str = None,
    excludeFlag: dict = None,
    includeFlag: dict = None,
    includeFlags: str = None,
    excludeFlags: str = None,
    lastUpdatedTimestamp: int = None,
    indexStartTime: int = None,
    indexEndTime: int = None,
    destinationIP: str = None,
    sourceIP: str = None,
    ip: str = None,
    destinationPort: str = None,
    sourcePort: str = None,
    port: str = None,
    minSeverity: str = None,
    maxSeverity: str = None,
    skipFutureEvents: bool = None,
    exactMatchProperties: bool = True,
    multivaluePropertySeparator: str = "comma",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Search for NIDS events (PUBLIC)

    :param int limit: Limit results
    :param int offset: Offset results
    :param bool includeDeleted: Also include deleted objects \(where implemented\)
    :param list customerID: DEPRECATED\! Use customer instead
    :param bool exclude: Exclude these criteria from the parent criteria.
    :param bool required: Only relevant for subcriteria. If set to true\, objects matching this subcriteria are required \(AND\-ed together with parent criteria\).
    :param list eventIdentifier: Search for events specified by full ID \(type\/timestamp\/customerID\/eventID\).
    :param list locationID: Search for events having these locations.
    :param list severity: Search events with specified severity. Can\'t be used together with minSeverity\/maxSeverity.
    :param list customer: Search for events by customer \(id or shortname\).
    :param list alarmID: Search for events having an attack identifier \(signature\) mapped to any of these alarms.
    :param list attackCategoryID: Search for events having an attack identifier \(signature\) mapped to any of these categories.
    :param list sourceGeoCountry: Search for events where source IP is registered in any of these countries.
    :param list destinationGeoCountry: Search for events where destination IP is registered in any of these countries.
    :param list geoCountry: Search for events where source or destination IP is registered in any of these countries.
    :param list domain: Search for events having one of these domains. The domains are not validated
    :param dict properties: Search for events having these properties \(logical AND\).
    :param bool productionCustomers: If set\, apply a customer filter for customers marked as \'not in production\'. If true\, EXCLUDE customers \'not in production\'. If false\, REQUIRE customers \'not in production\'. Default is unset \(no filter on production customers\).
    :param list sensorID: List of sensor IDs that must have a match in the retrieved event.
    :param list subCriteria: Subcriterias used to refine the search by including or excluding events.
    :param list timeFieldStrategy: Defines which timestamps will be included in the search\, will default to timestamp.
    :param list signature:
    :param int endTimestamp: Search objects until this timestamp
    :param int startTimestamp: Search objects from this timestamp
    :param list sortBy: Order results by these properties \(prefix with \- to sort descending\)
    :param dict excludeFlag:
    :param dict includeFlag:
    :param list includeFlags: Search objects with these flags set
    :param list excludeFlags: Exclude objects with these flags set
    :param int lastUpdatedTimestamp: Match only with events marked with a last updated time greater or equal to this.
    :param int indexStartTime: Earliest created time of the indices searched.
    :param int indexEndTime: Last created time of the indices searched.
    :param list destinationIP:
    :param list sourceIP:
    :param list ip:
    :param list destinationPort:
    :param list sourcePort:
    :param list port:
    :param str minSeverity:
    :param str maxSeverity:
    :param bool skipFutureEvents: Whether service should generate endTimestamp by current timestamp.
    :param bool exactMatchProperties: If set to true\, will execute in\-memory filtering to only match events that have exact match of properties specified at top level \"properties\" field of search request. WARN\: The count of response would not be reliable\, as the filtering is applied in\-memory of application server\, but the count was done by search engine.
    :param str multivaluePropertySeparator: Separator that is going to be used when formatting the multi\-value properties of the found events.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v1/nids/search".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        body.update({"customerID": customerID})
    # Only send skipFutureEvents if the argument was provided, don't send null values
    if skipFutureEvents is not None:
        body.update({"skipFutureEvents": skipFutureEvents})
    # Only send exclude if the argument was provided, don't send null values
    if exclude is not None:
        body.update({"exclude": exclude})
    # Only send required if the argument was provided, don't send null values
    if required is not None:
        body.update({"required": required})
    # Only send eventIdentifier if the argument was provided, don't send null values
    if eventIdentifier is not None:
        body.update({"eventIdentifier": eventIdentifier})
    # Only send locationID if the argument was provided, don't send null values
    if locationID is not None:
        body.update({"locationID": locationID})
    # Only send severity if the argument was provided, don't send null values
    if severity is not None:
        body.update({"severity": severity})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send alarmID if the argument was provided, don't send null values
    if alarmID is not None:
        body.update({"alarmID": alarmID})
    # Only send attackCategoryID if the argument was provided, don't send null values
    if attackCategoryID is not None:
        body.update({"attackCategoryID": attackCategoryID})
    # Only send sourceGeoCountry if the argument was provided, don't send null values
    if sourceGeoCountry is not None:
        body.update({"sourceGeoCountry": sourceGeoCountry})
    # Only send destinationGeoCountry if the argument was provided, don't send null values
    if destinationGeoCountry is not None:
        body.update({"destinationGeoCountry": destinationGeoCountry})
    # Only send geoCountry if the argument was provided, don't send null values
    if geoCountry is not None:
        body.update({"geoCountry": geoCountry})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send productionCustomers if the argument was provided, don't send null values
    if productionCustomers is not None:
        body.update({"productionCustomers": productionCustomers})
    # Only send exactMatchProperties if the argument was provided, don't send null values
    if exactMatchProperties is not None:
        body.update({"exactMatchProperties": exactMatchProperties})
    # Only send multivaluePropertySeparator if the argument was provided, don't send null values
    if multivaluePropertySeparator is not None:
        body.update({"multivaluePropertySeparator": multivaluePropertySeparator})
    # Only send sensorID if the argument was provided, don't send null values
    if sensorID is not None:
        body.update({"sensorID": sensorID})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        body.update({"signature": signature})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        body.update({"excludeFlag": excludeFlag})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        body.update({"includeFlag": includeFlag})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send lastUpdatedTimestamp if the argument was provided, don't send null values
    if lastUpdatedTimestamp is not None:
        body.update({"lastUpdatedTimestamp": lastUpdatedTimestamp})
    # Only send indexStartTime if the argument was provided, don't send null values
    if indexStartTime is not None:
        body.update({"indexStartTime": indexStartTime})
    # Only send indexEndTime if the argument was provided, don't send null values
    if indexEndTime is not None:
        body.update({"indexEndTime": indexEndTime})
    # Only send destinationIP if the argument was provided, don't send null values
    if destinationIP is not None:
        body.update({"destinationIP": destinationIP})
    # Only send sourceIP if the argument was provided, don't send null values
    if sourceIP is not None:
        body.update({"sourceIP": sourceIP})
    # Only send ip if the argument was provided, don't send null values
    if ip is not None:
        body.update({"ip": ip})
    # Only send destinationPort if the argument was provided, don't send null values
    if destinationPort is not None:
        body.update({"destinationPort": destinationPort})
    # Only send sourcePort if the argument was provided, don't send null values
    if sourcePort is not None:
        body.update({"sourcePort": sourcePort})
    # Only send port if the argument was provided, don't send null values
    if port is not None:
        body.update({"port": port})
    # Only send minSeverity if the argument was provided, don't send null values
    if minSeverity is not None:
        body.update({"minSeverity": minSeverity})
    # Only send maxSeverity if the argument was provided, don't send null values
    if maxSeverity is not None:
        body.update({"maxSeverity": maxSeverity})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("events", "v1", "nids"), module=argus_cli_module)
def list_nids_events(
    customerID: int = None,
    signature: str = None,
    ip: dict = None,
    startTimestamp: str = "-24hours",
    endTimestamp: str = "now",
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Simple search for NIDS events (PUBLIC)

    :param list customerID: Limit to customerID
    :param list signature: Limit to signature
    :param list ip: Limit to ip\/network
    :param str startTimestamp: Limit to events after this timestamp \(default is last 24 hours\).
    :param str endTimestamp: Limit to events before this timestamp.
    :param int limit: Limit results
    :param int offset: Offset results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/events/v1/nids".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    query_parameters = {}
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send customerID if the argument was provided, don't send null values
    if customerID is not None:
        query_parameters.update({"customerID": customerID})
    # Only send signature if the argument was provided, don't send null values
    if signature is not None:
        query_parameters.update({"signature": signature})
    # Only send ip if the argument was provided, don't send null values
    if ip is not None:
        query_parameters.update({"ip": ip})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
