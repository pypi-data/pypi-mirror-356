"""Autogenerated API"""
from argus_api.session import get_session as _get_session
from typing import TYPE_CHECKING, Optional

if TYPE_CHECKING:
    from argus_api.session import ArgusAPISession
from requests import Response


def add_customer(
    name: str,
    parent: str,
    shortName: str,
    domain: str = None,
    excludeFromProduction: bool = None,
    language: str = None,
    networkBaseCustomer: bool = None,
    singleNetworkDomain: bool = None,
    timeZone: str = None,
    type: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Create a new customer (PUBLIC)

    :param str name: Name of the new customer
    :param str parent: Short name or id of the customers parent.
    :param str shortName: Short name of the new customer
    :param str domain: Domain of the parent. If not set\, the parent will be resolved in the current users domain.
    :param bool excludeFromProduction: Mark customer as excluded from production. \(default false\)
    :param str language: Preferred language.
    :param bool networkBaseCustomer: Whether enable customer as base customer for a customer group\, used for remapping events’ customer by network CIDR among sub\-customers that belong to same customer group \(group must be SINGLE\_NETWORK\_DOMAIN flagged\)\, cannot be set for group customer\, and once enabled the customer cannot be promoted to group unless disable it. \(default false\)
    :param bool singleNetworkDomain: Whether enable customer group option for remapping events’ customer by network CIDR among its sub\-customers\, cannot be set for non\-group customer\, and once enabled the customer group cannot be changed to non\-group customer unless disable it. \(default false\)
    :param str timeZone: Customer\'s timezone id or string. Defaults to Europe\/Oslo.
    :param str type: Type of customer.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send excludeFromProduction if the argument was provided, don't send null values
    if excludeFromProduction is not None:
        body.update({"excludeFromProduction": excludeFromProduction})
    # Only send language if the argument was provided, don't send null values
    if language is not None:
        body.update({"language": language})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send networkBaseCustomer if the argument was provided, don't send null values
    if networkBaseCustomer is not None:
        body.update({"networkBaseCustomer": networkBaseCustomer})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send singleNetworkDomain if the argument was provided, don't send null values
    if singleNetworkDomain is not None:
        body.update({"singleNetworkDomain": singleNetworkDomain})
    # Only send timeZone if the argument was provided, don't send null values
    if timeZone is not None:
        body.update({"timeZone": timeZone})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def disable_customer(
    idOrShortName: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Disable customer. (PUBLIC)

    :param str idOrShortName: Customer id or shortname
    :param str domain: Customer domain
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/disable".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_customer(
    idOrShortName: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a Customer identified by its ID or short name. (PUBLIC)

    :param str idOrShortName: Customer ID or short name
    :param str domain: Customer domain to lookup short name \(defaults to current users domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_customer_logo(
    idOrShortName: str,
    domain: str = None,
    size: str = None,
    includeDefault: bool = True,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> Response:
    r"""Returns a Customer logo by customer shortname or id. (PUBLIC)

    :param str idOrShortName: Customer ID or shortName
    :param str domain: Customer domain to lookup shortname \(defaults to current users domain\)
    :param str size: The max size of the logo \(small\, medium\, large\, xlarge\). Will resize the logo within the selected size\, retaining aspect ratio.
    :param bool includeDefault: Include default logo
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/customeradmin/v2/customer/{idOrShortName}/logo".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}
    headers["content"] = None

    query_parameters = {}
    # Only send includeDefault if the argument was provided, don't send null values
    if includeDefault is not None:
        query_parameters.update({"includeDefault": includeDefault})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send size if the argument was provided, don't send null values
    if size is not None:
        query_parameters.update({"size": size})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


def get_customer_properties(
    idOrShortName: str,
    domain: str = None,
    key: str = None,
    section: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a set of properties for the customer id or shortName by property name. (PUBLIC)

    :param str idOrShortName: Customer ID or shortName
    :param str domain: Customer domain to lookup shortname \(defaults to current users domain\)
    :param list key: Filter for specific properties.
    :param list section: Filter for properties in specific sections.
    :param int offset: By how many records to offset results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/properties".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})
    # Only send section if the argument was provided, don't send null values
    if section is not None:
        query_parameters.update({"section": section})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def get_customer_user_roles(
    idOrShortName: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a set of User roles for the customer id or shortName. (PUBLIC)

    :param str idOrShortName: Customer ID or shortName
    :param str domain: Customer domain to lookup user \(defaults to current users domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/userroles".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def list_customers(
    parent: str = None,
    keywords: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns customers defined by query parameters (PUBLIC)

    :param list parent: Search by parent id or shortName
    :param list keywords: Search by keywords
    :param list sortBy: Sort search result
    :param int offset: By how many records to offset results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer".format()

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        query_parameters.update({"parent": parent})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def move_customer(
    idOrShortName: str,
    parent: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Move customer to a different parent. (PUBLIC)

    :param str idOrShortName: Customer ID or shortname
    :param str parent: The name or ID of the new parent to move the customer to.
    :param str domain: ID or shortname of domain to lookup customer in
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/move".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def prune_customer_data(
    idOrShortName: str,
    domain: str = None,
    token: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Trigger customer data pruning. Requires a authorization token for operation 'pruneCustomerData' with context variable 'customerID', to prove that the current user has authorized this operation. (PUBLIC)

    :param str idOrShortName: Customer id or shortname
    :param str domain: Customer domain
    :param str token: Authorization token
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/data".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send token if the argument was provided, don't send null values
    if token is not None:
        query_parameters.update({"token": token})

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def reenable_customer(
    idOrShortName: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Reenable customer. (PUBLIC)

    :param str idOrShortName: Customer ID or shortname
    :param str domain: Customer domain
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/reenable".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def remove_customer_properties(
    idOrShortName: str,
    key: str,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a set of all current properties for the customer id or shortName, after the values for specified keys have been deleted. (PUBLIC)

    :param str idOrShortName: Customer ID or short name\, used to identify customer.
    :param list key: Set of property keys to be deleted
    :param str domain: Domain ID or short name\, used to identify customer. Defaults to current user\'s domain.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/properties".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def search_customers(
    ancestor: str = None,
    customer: str = None,
    domain: str = None,
    excludeFlags: str = None,
    includeDeleted: bool = None,
    includeFlags: str = None,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = None,
    keywords: str = None,
    limit: int = None,
    offset: int = None,
    parent: str = None,
    properties: dict = None,
    subCriteria: dict = None,
    type: str = None,
    sortBy: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns customers defined by SearchAdminCustomerRequest (PUBLIC)

    :param list ancestor: Search for customers by ancestor customer id or shortname. Will return customers that descend from any of these parents.
    :param list customer: Restrict search to specified customers.
    :param list domain: Search for customers in one of these domains \(by domain id or name\).
    :param list excludeFlags: Exclude objects which have excludeFlags set.
    :param bool includeDeleted: Set to true to include deleted objects. By default\, exclude deleted objects.
    :param list includeFlags: Only include objects which have includeFlags set.
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\).
    :param str keywordMatchStrategy: Defines the MatchStrategy for keywords \(default match all keywords\).
    :param list keywords: Search for customers by keywords.
    :param int limit: Max number of results.
    :param int offset: Skip the first \(offset\) objects. By default\, return result from first object.
    :param list parent: Search for customers by parent customer id or shortname. Will return customers that are direct children of any of these parents.
    :param list properties:
    :param list subCriteria: Set additional criteria
    :param list type: Search for customers by type.
    :param list sortBy: Field to sort result by\, use \- to sort in desc order.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/search".format()

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send ancestor if the argument was provided, don't send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send type if the argument was provided, don't send null values
    if type is not None:
        body.update({"type": type})

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_customer(
    idOrShortName: str,
    allowGlobalData: bool = None,
    dataDeleted: bool = None,
    denySubmitForAnonymousUser: bool = None,
    excludeFromProduction: bool = None,
    language: str = None,
    name: str = None,
    networkBaseCustomer: bool = None,
    shortName: str = None,
    singleNetworkDomain: bool = None,
    timeZone: str = None,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Update a customer object. (PUBLIC)

    :param str idOrShortName: Customer ID or short name\, used to identify customer.
    :param bool allowGlobalData: It is possible to modify this flag only for leaf customers.
    :param bool dataDeleted: If set\, this option indicates that all of Customer data has been deleted. Please do not set this flag if you did not confirm that the customers data has been purged. Setting this option will not delete the data. It is for indication purposes only.
    :param bool denySubmitForAnonymousUser: It is possible to modify this flag only for leaf customers.
    :param bool excludeFromProduction: If set\, enable\/disable customer as excluded from production
    :param str language: If set\, change customer language.
    :param str name: If set\, change customer name to this value.
    :param bool networkBaseCustomer: If set\, enable\/disable customer as base customer for a customer group\, used for remapping events\' customer by network CIDR among sub\-customers that belong to same customer group \(group must be SINGLE\_NETWORK\_DOMAIN flagged\)\, cannot be set for group customer\, and once enabled the customer cannot be promoted to group unless disable it.
    :param str shortName: If set\, change customer shortname to this value \(must be unique\).
    :param bool singleNetworkDomain: If set\, enable\/disable customer group option for remapping events\' customer by network CIDR among its sub\-customers\, cannot be set for non\-group customer\, and once enabled the customer group cannot be changed to non\-group customer unless disable it.
    :param str timeZone: If set\, change customer timezone to timezone with this name.
    :param str domain: Domain ID or short name\, used to identify customer. Defaults to current user\'s domain.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send allowGlobalData if the argument was provided, don't send null values
    if allowGlobalData is not None:
        body.update({"allowGlobalData": allowGlobalData})
    # Only send dataDeleted if the argument was provided, don't send null values
    if dataDeleted is not None:
        body.update({"dataDeleted": dataDeleted})
    # Only send denySubmitForAnonymousUser if the argument was provided, don't send null values
    if denySubmitForAnonymousUser is not None:
        body.update({"denySubmitForAnonymousUser": denySubmitForAnonymousUser})
    # Only send excludeFromProduction if the argument was provided, don't send null values
    if excludeFromProduction is not None:
        body.update({"excludeFromProduction": excludeFromProduction})
    # Only send language if the argument was provided, don't send null values
    if language is not None:
        body.update({"language": language})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send networkBaseCustomer if the argument was provided, don't send null values
    if networkBaseCustomer is not None:
        body.update({"networkBaseCustomer": networkBaseCustomer})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send singleNetworkDomain if the argument was provided, don't send null values
    if singleNetworkDomain is not None:
        body.update({"singleNetworkDomain": singleNetworkDomain})
    # Only send timeZone if the argument was provided, don't send null values
    if timeZone is not None:
        body.update({"timeZone": timeZone})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_customer_logo(
    idOrShortName: str,
    mimeType: str,
    data: str = None,
    image: str = None,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Updates a customer logo image (PUBLIC)

    :param str idOrShortName: Short name or ID of customer
    :param str mimeType: The MIME type of the image. Currently allowed mimetypes are image\/png and image\/jpg
    :param str data:
    :param str image: Change customer logo. Base64 data String. Example\: \'data\:image\/png\;base64\, iVBORw0KGgoAAAA...\'\, please provide only the \'iVBORw0KGgoAAAA...\' part.
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/logo".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send data if the argument was provided, don't send null values
    if data is not None:
        body.update({"data": data})
    # Only send image if the argument was provided, don't send null values
    if image is not None:
        body.update({"image": image})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_customer_properties(
    idOrShortName: str,
    properties: dict,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Returns a set of only the updated properties (not all of the properties) for the customer id or shortName by property name. (PUBLIC)

    :param str idOrShortName: Customer ID or short name\, used to identify customer.
    :param dict properties: Set of properties to update with corresponding values.
    :param str domain: Domain ID or short name\, used to identify customer. Defaults to current user\'s domain.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/properties".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send properties if the argument was provided, don't send null values
    if properties is not None:
        body.update({"properties": properties})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


def update_customer_user_roles(
    idOrShortName: str,
    userRoles: dict,
    domain: str = None,
    json: bool = True,
    verify: Optional[bool] = None,
    proxies: Optional[dict] = None,
    apiKey: Optional[str] = None,
    authentication: Optional[dict] = None,
    server_url: Optional[str] = None,
    body: Optional[dict] = None,
    api_session: Optional["ArgusAPISession"] = None,
) -> dict:
    r"""Update user roles of a customer object. (PUBLIC)

    :param str idOrShortName: Customer ID or shortname
    :param list userRoles: Set of users and roles to update in json format
    :param str domain: Customer domain to lookup user \(defaults to current users domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :param api_session: session to use for this request. If not set, the global session will be used.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/customeradmin/v2/customer/{idOrShortName}/userroles".format(
        idOrShortName=idOrShortName
    )

    session = api_session or _get_session()
    headers = {}

    body = body or {}
    # Only send userRoles if the argument was provided, don't send null values
    if userRoles is not None:
        body.update({"userRoles": userRoles})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
