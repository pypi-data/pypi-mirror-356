"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module
from requests import Response

log = logging.getLogger(__name__)


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def add_user(
    customer: str,
    name: str,
    shortName: str,
    description: str = None,
    domain: str = None,
    email: str = None,
    enableAuthenticationMethods: str = None,
    phone: dict = None,
    phoneNumber: str = None,
    role: str = None,
    daemonAccount: bool = None,
    externallyManaged: bool = None,
    language: str = "english",
    notificationUser: bool = None,
    skipDefaultAuthenticationMethods: bool = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Add new user (PUBLIC)

    :param str customer: The shortname or ID for customer to register the subject to
    :param str name: The name of the subject
    :param str shortName: The shortname of the subject
    :param str description: The description of the subject
    :param str domain: The name or ID of the domain to look up the customer which we are registering the subject to
    :param str email: The user\'s email \[format\:email\]
    :param list enableAuthenticationMethods: Specify authentication methods to enable for this user. If not specified\, service defaults will apply.
    :param dict phone:
    :param str phoneNumber: DEPRECATED\: Use phone instead. The user\'s phone number. Gives an error if used with phoneNumber \[format\:phone\]
    :param str role: DEPRECATED\: Use \'description\' field instead.
    :param bool daemonAccount: If set\, mark this account as a daemon account
    :param bool externallyManaged: Whether the subject is managed externally
    :param str language: The user\'s language
    :param bool notificationUser: If set\, mark this account as a notification user account
    :param bool skipDefaultAuthenticationMethods: Skip adding default authentication methods. This is deprecated\, specify an empty enableAuthenticationMethods instead.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send daemonAccount if the argument was provided, don't send null values
    if daemonAccount is not None:
        body.update({"daemonAccount": daemonAccount})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send email if the argument was provided, don't send null values
    if email is not None:
        body.update({"email": email})
    # Only send enableAuthenticationMethods if the argument was provided, don't send null values
    if enableAuthenticationMethods is not None:
        body.update({"enableAuthenticationMethods": enableAuthenticationMethods})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send language if the argument was provided, don't send null values
    if language is not None:
        body.update({"language": language})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send notificationUser if the argument was provided, don't send null values
    if notificationUser is not None:
        body.update({"notificationUser": notificationUser})
    # Only send phone if the argument was provided, don't send null values
    if phone is not None:
        body.update({"phone": phone})
    # Only send phoneNumber if the argument was provided, don't send null values
    if phoneNumber is not None:
        body.update({"phoneNumber": phoneNumber})
    # Only send role if the argument was provided, don't send null values
    if role is not None:
        body.update({"role": role})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})
    # Only send skipDefaultAuthenticationMethods if the argument was provided, don't send null values
    if skipDefaultAuthenticationMethods is not None:
        body.update(
            {"skipDefaultAuthenticationMethods": skipDefaultAuthenticationMethods}
        )

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def admin_get_user_image(
    shortNameOrID: str,
    domain: str = None,
    size: str = None,
    width: int = None,
    height: int = None,
    default: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> Response:
    r"""Returns user profile picture. (PUBLIC)

    :param str shortNameOrID: User ID or username
    :param str domain: Domain ID or shortname \(optional\, defaults to current user domain\)
    :param str size: The preferred size of the image \(small\, medium\, large\, xlarge\)\, should not be used together with parameters \'width\' and \'height\'\, will crop the original image if it is not a square \(optional\)
    :param int width: The preferred width of the image. Preserves aspect ratio if height is not set \(optional\)
    :param int height: The preferred height of the image. Preserves aspect ratio if width is not set \(optional\)
    :param bool default: If true\, return default avatar image if user picture not set. Default is false.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object

    """

    route = "/useradmin/v2/user/{shortNameOrID}/picture".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}
    headers["content"] = None

    query_parameters = {}
    # Only send default if the argument was provided, don't send null values
    if default is not None:
        query_parameters.update({"default": default})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send size if the argument was provided, don't send null values
    if size is not None:
        query_parameters.update({"size": size})
    # Only send width if the argument was provided, don't send null values
    if width is not None:
        query_parameters.update({"width": width})
    # Only send height if the argument was provided, don't send null values
    if height is not None:
        query_parameters.update({"height": height})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def delete_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes a user (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}".format(shortNameOrID=shortNameOrID)
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def delete_user_preferences(
    shortNameOrID: str,
    key: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes selected user preferences (PUBLIC)

    :param str shortNameOrID: Short name or ID of subject
    :param list key: Name of preference to delete
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def get_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Get a user (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}".format(shortNameOrID=shortNameOrID)
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def get_user_preference(
    shortNameOrID: str,
    key: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Return the preference with the given key (PUBLIC)

    :param str shortNameOrID: Short name or ID of subject
    :param str key: Name of preference to return
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences/{key}".format(
        shortNameOrID=shortNameOrID, key=key
    )
    headers = {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def list_permissions_for_user(
    shortNameOrID: str,
    domain: str = None,
    offset: int = 0,
    limit: int = 25,
    includeDeleted: bool = False,
    includeInherited: bool = True,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""List permissions for a user (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param bool includeDeleted: Include deleted permission
    :param bool includeInherited: Include inherited permission
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/permissions".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send includeInherited if the argument was provided, don't send null values
    if includeInherited is not None:
        query_parameters.update({"includeInherited": includeInherited})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def list_user_preference_as_map(
    shortNameOrID: str,
    key: str,
    domain: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Lists out the user's preferences. Returns all user preferences if no keys are specified.Returns a empty map if no matching preferences where found for user (PUBLIC)

    :param str shortNameOrID: Short name or ID of subject
    :param list key: List of preferences to return\, default is all
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises UserNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferencemap".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def list_user_preferences(
    shortNameOrID: str,
    key: str,
    domain: str = None,
    offset: int = 0,
    limit: int = 25,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Lists out the user's preferences. Returns all user preferences if no keys are specified (PUBLIC)

    :param str shortNameOrID: Short name or ID of subject
    :param list key: List of preferences to return\, default is all
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises UserNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send key if the argument was provided, don't send null values
    if key is not None:
        query_parameters.update({"key": key})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def list_users(
    domain: str = None,
    subject: str = None,
    customer: str = None,
    excludeFlag: str = None,
    includeFlag: str = None,
    keyword: str = None,
    keywords: str = None,
    keywordField: str = None,
    sortBy: str = None,
    offset: int = 0,
    limit: int = 25,
    includeDeleted: bool = False,
    keywordMatch: str = "all",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Returns the users matching the query (PUBLIC)

    :param list domain: Domain to search in by short name or id
    :param list subject: Subject to search for by short name or id
    :param list customer: Customer to search for by short name or id
    :param list excludeFlag: Exclude users with flag
    :param list includeFlag: Include users with flag
    :param list keyword: DEPRECATED\: Use \'keywords\' instead
    :param list keywords: Search by keywords
    :param list keywordField: Set field strategy for keyword search
    :param list sortBy: Field to sort by
    :param int offset: Skip a number of results
    :param int limit: Maximum number of returned results
    :param bool includeDeleted: Include deleted users
    :param str keywordMatch: Set match strategy for keyword search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user".format()
    headers = {}

    query_parameters = {}
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        query_parameters.update({"includeDeleted": includeDeleted})
    # Only send keywordMatch if the argument was provided, don't send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        query_parameters.update({"subject": subject})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        query_parameters.update({"customer": customer})
    # Only send excludeFlag if the argument was provided, don't send null values
    if excludeFlag is not None:
        query_parameters.update({"excludeFlag": excludeFlag})
    # Only send includeFlag if the argument was provided, don't send null values
    if includeFlag is not None:
        query_parameters.update({"includeFlag": includeFlag})
    # Only send keyword if the argument was provided, don't send null values
    if keyword is not None:
        query_parameters.update({"keyword": keyword})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send keywordField if the argument was provided, don't send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def move_user(
    shortNameOrID: str,
    customer: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Move a user to another customer (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str customer: ID or shortname of customer to move the subject to. The customer must be in same domain as the subject.
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/move".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def reenable_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Reenables a deleted user (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/reenable".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def reset_password(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Resets a users password. This operation is deprecated, use /authentication/v1/user/{user}/password/reset instead. (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/resetpassword".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def search_users(
    keywordFieldStrategy: str,
    keywordMatchStrategy: str,
    timeMatchStrategy: str,
    sortBy: str,
    timeFieldStrategy: str,
    ancestor: str = None,
    customer: str = None,
    domain: str = None,
    endTimestamp: int = None,
    excludeFlags: str = None,
    includeFlags: str = None,
    keywords: str = None,
    parent: str = None,
    permissions: dict = None,
    subCriteria: dict = None,
    subject: str = None,
    userFieldStrategy: str = None,
    userMatchStrategy: str = None,
    userPreferences: dict = None,
    includeDeleted: bool = None,
    limit: int = 25,
    offset: int = None,
    startTimestamp: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Returns the users matching the query (PUBLIC)

    :param list keywordFieldStrategy: Which fields will be searched for the given keyword
    :param str keywordMatchStrategy: Search based on all keywords \(AND\)\, or based on any keyword \(OR\)
    :param str timeMatchStrategy: Search based on all time\-field \(AND\)\, or based on any time\-field \(OR\)
    :param list sortBy: Field to sort by
    :param list timeFieldStrategy: The fields to limit the time search to
    :param list ancestor: Restrict search to subjects descending from specific groups\, by ID or shortname. This will not include deleted ancestors if includeDeleted is set
    :param list customer: Restrict search to subjects bound to these customers \(by ID or shortname\). Customer groups will resolve to all sub customers as well.
    :param list domain: Restrict the search to subjects in these domains\, by domain ID or name.
    :param int endTimestamp: The end time of the search
    :param list excludeFlags: Exclude subjects with these flags from the search.
    :param list includeFlags: Restrict search to subjects having all of the specified flags.
    :param list keywords: Keywords to search for
    :param list parent: Restrict search to subjects which are direct member of specific groups\, by ID or shortname
    :param list permissions: Limit search to subjects with one of the given permissions
    :param list subCriteria: Set additional criteria with AND\, OR or AND NOT
    :param list subject: Restrict search to specific subjects\, by ID or shortname
    :param list userFieldStrategy:
    :param str userMatchStrategy:
    :param dict userPreferences: Restricts the search to users with matching user preferences. The key should be the name of the user preference. The UserPreferenceSearchSubCriteria can provide value\, or if the preference should be included or excluded
    :param bool includeDeleted: Whether or not to include deleted subjects. This will include deleted groups and users
    :param int limit: The max amount of items to display
    :param int offset: The amount of items to skip
    :param int startTimestamp: The start time of the search
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: ``requests.Response`` object or dictionary translated from JSON
    """

    route = "/useradmin/v2/user/search".format()
    headers = {}
    headers["content"] = None
    if json:
        headers["content"] = "application/json"

    body = body or {}
    # Only send ancestor if the argument was provided, don't send null values
    if ancestor is not None:
        body.update({"ancestor": ancestor})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        body.update({"domain": domain})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send parent if the argument was provided, don't send null values
    if parent is not None:
        body.update({"parent": parent})
    # Only send permissions if the argument was provided, don't send null values
    if permissions is not None:
        body.update({"permissions": permissions})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send subject if the argument was provided, don't send null values
    if subject is not None:
        body.update({"subject": subject})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})
    # Only send userPreferences if the argument was provided, don't send null values
    if userPreferences is not None:
        body.update({"userPreferences": userPreferences})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def set_user_image(
    shortNameOrID: str,
    image: str,
    mimeType: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Sets a users profile image (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str image:
    :param str mimeType: The MIME type of the image
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/picture".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    body = body or {}
    # Only send image if the argument was provided, don't send null values
    if image is not None:
        body.update({"image": image})
    # Only send mimeType if the argument was provided, don't send null values
    if mimeType is not None:
        body.update({"mimeType": mimeType})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def set_user_preference(
    shortNameOrID: str,
    key: str,
    value: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update the user's preferences (PUBLIC)

    :param str shortNameOrID: Short name or ID of subject
    :param str key: Name of preference to set
    :param str value: Value of the preference to set
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences/{key}/{value}".format(
        shortNameOrID=shortNameOrID, key=key, value=value
    )
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def set_user_preferences(
    shortNameOrID: str,
    preferences: dict = None,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update the user's preferences (PUBLIC)

    :param str shortNameOrID: Short name or ID of subject
    :param dict preferences: Request to update a user\'s preferences
    :param str domain: Domain ID or short name \(optional\, defaults to current user domain\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/preferences".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    body = body or {}
    # Only send preferences if the argument was provided, don't send null values
    if preferences is not None:
        body.update({"preferences": preferences})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def unblock_user(
    shortNameOrID: str,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Unblocks a user. This endpoint is deprecated, use /authentication/v1/user/{user}/unblock instead. (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}/unblock".format(
        shortNameOrID=shortNameOrID
    )
    headers = {}

    body = body or {}

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("useradmin", "v2", "user"), module=argus_cli_module)
def update_user(
    shortNameOrID: str,
    daemonAccount: bool = None,
    description: str = None,
    email: str = None,
    externallyManaged: bool = None,
    language: str = None,
    name: str = None,
    phone: dict = None,
    phoneNumber: str = None,
    role: str = None,
    shortName: str = None,
    domain: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Update a user (PUBLIC)

    :param str shortNameOrID: Short name or ID of user
    :param bool daemonAccount: If set\, change the daemon flag for this user
    :param str description: The description of the subject
    :param str email: If set\, update the user\'s email. Blank string will delete the current value. \[format\:email\]
    :param bool externallyManaged: Whether the subject is managed externally
    :param str language: If set\, change the user\'s language
    :param str name: The name of the subject
    :param dict phone:
    :param str phoneNumber: DEPRECATED\: Use phone instead. If set\, update the user\'s phone number. Gives an error if used with phone \[format\:phone\]
    :param str role: DEPRECATED\: Use \'description\' field instead.
    :param str shortName: The shortname of the subject
    :param str domain: Name or ID of the domain of the user
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationErrorException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/useradmin/v2/user/{shortNameOrID}".format(shortNameOrID=shortNameOrID)
    headers = {}

    body = body or {}
    # Only send daemonAccount if the argument was provided, don't send null values
    if daemonAccount is not None:
        body.update({"daemonAccount": daemonAccount})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send email if the argument was provided, don't send null values
    if email is not None:
        body.update({"email": email})
    # Only send externallyManaged if the argument was provided, don't send null values
    if externallyManaged is not None:
        body.update({"externallyManaged": externallyManaged})
    # Only send language if the argument was provided, don't send null values
    if language is not None:
        body.update({"language": language})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send phone if the argument was provided, don't send null values
    if phone is not None:
        body.update({"phone": phone})
    # Only send phoneNumber if the argument was provided, don't send null values
    if phoneNumber is not None:
        body.update({"phoneNumber": phoneNumber})
    # Only send role if the argument was provided, don't send null values
    if role is not None:
        body.update({"role": role})
    # Only send shortName if the argument was provided, don't send null values
    if shortName is not None:
        body.update({"shortName": shortName})

    query_parameters = {}
    # Only send domain if the argument was provided, don't send null values
    if domain is not None:
        query_parameters.update({"domain": domain})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        params=query_parameters or None,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
