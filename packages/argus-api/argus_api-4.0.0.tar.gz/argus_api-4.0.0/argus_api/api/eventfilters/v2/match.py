"""Autogenerated API"""
from argus_api.session import _legacy_session as session
import logging
from argus_cli.plugin import register_command
from argus_plugins import argus_cli_module

log = logging.getLogger(__name__)


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def add_match_filter(
    actions: dict,
    customer: str,
    description: str,
    eventType: str,
    filters: dict,
    name: str,
    labels: str = None,
    enabled: bool = None,
    index: int = 5,
    validFrom: str = "0",
    validTo: str = "0",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Adds a match filter (INTERNAL)

    :param dict actions:
    :param str customer: The shortname or ID of the customer the filter belongs to. To create a global filter set the value to \'0\'
    :param str description: A description of the filter
    :param str eventType: What type of event the filter should match against. Type raw will create a NIDSEventMatchFilter in v1\, aggregated will create a AggregatedIPAttackEventMatchFilter\, and all will create a IPAttackEventMatchFilter. Defaults to \'all\'
    :param dict filters:
    :param str name: The name of the filter
    :param list labels: A set of labels which can be used to categorize the filter
    :param bool enabled: Whether or not the filter is enabled
    :param int index: The index of the filter. Filters with lower index will be ran first.
    :param str validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match".format()
    headers = {}

    body = body or {}
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send enabled if the argument was provided, don't send null values
    if enabled is not None:
        body.update({"enabled": enabled})
    # Only send eventType if the argument was provided, don't send null values
    if eventType is not None:
        body.update({"eventType": eventType})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send index if the argument was provided, don't send null values
    if index is not None:
        body.update({"index": index})
    # Only send labels if the argument was provided, don't send null values
    if labels is not None:
        body.update({"labels": labels})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def debug_match_filter(
    id: int,
    eventIDs: str,
    actions: dict = None,
    filters: dict = None,
    validFrom: int = None,
    validTo: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Shows the result of running a match filter against a set of events (INTERNAL)

    :param int id: ID of filter
    :param list eventIDs: The list of event ids for the events to debug against. Can be given in the form of AGGR\/1\/123456789\/\{UUID\} or simply UUID.
    :param dict actions:
    :param dict filters:
    :param int validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param int validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/debug".format(id=id)
    headers = {}

    body = body or {}
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send eventIDs if the argument was provided, don't send null values
    if eventIDs is not None:
        body.update({"eventIDs": eventIDs})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def debug_unsaved_match_filter(
    eventIDs: str,
    eventType: str,
    actions: dict = None,
    filters: dict = None,
    validFrom: int = None,
    validTo: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Shows the result of running a match filter against a set of events (INTERNAL)

    :param list eventIDs: The list of event ids for the events to debug against. Can be given in the form of AGGR\/1\/123456789\/\{UUID\} or simply UUID.
    :param str eventType: What type of event the filter should match against. Type raw will create a NIDSEventMatchFilter in v1\, aggregated will create a AggregatedIPAttackEventMatchFilter\, and all will create a IPAttackEventMatchFilter. Defaults to \'all\'
    :param dict actions:
    :param dict filters:
    :param int validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param int validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/debug".format()
    headers = {}

    body = body or {}
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send eventIDs if the argument was provided, don't send null values
    if eventIDs is not None:
        body.update({"eventIDs": eventIDs})
    # Only send eventType if the argument was provided, don't send null values
    if eventType is not None:
        body.update({"eventType": eventType})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def delete_match_filter(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Deletes a match filter (INTERNAL)

    :param int id: ID of filter to delete
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}".format(id=id)
    headers = {}

    log.debug("DELETE %s (headers: %s)" % (route, str(headers)))

    response = session.delete(
        route,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def disable_match_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Disables a match filter (INTERNAL)

    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/disable".format(id=id)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def disable_match_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Disables a match filter on instance (INTERNAL)

    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{filterID}/{instanceID}/disable".format(
        filterID=filterID, instanceID=instanceID
    )
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def duplicate_match_filter(
    id: int,
    customer: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Duplicates a match filter (INTERNAL)

    :param int id: ID of filter
    :param str customer: The customer the duplicate should belong to \(id or shortname\). Use \'0\' to create a global filter\, If this field is not set the default is using the same customer as the original filter.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/duplicate".format(id=id)
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def enable_match_filter(
    id: int,
    comment: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Enables a match filter (INTERNAL)

    :param int id: ID of filter
    :param str comment: A comment describing why the filter was enabled\/disabled
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/enable".format(id=id)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def enable_match_filter_on_instance(
    filterID: int,
    instanceID: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Enables a match filter on instance (INTERNAL)

    :param int filterID: ID of the filter
    :param int instanceID: ID of the instance
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{filterID}/{instanceID}/enable".format(
        filterID=filterID, instanceID=instanceID
    )
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def get_match_filter(
    id: int,
    revision: int = None,
    includeCode: bool = False,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets a match filter (INTERNAL)

    :param int id: ID of filter
    :param int revision: The expected revision of the filter
    :param bool includeCode: Whether to include code in MatchFilter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    # Only send revision if the argument was provided, don't send null values
    if revision is not None:
        query_parameters.update({"revision": revision})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def get_match_filter_status(
    id: int,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets the statuses of a match filters instances (INTERNAL)

    :param int id: ID of filter
    :param int limit: Limit result
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/status".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def list_match_filter(
    keywords: str = None,
    includeCode: bool = None,
    sortBy: str = None,
    keywordMatch: str = "all",
    keywordField: str = None,
    timestampMatch: str = "all",
    timestampField: str = None,
    start: int = 0,
    end: int = 0,
    keywordMatchStrategy: str = "all",
    keywordFieldStrategy: str = None,
    timestampMatchStrategy: str = "all",
    timestampFieldStrategy: str = None,
    startTimestamp: int = 0,
    endTimestamp: int = 0,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Simple search for match filters (INTERNAL)

    :param list keywords: Search by keywords
    :param bool includeCode: Whether to include code in results
    :param list sortBy: Field to sort by
    :param str keywordMatch: Deprecated\: Set match strategy for keyword search
    :param list keywordField: Deprecated\: Set field strategy for keyword search
    :param str timestampMatch: Deprecated\: Set match strategy for timestamp filtering
    :param list timestampField: Deprecated\: Set field strategy for timestamp filtering
    :param int start: Deprecated\: Lower bound timestamp filter value
    :param int end: Deprecated\: Upper bound timestamp filter value
    :param str keywordMatchStrategy: Set match strategy for keyword search
    :param list keywordFieldStrategy: Set field strategy for keyword search
    :param str timestampMatchStrategy: Set match strategy for timestamp filtering
    :param list timestampFieldStrategy: Set field strategy for timestamp filtering
    :param int startTimestamp: Lower bound timestamp filter value
    :param int endTimestamp: Upper bound timestamp filter value
    :param int limit: Limit result
    :param int offset: Offset result
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match".format()
    headers = {}

    query_parameters = {}
    # Only send keywordMatch if the argument was provided, don't send null values
    if keywordMatch is not None:
        query_parameters.update({"keywordMatch": keywordMatch})
    # Only send keywordField if the argument was provided, don't send null values
    if keywordField is not None:
        query_parameters.update({"keywordField": keywordField})
    # Only send timestampMatch if the argument was provided, don't send null values
    if timestampMatch is not None:
        query_parameters.update({"timestampMatch": timestampMatch})
    # Only send timestampField if the argument was provided, don't send null values
    if timestampField is not None:
        query_parameters.update({"timestampField": timestampField})
    # Only send start if the argument was provided, don't send null values
    if start is not None:
        query_parameters.update({"start": start})
    # Only send end if the argument was provided, don't send null values
    if end is not None:
        query_parameters.update({"end": end})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        query_parameters.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        query_parameters.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send timestampMatchStrategy if the argument was provided, don't send null values
    if timestampMatchStrategy is not None:
        query_parameters.update({"timestampMatchStrategy": timestampMatchStrategy})
    # Only send timestampFieldStrategy if the argument was provided, don't send null values
    if timestampFieldStrategy is not None:
        query_parameters.update({"timestampFieldStrategy": timestampFieldStrategy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        query_parameters.update({"startTimestamp": startTimestamp})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        query_parameters.update({"endTimestamp": endTimestamp})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        query_parameters.update({"keywords": keywords})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        query_parameters.update({"includeCode": includeCode})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        query_parameters.update({"sortBy": sortBy})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def list_match_filter_revisions(
    id: int,
    limit: int = 25,
    offset: int = 0,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
) -> dict:
    r"""Gets a match filters earlier revisions (INTERNAL)

    :param int id: ID of filter to fetch revisions for
    :param int limit: The max amount of revisions to return
    :param int offset: The number of revisions to skip before returning
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/revisions".format(id=id)
    headers = {}

    query_parameters = {}
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        query_parameters.update({"limit": limit})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        query_parameters.update({"offset": offset})

    log.debug("GET %s (headers: %s)" % (route, str(headers)))

    response = session.get(
        route,
        params=query_parameters or None,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def revert_match_filter(
    filterID: int,
    comment: str,
    revisionID: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Reverts a match filter to a previous revision (INTERNAL)

    :param int filterID: ID of the filter to revert\( must be the current version of a filter\)
    :param str comment: A comment describing why the filter was reverted
    :param int revisionID: The ID of the filter to revert to. Must be a revision of the filter to revert
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{filterID}/revert".format(filterID=filterID)
    headers = {}

    body = body or {}
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send revisionID if the argument was provided, don't send null values
    if revisionID is not None:
        body.update({"revisionID": revisionID})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def revive_match_filter(
    id: int,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Revives a deleted a Match filter (INTERNAL)

    :param int id: ID of filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/revive".format(id=id)
    headers = {}

    body = body or {}

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def search_match_filter(
    alarmID: int = None,
    associatedCaseID: int = None,
    attackCategory: str = None,
    customer: str = None,
    excludeEventFlags: str = None,
    excludeFlags: str = None,
    filterID: int = None,
    filterType: str = None,
    includeAscendingCustomers: bool = None,
    includeEventFlags: str = None,
    includeFlags: str = None,
    keywords: str = None,
    location: str = None,
    sortBy: str = None,
    subCriteria: dict = None,
    user: str = None,
    endTimestamp: int = None,
    includeCode: bool = None,
    includeDeleted: bool = None,
    includeDescendingCustomers: bool = True,
    keywordFieldStrategy: str = None,
    keywordMatchStrategy: str = "all",
    limit: int = 25,
    offset: int = None,
    startTimestamp: int = None,
    timeFieldStrategy: str = None,
    timeMatchStrategy: str = "any",
    userFieldStrategy: str = None,
    userMatchStrategy: str = "all",
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Searches for match filters (INTERNAL)

    :param list alarmID: Limit to filters which target the following alarms
    :param list associatedCaseID: Limit to streaming filters for the following cases
    :param list attackCategory: Limit to filters which target the following attack categories\, identified by id or shortname
    :param list customer: Limit search to filters with the given customers\, identified by id or shortname
    :param list excludeEventFlags: Limit to filters which exclude the given event flags
    :param list excludeFlags: Exclude filters which have the following flags set
    :param list filterID: Limit search to filters with the given IDs
    :param list filterType: Limit search to filters with the given filter types
    :param bool includeAscendingCustomers: When limiting filters by customer\, include filters of ascending customers \(default is false\)
    :param list includeEventFlags: Limit to filters which include the given event flags
    :param list includeFlags: Limit to filters which have the following flags set
    :param list keywords: Search for keywords against fields defined by keywordFieldStrategy
    :param list location: Limit to filters which target the following locations\, identified by id or shortname
    :param list sortBy:
    :param list subCriteria: Subcriteria to add to the search
    :param list user: Search using users identified by id or shortname. If given a group\, we will resolve all members of the group recursively
    :param int endTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(end timestamp\)
    :param bool includeCode: Whether or not to include code in the result object. The code is only returned if set to true
    :param bool includeDeleted: Set to true to include deleted filters \(excluded by default\).
    :param bool includeDescendingCustomers: When limiting filters by customer\, include filters of descending customers \(default is true\)
    :param list keywordFieldStrategy: Defines which fields will be searched by keywords \(default all supported fields\)
    :param str keywordMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\)
    :param int limit: Limit maximum amount of results
    :param int offset: Skip specified amount of results
    :param int startTimestamp: Restrict to a time frame based on the set timeFieldStrategy \(start timestamp\)
    :param list timeFieldStrategy: Defines which timestamps will be included in the search \(default lastUpdated\)
    :param str timeMatchStrategy: Defines how strict to match against different timestamps \(all\/any\) using start and end timestamp \(default any\)
    :param list userFieldStrategy: Defines which fields will be searched by user \(default all supported fields\)
    :param str userMatchStrategy: Defines how strict different keywords should be matched \(default match all keywords\)
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/search".format()
    headers = {}

    body = body or {}
    # Only send alarmID if the argument was provided, don't send null values
    if alarmID is not None:
        body.update({"alarmID": alarmID})
    # Only send associatedCaseID if the argument was provided, don't send null values
    if associatedCaseID is not None:
        body.update({"associatedCaseID": associatedCaseID})
    # Only send attackCategory if the argument was provided, don't send null values
    if attackCategory is not None:
        body.update({"attackCategory": attackCategory})
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send endTimestamp if the argument was provided, don't send null values
    if endTimestamp is not None:
        body.update({"endTimestamp": endTimestamp})
    # Only send excludeEventFlags if the argument was provided, don't send null values
    if excludeEventFlags is not None:
        body.update({"excludeEventFlags": excludeEventFlags})
    # Only send excludeFlags if the argument was provided, don't send null values
    if excludeFlags is not None:
        body.update({"excludeFlags": excludeFlags})
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send filterType if the argument was provided, don't send null values
    if filterType is not None:
        body.update({"filterType": filterType})
    # Only send includeAscendingCustomers if the argument was provided, don't send null values
    if includeAscendingCustomers is not None:
        body.update({"includeAscendingCustomers": includeAscendingCustomers})
    # Only send includeCode if the argument was provided, don't send null values
    if includeCode is not None:
        body.update({"includeCode": includeCode})
    # Only send includeDeleted if the argument was provided, don't send null values
    if includeDeleted is not None:
        body.update({"includeDeleted": includeDeleted})
    # Only send includeDescendingCustomers if the argument was provided, don't send null values
    if includeDescendingCustomers is not None:
        body.update({"includeDescendingCustomers": includeDescendingCustomers})
    # Only send includeEventFlags if the argument was provided, don't send null values
    if includeEventFlags is not None:
        body.update({"includeEventFlags": includeEventFlags})
    # Only send includeFlags if the argument was provided, don't send null values
    if includeFlags is not None:
        body.update({"includeFlags": includeFlags})
    # Only send keywordFieldStrategy if the argument was provided, don't send null values
    if keywordFieldStrategy is not None:
        body.update({"keywordFieldStrategy": keywordFieldStrategy})
    # Only send keywordMatchStrategy if the argument was provided, don't send null values
    if keywordMatchStrategy is not None:
        body.update({"keywordMatchStrategy": keywordMatchStrategy})
    # Only send keywords if the argument was provided, don't send null values
    if keywords is not None:
        body.update({"keywords": keywords})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send location if the argument was provided, don't send null values
    if location is not None:
        body.update({"location": location})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})
    # Only send sortBy if the argument was provided, don't send null values
    if sortBy is not None:
        body.update({"sortBy": sortBy})
    # Only send startTimestamp if the argument was provided, don't send null values
    if startTimestamp is not None:
        body.update({"startTimestamp": startTimestamp})
    # Only send subCriteria if the argument was provided, don't send null values
    if subCriteria is not None:
        body.update({"subCriteria": subCriteria})
    # Only send timeFieldStrategy if the argument was provided, don't send null values
    if timeFieldStrategy is not None:
        body.update({"timeFieldStrategy": timeFieldStrategy})
    # Only send timeMatchStrategy if the argument was provided, don't send null values
    if timeMatchStrategy is not None:
        body.update({"timeMatchStrategy": timeMatchStrategy})
    # Only send user if the argument was provided, don't send null values
    if user is not None:
        body.update({"user": user})
    # Only send userFieldStrategy if the argument was provided, don't send null values
    if userFieldStrategy is not None:
        body.update({"userFieldStrategy": userFieldStrategy})
    # Only send userMatchStrategy if the argument was provided, don't send null values
    if userMatchStrategy is not None:
        body.update({"userMatchStrategy": userMatchStrategy})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def search_match_filter_status(
    customer: str = None,
    filterID: int = None,
    filterStatus: str = None,
    filterType: str = None,
    limit: int = None,
    loggingStatus: str = None,
    offset: int = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Search for match filters instance statuses for filters that match the criteria (INTERNAL)

    :param list customer:
    :param list filterID:
    :param list filterStatus:
    :param str filterType:
    :param int limit:
    :param list loggingStatus:
    :param int offset:
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/status/search".format()
    headers = {}

    body = body or {}
    # Only send customer if the argument was provided, don't send null values
    if customer is not None:
        body.update({"customer": customer})
    # Only send filterID if the argument was provided, don't send null values
    if filterID is not None:
        body.update({"filterID": filterID})
    # Only send filterStatus if the argument was provided, don't send null values
    if filterStatus is not None:
        body.update({"filterStatus": filterStatus})
    # Only send filterType if the argument was provided, don't send null values
    if filterType is not None:
        body.update({"filterType": filterType})
    # Only send limit if the argument was provided, don't send null values
    if limit is not None:
        body.update({"limit": limit})
    # Only send loggingStatus if the argument was provided, don't send null values
    if loggingStatus is not None:
        body.update({"loggingStatus": loggingStatus})
    # Only send offset if the argument was provided, don't send null values
    if offset is not None:
        body.update({"offset": offset})

    log.debug(
        "POST %s (headers: %s, body: %s)" % (route, str(headers), str(body) or "")
    )

    response = session.post(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def set_match_filter_log_level(
    id: int,
    logLevel: str,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Sets the log level of a Match filter (INTERNAL)

    :param int id: ID of filter
    :param str logLevel: The new log level of the filter
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}/logging".format(id=id)
    headers = {}

    body = body or {}
    # Only send logLevel if the argument was provided, don't send null values
    if logLevel is not None:
        body.update({"logLevel": logLevel})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response


@register_command(extending=("eventfilters", "v2", "match"), module=argus_cli_module)
def update_match_filter(
    id: int,
    comment: str,
    actions: dict = None,
    addLabels: str = None,
    description: str = None,
    filters: dict = None,
    index: int = None,
    name: str = None,
    removeLabels: str = None,
    setLabels: str = None,
    validFrom: str = None,
    validTo: str = None,
    json: bool = True,
    verify: bool = None,
    proxies: dict = None,
    apiKey: str = None,
    authentication: dict = {},
    server_url: str = None,
    body: dict = None,
) -> dict:
    r"""Updates a match filter (INTERNAL)

    :param int id: ID of filter
    :param str comment: A comment describing why the filter was created
    :param dict actions:
    :param list addLabels: A set of labels to add to the filter.  Will be applied after removing labels. Will throw an exception if used in conjunction with setLabels
    :param str description: A description of the filter
    :param dict filters:
    :param int index: The index of the filter. Filters with lower index will be ran first.
    :param str name: The name of the filter
    :param list removeLabels: A set of labels to remove from the filter.  Will be applied before adding labels and ignore filters that are not present. Will throw an exception if used in conjunction with setLabels
    :param list setLabels: Replace the current set of labels with these. Will throw an exception if used in conjunction with addLabels or removeLabels
    :param str validFrom: When the filter starts being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param str validTo: When the filter stops being applied. Timestamp can be milliseconds since epoch\, ISO8601 timestamp\, or a string with a relative timestamp. See the general integration guide for more details. Null values will be ignored. Use 0 to unset  Allows to specify a unix timestamp \(milliseconds\)\, ISO timestamp\, or relative time.
    :param json: return the response's body as a ``dict`` parsed from json. ``True`` by
      default. If set to false, the raw ``requests.Response`` object will be returned.
    :param verify: path to a certificate bundle or boolean indicating whether SSL
      verification should be performed.
    :param apiKey: Argus API key.
    :param authentication: authentication override
    :param server_url: API base URL override
    :param body: body of the request. other parameters will override keys defined in the body.
    :raises AuthenticationFailedException: on 401
    :raises AccessDeniedException: on 403
    :raises ObjectNotFoundException: on 404
    :raises ValidationFailedException: on 412
    :raises ArgusException: on other status codes

    :returns: dictionary translated from JSON
    """

    route = "/eventfilters/v2/match/{id}".format(id=id)
    headers = {}

    body = body or {}
    # Only send actions if the argument was provided, don't send null values
    if actions is not None:
        body.update({"actions": actions})
    # Only send addLabels if the argument was provided, don't send null values
    if addLabels is not None:
        body.update({"addLabels": addLabels})
    # Only send comment if the argument was provided, don't send null values
    if comment is not None:
        body.update({"comment": comment})
    # Only send description if the argument was provided, don't send null values
    if description is not None:
        body.update({"description": description})
    # Only send filters if the argument was provided, don't send null values
    if filters is not None:
        body.update({"filters": filters})
    # Only send index if the argument was provided, don't send null values
    if index is not None:
        body.update({"index": index})
    # Only send name if the argument was provided, don't send null values
    if name is not None:
        body.update({"name": name})
    # Only send removeLabels if the argument was provided, don't send null values
    if removeLabels is not None:
        body.update({"removeLabels": removeLabels})
    # Only send setLabels if the argument was provided, don't send null values
    if setLabels is not None:
        body.update({"setLabels": setLabels})
    # Only send validFrom if the argument was provided, don't send null values
    if validFrom is not None:
        body.update({"validFrom": validFrom})
    # Only send validTo if the argument was provided, don't send null values
    if validTo is not None:
        body.update({"validTo": validTo})

    log.debug("PUT %s (headers: %s, body: %s)" % (route, str(headers), str(body) or ""))

    response = session.put(
        route,
        json=body,
        verify=verify,
        apiKey=apiKey,
        authentication=authentication,
        server_url=server_url,
        headers=headers,
        proxies=proxies,
    )
    return response.json() if json else response
