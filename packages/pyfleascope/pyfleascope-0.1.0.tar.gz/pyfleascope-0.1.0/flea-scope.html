<td>
<input type="text" id="delay" onchange='Send(String.fromCharCode(3));'' value="0u" size="2"></input>
</td>
<td>
<select id="probe" onchange='Send(String.fromCharCode(3)); Probe();'>
<option selected value="1">x1</option>
<option value="10">x10</option>
</select>
</td>
</td>
<td>
<select id="wave" onchange="Wave();">
<option>ekg</option>
<option selected>sine</option>
<option>square</option>
<option>triangle</option>
</select>


<script>
'use strict';

var webpage;

var usb;
var comm;
var epin = 2;
var epout = 3;
var reader;
var writer;
var enc = new TextEncoder();
var dec = new TextDecoder();
var canvas;
var labels;
var bytes = 1024;

var discard;
var discarded;
var string = "";
var running = "";

var digital = false;

var bg = false;

var avgV = 0;  // ac only
var analogV = 0;  // 0..v or -v..v (must be multiplied by p!)
var measure = 0;

const MSPS = 18;  // approximate target sample rate
const SAMPLES = 2000*MSPS/20;  // approximate width of display canvas
const EXTRA = 200;  // extra samples in case web page wants to fine-scale
const INTERLEAVE = 5;  // we interleave results from 5 adcs
const DIVSV = 10;
const DIVST = 20;
const VERT = 4;

const bus_frequency = 120000000;
const bus_mhz = bus_frequency/1000000;

var msps;  // actual based on mcu timer pr

var width = SAMPLES*2;  // actual display width after ScaleCanvas()
var height = 256;
var bits = 9;


// return time for fraction of display width
function usec(frac, scale, fixed)
{
    var usecv = parseInt(document.getElementById("qusec").value);  // this is per-division
    if (usecv < 0) {
        usecv = -5/usecv;
    } else {
        usecv *= 5;
    }
    usecv = usecv * DIVST * frac;
    var usecs;
    if (scale && usecv >= 1000) {
        usecs = "" + (usecv/1000).toFixed(fixed) + "ms";
    } else {
        usecs = "" + (usecv).toFixed(fixed) + "us";
    }
    return usecs;
}

// return frequency for fraction of display width
function freq(frac, scale, fixed)
{
    var usecv = parseInt(document.getElementById("qusec").value);  // this is per-division
    if (usecv < 0) {
        usecv = -5/usecv;
    } else {
        usecv *= 5;
    }
    usecv = usecv * DIVST * frac;
    var freqv = 1000000/usecv;
    var freqs;
    if (scale && freqv >= 1000000) {
        freqs = "" + (freqv/1000000).toFixed(fixed) + "MHz";
    } else if (scale && freqv >= 1000) {
        freqs = "" + (freqv/1000).toFixed(fixed) + "kHz";
    } else {
        freqs = "" + (freqv).toFixed(fixed) + "Hz";
    }
    return freqs;
}

// the user loaded the webpage; set up keyboard listeners
function Body()
{
    webpage = location.pathname.split("/").slice(-1)[0];

    if (webpage.match(/manual/)) {
        document.getElementById("start1").hidden = false;
        document.getElementById("start2").hidden = false;

        document.getElementById("help").innerHTML += "<p>" + navigator.userAgent;
        for (var vv in navigator) {
            document.getElementById("help").innerHTML += vv + ", ";
        }
        document.getElementById("help").innerHTML += "</p>";
    }

    if (/\b(Linux)\b/.test(navigator.userAgent)) {
        // linux gets ooo data at larger web serial buffer sizes
        bytes = 256;
    }

    canvas = document.getElementById('canvas');
    labels = document.getElementById('labels');
    ScaleCanvas();

    canvas.addEventListener('mousedown', function(e) {
        var v = parseFloat(document.getElementById("volts").value);
        var p = parseFloat(document.getElementById("probe").value);
        var r = parseFloat(document.getElementById("polar").value);
        down = true;
        if (! measure) {
            Send(String.fromCharCode(3));  // Ctrl-C
            var analogY = Math.min(Math.max(e.offsetY, 0), 255);  // 0..255 (0..height-1)
            analogV = (height/r - (analogY+1))/(height/r)*v;  // 0..v or -v..v
            analogV += avgV;
            document.getElementById("status").innerHTML = "trigger = " + (analogV*p).toFixed(2) + "V";
            Display();
        } else {
            if (measure == 1) {
                oldX = newX;
                oldY = newY;
                newX = e.offsetX;
                newY = e.offsetY;
                document.getElementById('measure').style.color = 'black';
                measure = 0;
            } else {
                newX = e.offsetX;
                newY = e.offsetY;
                measure = 1;
            }
            ShowStatus();
            ShowPoints();
        }
    });

    canvas.addEventListener('mouseup', function(e) {
        down = false;
    });
}

// the user wants to connect to a USB device's bulk endpoints directly

async function Display()
{
    // result is in string
    var lines = string.split(/\r?\n/);

    var bw = document.querySelector('body').classList.contains('dark')

    var ctx;

    // draw vertical labels
    ctx = labels.getContext('2d');

    ctx.clearRect(0, 0, 50, 546);

    ctx.font = `12px Verdana`;

    var v = parseFloat(document.getElementById("volts").value);
    var p = parseFloat(document.getElementById("probe").value);
    var r = parseFloat(document.getElementById("polar").value);
    var ac = document.getElementById("polar").value == "2.";

    // voltage
    if (document.getElementById("polar").value == 1) {
        ctx.fillText("" + +(v*p).toFixed(2) + "V", 0, 10);
        ctx.fillText("" + +(v*p/2).toFixed(2) + "V", 0, 128);
        ctx.fillText("0V", 0, 256);
    } else {
        ctx.fillText("+" + +(v*p).toFixed(2) + "V", 0, 10);
        if (document.getElementById("polar").value == "2") {
            ctx.fillText("0V", 0, 128);
        } else {
            ctx.fillText("avg V", 0, 128);
        }
        ctx.fillText("-" + +(v*p).toFixed(2) + "V", 0, 256);
    }

    var b;

    // bits
    for (b = 0; b < bits; b++) {
        sy = 305+b*30;

        ctx.fillText("b"+b, 0, sy-2);
    }

    // draw lines and horizontal labels
    ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, width, 546);

    ShowPoints();

    for (var i = 0; i <= DIVST; i++) {
        if (i%(DIVSV/2) == 0) {
            ctx.setLineDash([6, 10]);
        } else {
            ctx.setLineDash([2, 10]);
        }
        ctx.beginPath();
        ctx.moveTo(width/DIVST*i, 0);
        ctx.lineTo(width/DIVST*i, 255);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(width/DIVST*i, 305-20);
        ctx.lineTo(width/DIVST*i, 305+bits*30);
        ctx.stroke();
        ctx.setLineDash([]);

        var t = "" + usec(i/DIVST, true, 2).replace(/[.]*0+([mu])/,"$1");
        var w = (i==DIVST)?(ctx.measureText(t).width):((i)?(ctx.measureText(t).width/2):0);
        ctx.fillText(t, (width/DIVST*i)-w, 274);
    }

    if (! digital) {
        var analogY;  // 0..255 (0..height-1)
        if (analogV > v+avgV) {
            analogY = 0;
            ctx.setLineDash([10, 4]);
            ctx.strokeStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(0, analogY);
            ctx.lineTo(width, analogY);
            ctx.stroke();
        } else if ((r == 1 && analogV < 0+avgV) || (r == 2 && analogV < -v+avgV)) {
            analogY = 255;
            ctx.setLineDash([10, 4]);
            ctx.strokeStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(0, analogY);
            ctx.lineTo(width, analogY);
            ctx.stroke();
        } else {
            if (r == 1) {
                analogY = 256 - Math.floor((analogV-avgV)*255/(v));
            } else {
                analogY = 256 - Math.floor((analogV-avgV+v)*255/(2*v));
            }
            ctx.setLineDash([10, 4]);
            ctx.strokeStyle = '#00BF00';
            ctx.beginPath();
            ctx.moveTo(0, analogY);
            ctx.lineTo(width, analogY);
            ctx.stroke();
        }
    }

    for (i = 0; i < VERT+1; i++) {
        ctx.beginPath();
        ctx.strokeStyle = '#000000';
        if (i%(VERT/2) == 0) {
            ctx.setLineDash([bw?4:6, 10]);
        } else {
            ctx.setLineDash([bw?1:2, 10]);
        }
        ctx.moveTo(0, (height-1)*i/VERT);
        ctx.lineTo(width, (height-1)*i/VERT);
        ctx.stroke();
    }

    ctx.setLineDash([]);

    if (lines.length >= 100 || string == "") {
        // scope result

        var sx, sy, sh;

        var path;
        path = new Path2D();  // analog
        path.moveTo(0, 255);

        var paths = [];
        var lastBit = [];
        for (var b = 0; b < bits; b++) {
            sy = 305+b*30;

            paths[b] = new Path2D();  // digital
            paths[b].moveTo(0, sy);
            lastBit[b] = false;
        }

        sh = 20;

        var adcmin = 1023;
        var adcmax = 0;
        var adcsum = 0;
        var adcrms = 0;

        var j;

        adcrawcount = 0;
        adcrawsum = 0;

        var inr = false;

        // compute adcmin, adcmax, adcavg up front
        for (i = 0; i < width/2 && i < lines.length; i++) {
            // XXX -- if we find "done", reset to 0 and keep going
            var twelve = lines[i].match(/,/);
            var words = lines[i].split(/[ ,]/);
            var adc = parseInt(words[0]);  // 0..1023 for roughly -6.6V to 6.6V at BNC
            if (twelve) {
                adc /= 4;  // N.B. no longer integer!
            }

            adcrawsum += adc;
            adcrawcount++;

            var adcscaled = (adc-GetZero()-512)/(Get3v3())*256 + 512;  // 0..1023

            if (adcscaled < adcmin) {
                adcmin = adcscaled;
            }
            if (adcscaled > adcmax) {
                adcmax = adcscaled;
            }

            adcsum += adcscaled;
        }
        var adcavg = adcsum/i;

        ctx.lineWidth = 1.5;

        // plot points and compute adcrms
        for (i = 0; i < width/2 && i < lines.length; i++) {
            // XXX -- if we find "done", reset to 0 and keep going
            var twelve = lines[i].match(/,/);
            var words = lines[i].split(/[ ,]/);
            var adc = parseInt(words[0]);  // 0..1023 for roughly -6.6V to 6.6V at BNC
            if (twelve) {
                adc /= 4;  // N.B. no longer integer!
            }
            var byte = parseInt(words[1]);

            var adcscaled = (adc-GetZero()-512)/(Get3v3())*256 + 512;  // 0..1023

            if (adcscaled >= adcavg) {
                adcrms += (adcscaled-adcavg)*(adcscaled-adcavg);
            } else {
                adcrms += (adcavg-adcscaled)*(adcavg-adcscaled);
            }

            if (ac) {
                adcscaled = (adcscaled-512)-(adcavg-512)+512;
            }

            var adcv = (adcscaled-512) * adcfull/v + 512;  // 0..1023 or more

            sx = i*2;
            
            var oor;
            var minv = 0;
            var divv = 4;
            if (document.getElementById("polar").value == 1) {
                minv = 512;
                divv = 2;
            }
            oor = (adcv < minv*98/100) || (adcv > 1023*102/100);

            if (adcv < minv) {
                adcv = minv;
            } else if (adcv > 1023) {
                adcv = 1023;
            }

            path.lineTo(sx, (512/divv)-Math.round((adcv-512)/divv));

            if (oor != inr) {
                ctx.stroke(path);
                if (oor) {
                    ctx.strokeStyle = '#FF0000';
                } else {
                    ctx.strokeStyle = '#000000';
                }
                path = new Path2D();  // analog
                path.moveTo(sx, (512/divv)-Math.round((adcv-512)/divv));
                inr = oor;
            }

            for (b = 0; b < bits; b++) {
                sy = 305+b*30;

                var bit = (byte & (1 << b)) != 0;
                if (bit == lastBit[b]) {
                    paths[b].lineTo(sx, sy - (bit?sh:0));
                } else {
                    paths[b].lineTo(sx, sy - (lastBit[b]?sh:0));
                    paths[b].lineTo(sx, sy - (bit?sh:0));
                }
                lastBit[b] = bit;
            }
        }
        adcrms = Math.pow(adcrms/i, 0.5);

        if (ac) {
            avgV = (adcsum/i-512)/512*adcfull;
        } else {
            avgV = 0;
        }
        document.getElementById("voltage").innerHTML = "" + voltadc(adcsum/i, false, 2) + " avg; " +
                                                            voltadc(adcmax-adcmin+512, false, 2) + " pp; " +
                                                            voltadc(adcrms+512, false, 2) + " rms";

        path.moveTo(width, 255);
        ctx.stroke(path);
        ctx.strokeStyle = '#000000';

        sx = i*2;
        for (b = 0; b < bits; b++) {
            sy = 305+b*30;

            if (false == lastBit[b]) {
                paths[b].lineTo(sx, sy - (false?sh:0));
            } else {
                paths[b].lineTo(sx, sy - (lastBit[b]?sh:0));
                paths[b].lineTo(sx, sy - (false?sh:0));
            }

            if (document.getElementById("b"+b).value != "") {
                ctx.strokeStyle = '#00BF00';
            }
            ctx.stroke(paths[b]);
            if (document.getElementById("b"+b).value != "") {
                ctx.strokeStyle = '#000000';
            }
        }

        ctx.lineWidth = 1;

    } else if (running.match(/ver/) && lines.length > 0) {
        // ver result

        ver = lines[0];
        if (ver != "2.27g (checksum 0x7c8e)" && ver.split()[0] <= "2.27g") {
            ver += " -- <font color='red'>PLEASE UPGRADE!</font>";
        }
        document.getElementById("ver").innerHTML = "<b>" + ver + "</b>";
    }
}

// receive a string from the device
async function Receive()
{
    var str;
    var result;

    if (usb) {
        result = await usb.transferIn(epin, bytes);
        str = dec.decode(result.data.buffer);
    } else {
        result = await reader.read();
        str = dec.decode(result.value);
    }
    if (! discard) {
        string += str.replace(/</g,'&lt;').replace(/>/g,'&gt;');
        if (string.match(/done\r\n$/)) {
            // we have scope or other results!
            string = string.replace(/done\r\n$/g, "");
            clearTimeout(waiting);
            document.getElementById("command").innerHTML = " ";  // N.B. need space to avoid jitter!
            Display();
            running = "";
            setTimeout(Next, 1);
        }
    } else {
        discarded = true;
    }
    setTimeout(Receive, 1);
}

</script>
</body>
</html>
