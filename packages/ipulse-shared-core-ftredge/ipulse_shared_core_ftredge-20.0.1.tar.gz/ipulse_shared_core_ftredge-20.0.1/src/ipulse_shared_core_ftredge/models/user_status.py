""" User Status model for tracking user subscription and access rights. """
from datetime import datetime, timezone
from dateutil.relativedelta import relativedelta  # Add missing import
from typing import Set, Optional, Dict, List, ClassVar, Any
from pydantic import Field, ConfigDict, field_validator, computed_field, BaseModel, model_validator
from ipulse_shared_base_ftredge import Layer, Module, list_as_lower_strings, Subject,SubscriptionPlan, SubscriptionStatus
from ipulse_shared_base_ftredge.enums.enums_iam import IAMUnitType
from .subscription import Subscription
from .base_data_model import BaseDataModel

# ORIGINAL AUTHOR ="Russlan Ramdowar;russlan@ftredge.com"
# CLASS_ORGIN_DATE=datetime(2024, 2, 12, 20, 5)

class IAMUnitRefAssignment(BaseModel):
    """
    Represents an IAM assignment (for groups, roles, or permissions) with expiration tracking.
    """
    # Identity of the IAM unit reference
    iam_unit_ref: str = Field(
        ...,
        description="Reference name of the IAM unit (e.g., 'base_subscription_group')"
    )

    # Expiration tracking
    expires_at: Optional[datetime] = Field(
        default=None,
        description="When this assignment expires (null for permanent)"
    )

    source: str = Field(
        ...,
        description="Source of this assignment (subscription plan ID, 'system_default', etc.)"
    )

    def is_valid(self) -> bool:
        """Check if the assignment is currently valid (not expired)."""
        if self.expires_at is None:
            return True
        return datetime.now(timezone.utc) <= self.expires_at

############################ !!!!! ALWAYS UPDATE SCHEMA VERSION , IF SCHEMA IS BEING MODIFIED !!! #################################
class UserStatus(BaseDataModel):
    """
    User Status model for tracking user subscription and access rights.
    """
    # Set frozen=False to allow modification of attributes
    model_config = ConfigDict(frozen=False, extra="forbid")

    # Class constants
    VERSION: ClassVar[float] = 5.1  # Incremented version for removing computed fields
    DOMAIN: ClassVar[str] = "_".join(list_as_lower_strings(Layer.PULSE_APP, Module.CORE.name, Subject.USER.name))
    OBJ_REF: ClassVar[str] = "userstatus"

    # Centralized collection name and document ID prefix
    COLLECTION_NAME: ClassVar[str] = "papp_core_user_userstatuss"


    # System-managed fields
    schema_version: float = Field(
        default=VERSION,
        frozen=True,
        description="Version of this Class == version of DB Schema"
    )

    id: str = Field(
        ...,  # Still required, but will be auto-generated by model_validator if not provided
        description=f"User ID, format: {OBJ_REF}_user_uid"
    )

    user_uid: str = Field(
        ...,
        description="User UID from Firebase Auth"
    )

    # Added organizations field for consistency with UserProfile
    organizations_uids: Set[str] = Field(
        default_factory=set,
        description="Organization UIDs the user belongs to"
    )

    # Enhanced IAM permissions structure with expiration - update to use string for enum keys
    iam_domain_permissions: Dict[str, Dict[str, Dict[str, IAMUnitRefAssignment]]] = Field(
        ...,
        description="Domain -> IAM unit type (groups/roles/permissions) -> unit reference name -> assignment details (with expiration)"
    )

    # Subscription Management - Single active subscription instead of dictionary
    subscriptions_history: Dict[str, Subscription] = Field(
        default_factory=dict,  # Initialize with empty dict
        description="Dictionary of user\'s past recent subscriptions, keyed by subscription ID"
    )

    # Changed from dictionary to single Optional subscription
    active_subscription: Optional[Subscription] = Field(
        default=None,
        description="The user's currently active subscription, if any"
    )

    # Credit management fields
    sbscrptn_based_insight_credits: int = Field(
        ...,
        description="Subscription-based insight credits (expire with subscription)"
    )

    sbscrptn_based_insight_credits_updtd_on: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Last update timestamp for subscription credits"
    )

    extra_insight_credits: int = Field(
        ...,
        description="Additional purchased insight credits (non-expiring)"
    )

    extra_insight_credits_updtd_on: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Last update timestamp for extra credits"
    )

    voting_credits: int = Field(
        ...,
        description="Voting credits for user"
    )

    voting_credits_updtd_on: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Last update timestamp for voting credits"
    )

    metadata: Dict[str, Any] = Field(
        default_factory=dict,
        description="Additional metadata for the user status"
    )

    @model_validator(mode='before')
    @classmethod
    def ensure_id_exists(cls, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Ensures the id field exists by generating it from user_uid if needed.
        This runs BEFORE validation, guaranteeing id will be present for validators.
        """
        if not isinstance(data, dict):
            return data

        # If id is already in the data, leave it alone
        if 'id' in data and data['id']:
            return data

        # If user_uid exists but id doesn't, generate id from user_uid
        if 'user_uid' in data and data['user_uid']:
            data['id'] = f"{cls.OBJ_REF}_{data['user_uid']}"

        return data

    # Utility methods for subscription management - updated for single subscription

    def get_active_subscription(self) -> Optional[Subscription]:
        """Get the currently active subscription if it exists."""
        return self.active_subscription

    def get_subscription_plan_name(self) -> Optional[SubscriptionPlan]:
        """Get the current subscription plan name."""
        if self.active_subscription:
            return self.active_subscription.plan_name
        return None

    def has_valid_permission_type_for_domain(self, domain: str, iam_unit_type: IAMUnitType = IAMUnitType.GROUPS) -> bool:
        """Check if the user has any valid IAM permissions of specified type for the domain."""
        if domain not in self.iam_domain_permissions:
            return False

        # Update to use string value from enum
        domain_permissions = self.iam_domain_permissions[domain].get(iam_unit_type.value, {})
        return any(assignment.is_valid() for assignment in domain_permissions.values())

    def has_valid_groups_for_domain(self, domain: str) -> bool:
        """Check if the user has any valid IAM groups for the specified domain (legacy method)."""
        return self.has_valid_permission_type_for_domain(domain, IAMUnitType.GROUPS)

    def get_valid_permissions_for_domain(self, domain: str, iam_unit_type: IAMUnitType = IAMUnitType.GROUPS) -> List[str]:
        """Get a list of valid (non-expired) permission names of specified type for the domain."""
        if domain not in self.iam_domain_permissions:
            return []

        # Update to use string value from enum
        domain_permissions = self.iam_domain_permissions[domain].get(iam_unit_type.value, {})
        return [
            iam_unit_ref
            for iam_unit_ref, assignment in domain_permissions.items()
            if assignment.is_valid()
        ]

    def get_valid_groups_for_domain(self, domain: str) -> List[str]:
        """Get a list of valid (non-expired) group names for the domain (legacy method)."""
        return self.get_valid_permissions_for_domain(domain, IAMUnitType.GROUPS)

    def add_iam_unit_ref_assignment(
        self,
        domain: str,
        iam_unit_ref: str,
        iam_unit_type: IAMUnitType,
        source: str,
        expires_at: Optional[datetime] = None
    ) -> None:
        """
        Add a permission assignment to the user's IAM domain permissions.

        Args:
            domain: The domain for the permission (e.g., 'papp')
            iam_unit_ref: The name/identifier of the permission to add
            iam_unit_type: Type of IAM assignment (GROUP, ROLE, PERMISSION)
            source: Source identifier for this assignment (e.g., subscription ID)
            expires_at: Optional expiration date
        """
        # Ensure domain exists
        if domain not in self.iam_domain_permissions:
            self.iam_domain_permissions[domain] = {}

        # Ensure permission type section exists - use string value from enum
        if iam_unit_type.value not in self.iam_domain_permissions[domain]:
            self.iam_domain_permissions[domain][iam_unit_type.value] = {}

        # Create new assignment
        assignment = IAMUnitRefAssignment(
            iam_unit_ref=iam_unit_ref,
            source=source,
            expires_at=expires_at
        )

        # Add the permission - use string value from enum
        self.iam_domain_permissions[domain][iam_unit_type.value][iam_unit_ref] = assignment

    def add_group_assignment(
        self,
        domain: str,
        group_name: str,
        source: str,
        expires_at: Optional[datetime] = None
    ) -> None:
        """
        Add a group assignment to the user's IAM groups (legacy method).

        Args:
            domain: The domain for the group (e.g., 'papp')
            group_name: The name of the group to add
            source: Source identifier for this assignment (e.g., subscription ID)
            expires_at: Optional expiration date
        """
        self.add_iam_unit_ref_assignment(domain, group_name, IAMUnitType.GROUPS, source, expires_at)

    def remove_expired_iam_unit_refs(self, iam_unit_type: Optional[IAMUnitType] = None) -> int:
        """
        Remove all expired permission assignments of a specific type or all types.

        Args:
            iam_unit_type: If provided, only remove this type of permissions

        Returns:
            Number of removed permission assignments
        """
        now = datetime.now(timezone.utc)
        removed_count = 0

        # Create a deep copy of domains to avoid modification during iteration
        domains = list(self.iam_domain_permissions.keys())

        for domain in domains:
            # If iam_unit_type is specified, only check that type
            if iam_unit_type:
                unit_type_value = iam_unit_type.value
                if unit_type_value not in self.iam_domain_permissions[domain]:
                    continue

                iam_unit_types_to_check = [unit_type_value]
            else:
                # Check all permission types
                iam_unit_types_to_check = list(self.iam_domain_permissions[domain].keys())

            # Process each permission type
            for perm_type in iam_unit_types_to_check:
                # Create a list of permissions to remove
                permissions_to_remove = [
                    iam_unit_ref
                    for iam_unit_ref, assignment in self.iam_domain_permissions[domain][perm_type].items()
                    if assignment.expires_at and assignment.expires_at < now
                ]

                # Remove expired permissions
                for iam_unit_ref in permissions_to_remove:
                    del self.iam_domain_permissions[domain][perm_type][iam_unit_ref]
                    removed_count += 1

        return removed_count

    def remove_expired_groups(self) -> int:
        """
        Remove all expired group assignments (legacy method).

        Returns:
            Number of removed group assignments
        """
        return self.remove_expired_iam_unit_refs(IAMUnitType.GROUPS)

    def update_iam_unit_refs_from_subscription(self, subscription: Subscription) -> int:
        """
        Update IAM permissions based on a subscription.

        Args:
            subscription: Subscription to apply

        Returns:
            Number of permission assignments added
        """
        added_count = 0

        for domain, permissions_by_type in subscription.default_iam_domain_permissions.items():
            for iam_unit_type_str, iam_unit_refs in permissions_by_type.items():
                # Convert string to enum if needed for internal processing
                try:
                    iam_unit_type = IAMUnitType(iam_unit_type_str)
                    for iam_unit_ref in iam_unit_refs:
                        self.add_iam_unit_ref_assignment(
                            domain=domain,
                            iam_unit_ref=iam_unit_ref,
                            iam_unit_type=iam_unit_type,
                            source=f"{subscription.plan_name.value}_v{subscription.plan_version}",
                            expires_at=subscription.cycle_end_date
                        )
                        added_count += 1
                except ValueError:
                    # Skip invalid unit types
                    continue

        return added_count

    def update_groups_from_subscription(self, subscription: Subscription) -> int:
        """
        Update IAM groups based on a subscription (legacy method).

        Args:
            subscription: Subscription to apply

        Returns:
            Number of group assignments added
        """
        return self.update_iam_unit_refs_from_subscription(subscription)

    # Method instead of computed field
    def is_subscription_active(self) -> bool:
        """Check if the user has an active subscription."""
        if self.active_subscription:
            return self.active_subscription.is_active()
        return False

    # Method instead of computed field
    def subscription_expires_in_days(self) -> Optional[int]:
        """Get days until subscription expiration."""
        if self.active_subscription and self.active_subscription.is_active():
            return self.active_subscription.days_remaining()
        return None

    def apply_subscription(self, subscription: Subscription) -> None:
        """
        Apply a subscription's benefits to the user status.
        This updates credits, permissions, and sets the active subscription.

        Args:
            subscription: The subscription to apply
        """
        if not subscription:
            return

        # Add IAM permissions from subscription
        self.update_iam_unit_refs_from_subscription(subscription)

        # Update subscription-based credits
        credits_per_update = subscription.subscription_based_insight_credits_per_update
        if credits_per_update > 0:
            self.sbscrptn_based_insight_credits = credits_per_update
            self.sbscrptn_based_insight_credits_updtd_on = datetime.now(timezone.utc)

        # Update voting credits directly from subscription attributes
        voting_credits = subscription.voting_credits_per_update
        if voting_credits > 0:
            self.voting_credits = voting_credits
            self.voting_credits_updtd_on = datetime.now(timezone.utc)

        # Store subscription details
        self.active_subscription = subscription

    def revoke_subscription(self) -> None:
        """
        Revoke the current subscription benefits.
        This clears subscription-based credits and removes the active subscription.
        """
        if not self.active_subscription:
            return

        # Clear subscription-based credits and active subscription
        self.sbscrptn_based_insight_credits = 0
        self.sbscrptn_based_insight_credits_updtd_on = datetime.now(timezone.utc)
        self.active_subscription = None

    def apply_subscription_plan(self,
                               plan_data: Dict[str, Any],
                               source: str = "default_configuration",
                               expires_at: Optional[datetime] = None) -> None:
        """
        Apply a subscription plan\'s benefits from plan data dictionary.

        Args:
            plan_data: Dictionary containing subscription plan details
            source: Source identifier for this application
            expires_at: Optional expiration date for the subscription
        """
        # Default expiration date (1 month from now) if not provided
        if not expires_at:
            expires_at = datetime.now(timezone.utc) + relativedelta(months=1)

        # Extract IAM permissions
        iam_domain_permissions = plan_data.get("default_iam_domain_permissions", {})

        # Extract plan name - no default fallbacks
        plan_name_str = plan_data.get("plan_name")
        if not plan_name_str:
            # Consider logging a warning or raising an error if plan_name is critical
            return  # Cannot create subscription without plan name

        try:
            plan_name = SubscriptionPlan(plan_name_str)
        except ValueError:
            # Consider logging a warning or raising an error for invalid plan_name
            return  # Invalid plan name

        # Extract required fields - no default fallbacks
        plan_version = plan_data.get("plan_version")
        validity_time_length = plan_data.get("plan_validity_cycle_length")
        validity_time_unit = plan_data.get("plan_validity_cycle_unit")

        # If any required field is missing, return without creating subscription
        if plan_version is None or validity_time_length is None or validity_time_unit is None:
            # Consider logging a warning or raising an error if these fields are critical
            return

        # Calculate directly assigned fields
        plan_id = f"{plan_name_str}_{plan_version}" # Use the string version for ID
        cycle_start_date = datetime.now(timezone.utc)

        # Ensure cycle_end_date is calculated correctly using the provided expires_at or calculated from plan details
        # If expires_at is provided, it should ideally align with plan's cycle, but we prioritize it if present.
        # However, the current Subscription.calculate_cycle_end_date might be more robust if plan details are the source of truth.
        # For now, let's assume expires_at is a specific override if provided, otherwise calculate from plan.
        # This logic might need refinement based on how expires_at is intended to be used.
        # If expires_at is meant to be the definitive end date, use it. Otherwise, calculate.
        # The original code used expires_at for IAM assignments but calculated cycle_end_date for the subscription object itself.
        # Let's stick to calculating cycle_end_date from plan details for the Subscription object for consistency.

        cycle_end_date = Subscription.calculate_cycle_end_date(
            cycle_start_date,
            validity_time_length,
            validity_time_unit
        )

        # If an explicit expires_at is given and differs, it might indicate a special case (e.g. trial ending sooner)
        # For IAM assignments, the original code used the `expires_at` passed to `apply_subscription_plan`
        # For the subscription object itself, it calculated `cycle_end_date`.
        # We will use the calculated `cycle_end_date` for the subscription object.
        # The `expires_at` for IAM assignments will be handled by `update_iam_unit_refs_from_subscription`
        # which uses `subscription.cycle_end_date`.

        # Create subscription object with direct fields instead of computed
        subscription = Subscription(
            plan_name=plan_name, # Enum version
            plan_version=plan_version,
            plan_id=plan_id, # String version
            cycle_start_date=cycle_start_date,
            cycle_end_date=cycle_end_date, # Calculated cycle_end_date
            validity_time_length=validity_time_length,
            validity_time_unit=validity_time_unit,
            auto_renew=plan_data.get("plan_auto_renewal", False),
            status=SubscriptionStatus.ACTIVE, # Default to ACTIVE when applying
            default_iam_domain_permissions=iam_domain_permissions,
            fallback_plan_id=plan_data.get("fallback_plan_id_if_current_plan_expired"),
            price_paid_usd=plan_data.get("plan_per_cycle_price_usd") or 0.0,
            created_by=source,
            updated_by=source,
            subscription_based_insight_credits_per_update=plan_data.get("subscription_based_insight_credits_per_update") or 0,
            subscription_based_insight_credits_update_freq_h=plan_data.get("subscription_based_insight_credits_update_freq_h") or 24,
            extra_insight_credits_per_cycle=plan_data.get("extra_insight_credits_per_cycle") or 0,
            voting_credits_per_update=plan_data.get("voting_credits_per_update") or 0,
            voting_credits_update_freq_h=plan_data.get("voting_credits_update_freq_h") or 62 # Corrected typo from 62 to, e.g., 720 for monthly if intended
        )

        # Apply this new subscription
        self.apply_subscription(subscription)