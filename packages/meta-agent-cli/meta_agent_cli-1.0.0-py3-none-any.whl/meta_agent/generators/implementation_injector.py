"""
Implementation Injector for LLM-generated Tool Code.

This module provides the ImplementationInjector class which injects
generated implementation code into tool templates.
"""

import logging
from typing import Any


class ImplementationInjector:
    """
    Injects generated implementation code into tool templates.
    
    This class is responsible for taking the code generated by an LLM and
    injecting it into a tool template to create a complete, executable tool.
    """
    
    def __init__(self, template_engine):
        """
        Initialize the ImplementationInjector with a template engine.
        
        Args:
            template_engine: Engine for rendering templates
        """
        self.template_engine = template_engine
        self.logger = logging.getLogger(__name__)
        
    def inject(self, generated_code: str, tool_specification: Any) -> str:
        """
        Inject the generated code into the tool template.
        
        This method takes the generated implementation code and combines it
        with the tool specification to create a complete tool implementation
        using a template.
        
        Args:
            generated_code: The implementation code generated by the LLM
            tool_specification: The specification for the tool
            
        Returns:
            str: The complete tool code with the implementation injected
            
        Raises:
            ValueError: If the generated code is empty or invalid
            RuntimeError: If template rendering fails
        """
        self.logger.info(f"Injecting implementation for tool: {getattr(tool_specification, 'name', 'unnamed')}")
        
        # Validate the generated code
        if not generated_code or not generated_code.strip():
            error_msg = "Generated code is empty or whitespace-only"
            self.logger.error(error_msg)
            raise ValueError(error_msg)
        
        # Prepare the template data
        template_data = {
            "name": getattr(tool_specification, 'name', 'UnnamedTool'),
            "description": getattr(tool_specification, 'description', 'No description provided'),
            "input_params": getattr(tool_specification, 'input_params', []),
            "output_format": getattr(tool_specification, 'output_format', 'No output format specified'),
            "implementation": generated_code
        }
        
        try:
            # Render the template with the data
            self.logger.debug("Rendering tool template")
            template = self.template_engine.get_template("tool_template.j2")
            complete_tool_code = template.render(template_data)
            
            self.logger.info("Implementation injected successfully")
            return complete_tool_code
        except Exception as e:
            error_msg = f"Failed to render tool template: {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            raise RuntimeError(error_msg) from e
    
    def inject_with_custom_template(self, generated_code: str, 
                                   tool_specification: Any,
                                   template_name: str) -> str:
        """
        Inject the generated code using a custom template.
        
        This method is similar to inject() but allows specifying a custom
        template to use instead of the default.
        
        Args:
            generated_code: The implementation code generated by the LLM
            tool_specification: The specification for the tool
            template_name: The name of the custom template to use
            
        Returns:
            str: The complete tool code with the implementation injected
            
        Raises:
            ValueError: If the generated code is empty or invalid
            RuntimeError: If template rendering fails
        """
        self.logger.info(f"Injecting implementation with custom template '{template_name}'")
        
        # Validate the generated code
        if not generated_code or not generated_code.strip():
            error_msg = "Generated code is empty or whitespace-only"
            self.logger.error(error_msg)
            raise ValueError(error_msg)
        
        # Prepare the template data
        template_data = {
            "name": getattr(tool_specification, 'name', 'UnnamedTool'),
            "description": getattr(tool_specification, 'description', 'No description provided'),
            "input_params": getattr(tool_specification, 'input_params', []),
            "output_format": getattr(tool_specification, 'output_format', 'No output format specified'),
            "implementation": generated_code
        }
        
        try:
            # Render the custom template with the data
            self.logger.debug(f"Rendering custom template: {template_name}")
            template = self.template_engine.get_template(template_name)
            complete_tool_code = template.render(template_data)
            
            self.logger.info("Implementation injected successfully with custom template")
            return complete_tool_code
        except Exception as e:
            error_msg = f"Failed to render custom template '{template_name}': {str(e)}"
            self.logger.error(error_msg, exc_info=True)
            raise RuntimeError(error_msg) from e
