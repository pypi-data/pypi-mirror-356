"""
Fallback Manager for LLM-backed Code Generation.

This module provides the FallbackManager class which implements fallback
strategies for handling code generation failures.
"""

import logging
from typing import Any, Dict, List

from ..models.validation_result import ValidationResult


class FallbackManager:
    """
    Manages fallback strategies for code generation failures.
    
    This class is responsible for implementing various fallback strategies
    when code generation fails, including retrying with modified prompts,
    fixing specific issues, and generating simple implementations.
    """
    
    def __init__(self, llm_service, prompt_builder):
        """
        Initialize the FallbackManager.
        
        Args:
            llm_service: Service for making LLM API calls
            prompt_builder: Builder for creating LLM prompts
        """
        self.llm_service = llm_service
        self.prompt_builder = prompt_builder
        self.logger = logging.getLogger(__name__)
        
    async def handle_failure(self, validation_result: ValidationResult, 
                            tool_specification: Any, 
                            prompt: str, 
                            context: Dict[str, Any]) -> str:
        """
        Handle validation failure by implementing a fallback strategy.
        
        This method determines the appropriate fallback strategy based on
        the validation result and implements it.
        
        Args:
            validation_result: The validation result containing failure information
            tool_specification: The specification for the tool
            prompt: The original prompt used for code generation
            context: The context used for code generation
            
        Returns:
            str: The code generated by the fallback strategy
            
        Raises:
            RuntimeError: If all fallback strategies fail
        """
        self.logger.warning(
            f"Handling code generation failure for tool: {getattr(tool_specification, 'name', 'unnamed')}"
        )
        
        # Determine the fallback strategy based on the validation result
        if not validation_result.syntax_valid:
            self.logger.info("Using syntax error fallback strategy")
            return await self._handle_syntax_error(
                validation_result, tool_specification, prompt, context
            )
        elif not validation_result.security_valid:
            self.logger.info("Using security issue fallback strategy")
            return await self._handle_security_issue(
                validation_result, tool_specification, prompt, context
            )
        elif not validation_result.spec_compliance:
            self.logger.info("Using spec compliance fallback strategy")
            return await self._handle_spec_compliance_issue(
                validation_result, tool_specification, prompt, context
            )
        else:
            # This should not happen, but just in case
            self.logger.warning("No specific validation failure detected, using simple implementation")
            return await self._generate_simple_implementation(tool_specification)
    
    async def handle_exception(self, exception: Exception, 
                              tool_specification: Any, 
                              prompt: str, 
                              context: Dict[str, Any]) -> str:
        """
        Handle exception by implementing a fallback strategy.
        
        This method implements a fallback strategy for handling exceptions
        that occur during code generation.
        
        Args:
            exception: The exception that occurred
            tool_specification: The specification for the tool
            prompt: The original prompt used for code generation
            context: The context used for code generation
            
        Returns:
            str: The code generated by the fallback strategy
            
        Raises:
            RuntimeError: If all fallback strategies fail
        """
        self.logger.error(
            f"Exception during code generation: {str(exception)}",
            exc_info=True
        )
        
        # Try a simplified prompt first
        try:
            self.logger.info("Attempting code generation with simplified prompt")
            simplified_prompt = self._create_simplified_prompt(tool_specification)
            simplified_context = self._simplify_context(context)
            
            return await self.llm_service.generate_code(simplified_prompt, simplified_context)
        except Exception as e:
            self.logger.error(
                f"Simplified prompt strategy failed: {str(e)}",
                exc_info=True
            )
        
        # If simplified prompt fails, try a template-based implementation
        self.logger.info("Falling back to template-based implementation")
        return self._create_template_based_implementation(tool_specification)
    
    async def _handle_syntax_error(self, validation_result: ValidationResult, 
                                  tool_specification: Any, 
                                  prompt: str, 
                                  context: Dict[str, Any]) -> str:
        """
        Handle syntax error by implementing a fallback strategy.
        
        This method attempts to fix syntax errors in the generated code by
        providing more specific guidance to the LLM.
        
        Args:
            validation_result: The validation result containing syntax errors
            tool_specification: The specification for the tool
            prompt: The original prompt used for code generation
            context: The context used for code generation
            
        Returns:
            str: The fixed code
            
        Raises:
            RuntimeError: If the fallback strategy fails
        """
        self.logger.info(f"Handling syntax errors: {validation_result.syntax_errors}")
        
        # Create a prompt that specifically addresses the syntax errors
        error_details = "\n".join(validation_result.syntax_errors)
        fix_prompt = f"""
        The previous code generation attempt had syntax errors:
        
        {error_details}
        
        Please generate a corrected implementation for the following tool:
        
        Tool Name: {getattr(tool_specification, 'name', 'unnamed')}
        Description: {getattr(tool_specification, 'description', 'No description')}
        
        Ensure that your code has no syntax errors and is valid Python code.
        Focus on producing syntactically correct code, even if it means simplifying the implementation.
        """
        
        try:
            # Try to generate fixed code
            self.logger.debug("Attempting to generate code with syntax error fix prompt")
            return await self.llm_service.generate_code(fix_prompt, context)
        except Exception as e:
            self.logger.error(
                f"Syntax error fix strategy failed: {str(e)}",
                exc_info=True
            )
            
            # If fixing fails, fall back to a simple implementation
            self.logger.info("Falling back to simple implementation")
            return await self._generate_simple_implementation(tool_specification)
    
    async def _handle_security_issue(self, validation_result: ValidationResult, 
                                    tool_specification: Any, 
                                    prompt: str, 
                                    context: Dict[str, Any]) -> str:
        """
        Handle security issue by implementing a fallback strategy.
        
        This method attempts to fix security issues in the generated code by
        providing more specific guidance to the LLM.
        
        Args:
            validation_result: The validation result containing security issues
            tool_specification: The specification for the tool
            prompt: The original prompt used for code generation
            context: The context used for code generation
            
        Returns:
            str: The fixed code
            
        Raises:
            RuntimeError: If the fallback strategy fails
        """
        self.logger.info(f"Handling security issues: {validation_result.security_issues}")
        
        # Create a prompt that specifically addresses the security issues
        security_details = "\n".join(validation_result.security_issues)
        fix_prompt = f"""
        The previous code generation attempt had security issues:
        
        {security_details}
        
        Please generate a secure implementation for the following tool:
        
        Tool Name: {getattr(tool_specification, 'name', 'unnamed')}
        Description: {getattr(tool_specification, 'description', 'No description')}
        
        Security guidelines:
        1. Avoid using os.system, subprocess, eval, exec, or __import__
        2. Validate all inputs before processing
        3. Use safe alternatives to dangerous functions
        4. Avoid writing to files without proper validation
        5. Do not disable SSL verification in HTTP requests
        6. Use parameterized queries for database operations
        
        Ensure your implementation is secure while still fulfilling the tool's purpose.
        """
        
        try:
            # Try to generate fixed code
            self.logger.debug("Attempting to generate code with security fix prompt")
            return await self.llm_service.generate_code(fix_prompt, context)
        except Exception as e:
            self.logger.error(
                f"Security fix strategy failed: {str(e)}",
                exc_info=True
            )
            
            # If fixing fails, fall back to a simple implementation
            self.logger.info("Falling back to simple implementation")
            return await self._generate_simple_implementation(tool_specification)
    
    async def _handle_spec_compliance_issue(self, validation_result: ValidationResult, 
                                          tool_specification: Any, 
                                          prompt: str, 
                                          context: Dict[str, Any]) -> str:
        """
        Handle specification compliance issue by implementing a fallback strategy.
        
        This method attempts to fix specification compliance issues in the
        generated code by providing more specific guidance to the LLM.
        
        Args:
            validation_result: The validation result containing compliance issues
            tool_specification: The specification for the tool
            prompt: The original prompt used for code generation
            context: The context used for code generation
            
        Returns:
            str: The fixed code
            
        Raises:
            RuntimeError: If the fallback strategy fails
        """
        self.logger.info(f"Handling spec compliance issues: {validation_result.compliance_issues}")
        
        # Create a prompt that specifically addresses the compliance issues
        compliance_details = "\n".join(validation_result.compliance_issues)
        
        # Get input parameters and output format for the prompt
        input_params = getattr(tool_specification, 'input_params', [])
        input_params_str = "\n".join([
            f"- {param.get('name', 'unnamed')} ({param.get('type', 'any')}): " +
            f"{param.get('description', 'No description')} " +
            f"{'[Required]' if param.get('required', False) else ''}"
            for param in input_params
        ])
        
        output_format = getattr(tool_specification, 'output_format', 'No output format specified')
        if isinstance(output_format, dict):
            output_format_str = output_format.get('description', 'No output format specified')
        else:
            output_format_str = str(output_format)
        
        fix_prompt = f"""
        The previous code generation attempt had specification compliance issues:
        
        {compliance_details}
        
        Please generate a compliant implementation for the following tool:
        
        Tool Name: {getattr(tool_specification, 'name', 'unnamed')}
        Description: {getattr(tool_specification, 'description', 'No description')}
        
        Input Parameters:
        {input_params_str}
        
        Output Format:
        {output_format_str}
        
        Compliance requirements:
        1. Use all required input parameters in your implementation
        2. Include proper error handling with try-except blocks
        3. Validate all input parameters before processing
        4. Include type hints for functions and parameters
        5. Add comprehensive docstrings explaining the code
        6. Return output in the specified format
        
        Ensure your implementation fully complies with the tool specification.
        """
        
        try:
            # Try to generate fixed code
            self.logger.debug("Attempting to generate code with compliance fix prompt")
            return await self.llm_service.generate_code(fix_prompt, context)
        except Exception as e:
            self.logger.error(
                f"Compliance fix strategy failed: {str(e)}",
                exc_info=True
            )
            
            # If fixing fails, fall back to a simple implementation
            self.logger.info("Falling back to simple implementation")
            return await self._generate_simple_implementation(tool_specification)
    
    async def _generate_simple_implementation(self, tool_specification: Any) -> str:
        """
        Generate a simple implementation as a last resort.
        
        This method creates a minimal but functional implementation of the tool
        when all other strategies have failed.
        
        Args:
            tool_specification: The specification for the tool
            
        Returns:
            str: A simple implementation of the tool
        """
        self.logger.info(f"Generating simple implementation for tool: {getattr(tool_specification, 'name', 'unnamed')}")
        
        # Get input parameters
        input_params = getattr(tool_specification, 'input_params', [])
        param_names = [param.get('name', f'param{i}') for i, param in enumerate(input_params)]
        
        # Create a simple implementation
        ", ".join(param_names)
        params_with_types = ", ".join([f"{name}: Any" for name in param_names])
        
        simple_impl = f"""
from typing import Any, Dict, List, Optional, Union

def execute({params_with_types}) -> Dict[str, Any]:
    \"\"\"
    Simple implementation for {getattr(tool_specification, 'name', 'unnamed')} tool.
    
    This is a fallback implementation that provides basic functionality.
    
    Args:
        {chr(10).join([f'{name}: Input parameter' for name in param_names])}
        
    Returns:
        Dict[str, Any]: Result of the tool execution
    \"\"\"
    try:
        # Basic implementation
        result = {{
            "status": "success",
            "message": "This is a fallback implementation with limited functionality.",
            "data": {{
                {chr(10).join([f'"{name}": {name},' for name in param_names])}
            }}
        }}
        
        return result
    except Exception as e:
        return {{
            "status": "error",
            "message": f"An error occurred: {{str(e)}}",
            "data": None
        }}
        """
        
        self.logger.debug("Simple implementation generated")
        return simple_impl
    
    def _create_simplified_prompt(self, tool_specification: Any) -> str:
        """
        Create a simplified prompt for code generation.
        
        This method creates a minimal prompt with only the essential information
        for generating code.
        
        Args:
            tool_specification: The specification for the tool
            
        Returns:
            str: A simplified prompt
        """
        # Get input parameters
        input_params = getattr(tool_specification, 'input_params', [])
        input_params_str = "\n".join([
            f"- {param.get('name', 'unnamed')}: {param.get('description', 'No description')}"
            for param in input_params
        ])
        
        # Create a simplified prompt
        simplified_prompt = f"""
        Generate a simple Python function for the following tool:
        
        Tool Name: {getattr(tool_specification, 'name', 'unnamed')}
        Description: {getattr(tool_specification, 'description', 'No description')}
        
        Input Parameters:
        {input_params_str}
        
        Keep the implementation simple and focus on basic functionality.
        Include error handling with try-except blocks.
        """
        
        return simplified_prompt
    
    def _simplify_context(self, context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Simplify the context for code generation.
        
        This method removes non-essential information from the context to
        reduce complexity.
        
        Args:
            context: The original context
            
        Returns:
            Dict[str, Any]: A simplified context
        """
        # Keep only essential context information
        simplified_context = {
            "tool_purpose": context.get("tool_purpose", ""),
            "constraints": context.get("constraints", [])
        }
        
        # Simplify input/output formats if present
        if "input_output_formats" in context:
            input_output = context["input_output_formats"]
            simplified_context["input_output_formats"] = {
                "inputs": input_output.get("inputs", []),
                "output": {"description": "Simple output"}
            }
        
        return simplified_context
    
    def _create_template_based_implementation(self, tool_specification: Any) -> str:
        """
        Create a template-based implementation.
        
        This method generates code based on predefined templates for different
        tool types.
        
        Args:
            tool_specification: The specification for the tool
            
        Returns:
            str: A template-based implementation
        """
        # Determine tool type from name and description
        tool_name = getattr(tool_specification, 'name', '').lower()
        tool_description = getattr(tool_specification, 'description', '').lower()
        
        # Get input parameters
        input_params = getattr(tool_specification, 'input_params', [])
        param_names = [param.get('name', f'param{i}') for i, param in enumerate(input_params)]
        ", ".join(param_names)
        ", ".join([f"{name}: Any" for name in param_names])
        
        # Check for API caller tools
        api_keywords = ['api', 'http', 'request', 'fetch', 'endpoint', 'rest']
        if any(keyword in tool_description or keyword in tool_name for keyword in api_keywords):
            return self._create_api_caller_template(tool_specification, param_names)
        
        # Check for data processing tools
        data_keywords = ['data', 'process', 'transform', 'convert', 'parse', 'format']
        if any(keyword in tool_description or keyword in tool_name for keyword in data_keywords):
            return self._create_data_processor_template(tool_specification, param_names)
        
        # Check for file manipulation tools
        file_keywords = ['file', 'read', 'write', 'save', 'load', 'open', 'directory']
        if any(keyword in tool_description or keyword in tool_name for keyword in file_keywords):
            return self._create_file_manipulator_template(tool_specification, param_names)
        
        # Default template
        return self._create_default_template(tool_specification, param_names)
    
    def _create_api_caller_template(self, tool_specification: Any, param_names: List[str]) -> str:
        """
        Create a template for API caller tools.
        
        Args:
            tool_specification: The specification for the tool
            param_names: List of parameter names
            
        Returns:
            str: A template implementation for API caller tools
        """
        params_with_types = ", ".join([f"{name}: str" for name in param_names])
        url_param = param_names[0] if param_names else "url"
        
        return f"""
import requests
from typing import Any, Dict, Optional

def execute({params_with_types}) -> Dict[str, Any]:
    \"\"\"
    Execute an API call based on the provided parameters.
    
    Args:
        {chr(10).join([f'{name}: Input parameter' for name in param_names])}
        
    Returns:
        Dict[str, Any]: The API response
    \"\"\"
    try:
        # Make the API request
        response = requests.get({url_param}, timeout=10)
        
        # Check if the request was successful
        response.raise_for_status()
        
        # Parse the response
        data = response.json()
        
        return {{
            "status": "success",
            "data": data,
            "message": "API call completed successfully"
        }}
    except requests.exceptions.RequestException as e:
        return {{
            "status": "error",
            "data": None,
            "message": f"API request failed: {{str(e)}}"
        }}
    except Exception as e:
        return {{
            "status": "error",
            "data": None,
            "message": f"An error occurred: {{str(e)}}"
        }}
        """
    
    def _create_data_processor_template(self, tool_specification: Any, param_names: List[str]) -> str:
        """
        Create a template for data processor tools.
        
        Args:
            tool_specification: The specification for the tool
            param_names: List of parameter names
            
        Returns:
            str: A template implementation for data processor tools
        """
        params_with_types = ", ".join([f"{name}: Any" for name in param_names])
        data_param = next((name for name in param_names if "data" in name.lower()), 
                          param_names[0] if param_names else "data")
        
        return f"""
from typing import Any, Dict, List, Optional, Union
import json

def execute({params_with_types}) -> Dict[str, Any]:
    \"\"\"
    Process data based on the provided parameters.
    
    Args:
        {chr(10).join([f'{name}: Input parameter' for name in param_names])}
        
    Returns:
        Dict[str, Any]: The processed data
    \"\"\"
    try:
        # Validate input
        if not {data_param}:
            return {{
                "status": "error",
                "data": None,
                "message": "No data provided for processing"
            }}
        
        # Process the data (basic example)
        processed_data = {{}}
        
        # If data is a string, try to parse it as JSON
        if isinstance({data_param}, str):
            try:
                processed_data = json.loads({data_param})
            except json.JSONDecodeError:
                processed_data = {{"text": {data_param}}}
        # If data is already a dict or list, use it directly
        elif isinstance({data_param}, (dict, list)):
            processed_data = {data_param}
        # Otherwise, convert to string
        else:
            processed_data = {{"value": str({data_param})}}
        
        return {{
            "status": "success",
            "data": processed_data,
            "message": "Data processed successfully"
        }}
    except Exception as e:
        return {{
            "status": "error",
            "data": None,
            "message": f"An error occurred: {{str(e)}}"
        }}
        """
    
    def _create_file_manipulator_template(self, tool_specification: Any, param_names: List[str]) -> str:
        """
        Create a template for file manipulator tools.
        
        Args:
            tool_specification: The specification for the tool
            param_names: List of parameter names
            
        Returns:
            str: A template implementation for file manipulator tools
        """
        params_with_types = ", ".join([f"{name}: str" for name in param_names])
        file_param = next((name for name in param_names if "file" in name.lower() or "path" in name.lower()), 
                          param_names[0] if param_names else "file_path")
        
        return f"""
import os
from typing import Any, Dict, Optional

def execute({params_with_types}) -> Dict[str, Any]:
    \"\"\"
    Manipulate files based on the provided parameters.
    
    Args:
        {chr(10).join([f'{name}: Input parameter' for name in param_names])}
        
    Returns:
        Dict[str, Any]: The result of the file operation
    \"\"\"
    try:
        # Validate input
        if not {file_param}:
            return {{
                "status": "error",
                "data": None,
                "message": "No file path provided"
            }}
        
        # Check if the file exists
        if not os.path.exists({file_param}):
            return {{
                "status": "error",
                "data": None,
                "message": f"File not found: {{{file_param}}}"
            }}
        
        # Read the file (basic example)
        with open({file_param}, 'r', encoding='utf-8') as file:
            content = file.read()
        
        # Get file metadata
        file_size = os.path.getsize({file_param})
        file_modified = os.path.getmtime({file_param})
        
        return {{
            "status": "success",
            "data": {{
                "content": content,
                "size": file_size,
                "modified": file_modified,
                "path": {file_param}
            }},
            "message": "File read successfully"
        }}
    except Exception as e:
        return {{
            "status": "error",
            "data": None,
            "message": f"An error occurred: {{str(e)}}"
        }}
        """
    
    def _create_default_template(self, tool_specification: Any, param_names: List[str]) -> str:
        """
        Create a default template for tools.
        
        Args:
            tool_specification: The specification for the tool
            param_names: List of parameter names
            
        Returns:
            str: A default template implementation
        """
        params_with_types = ", ".join([f"{name}: Any" for name in param_names])
        
        return f"""
from typing import Any, Dict, List, Optional, Union

def execute({params_with_types}) -> Dict[str, Any]:
    \"\"\"
    Execute the tool based on the provided parameters.
    
    Args:
        {chr(10).join([f'{name}: Input parameter' for name in param_names])}
        
    Returns:
        Dict[str, Any]: The result of the tool execution
    \"\"\"
    try:
        # Basic implementation
        result = {{
            "status": "success",
            "message": "Tool executed successfully (template-based implementation)",
            "data": {{
                {chr(10).join([f'"{name}": {name},' for name in param_names])}
            }}
        }}
        
        return result
    except Exception as e:
        return {{
            "status": "error",
            "message": f"An error occurred: {{str(e)}}",
            "data": None
        }}
        """
