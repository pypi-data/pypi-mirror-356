# THIS FILE IS AUTO-GENERATED BY ini2py.
# DO NOT EDIT THIS FILE MANUALLY.

import time
import configparser
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from threading import Thread
from .schema import (
{{SCHEMA_IMPORTS}}
)


def find_config_path(filename="config.ini", max_depth=5):
    """
    從當前工作目錄開始向上查找配置文件。
    會依次尋找 'filename', 'config/filename', 'conf/filename'。

    參數：
        filename (str): 配置文件名稱，預設為 'config.ini'。
        max_depth (int): 最大向上查找的目錄層數，預設為 5。

    返回：
        str 或 None: 找到的配置文件路徑，若未找到則返回 None。
    """
    path = "."
    for _ in range(max_depth):
        abs_path = os.path.abspath(path)
        
        check_paths = [
            os.path.join(abs_path, filename),
            os.path.join(abs_path, 'config', filename),
            os.path.join(abs_path, 'conf', filename),
        ]
        
        for p in check_paths:
            if os.path.exists(p):
                return p
        
        if os.path.dirname(abs_path) == abs_path:
            break
        path = os.path.join(path, "..")
        
    return None


class ConfigFileHandler(FileSystemEventHandler):
    """
    專門處理配置文件變更的事件處理器。
    只監控指定的配置文件，並自動排除指定的目錄。
    """
    
    def __init__(self, config_manager, exclude_dirs=None):
        """
        初始化事件處理器。

        參數：
            config_manager (ConfigManager): 配置管理器實例。
            exclude_dirs (set): 要排除的目錄名稱集合。
        """
        super().__init__()
        self.config_manager = config_manager
        self.exclude_dirs = exclude_dirs or {'data', 'logs', 'src'}
        self.last_modified_time = 0
        self.config_filename = os.path.basename(config_manager.config_path)
        
        print(f"ConfigFileHandler initialized - watching for: {self.config_filename}")
        print(f"Excluding directories: {', '.join(self.exclude_dirs)}")

    def _should_ignore_path(self, path):
        """
        檢查路徑是否應該被忽略。
        
        參數：
            path (str): 要檢查的路徑
            
        返回：
            bool: True 如果應該忽略，False 如果不應該忽略
        """
        # 將路徑標準化並分割成各個部分
        normalized_path = os.path.normpath(path)
        path_parts = normalized_path.split(os.sep)
        
        # 檢查路徑中是否包含要排除的目錄
        for part in path_parts:
            if part in self.exclude_dirs:
                return True
        
        return False

    def on_modified(self, event):
        """
        當文件被修改時觸發。
        只處理我們關心的配置文件，並排除指定目錄。
        """
        if event.is_directory:
            return

        # 檢查是否在排除的目錄中
        if self._should_ignore_path(event.src_path):
            return

        # 檢查是否是我們要監控的配置文件
        if os.path.basename(event.src_path) == self.config_filename:
            current_time = time.time()
            # 防止重複觸發（1秒內的重複事件會被忽略）
            if current_time - self.last_modified_time > 1:
                self.last_modified_time = current_time
                print(f"Config file {event.src_path} changed, reloading values...")
                self.config_manager.reload_config()

    def on_created(self, event):
        """
        當文件被創建時觸發。
        處理配置文件被重新創建的情況。
        """
        if event.is_directory:
            return

        if self._should_ignore_path(event.src_path):
            return

        if os.path.basename(event.src_path) == self.config_filename:
            print(f"Config file {event.src_path} created, reloading values...")
            self.config_manager.reload_config()


class ConfigManager(object):
    """
    配置管理器，負責加載、管理和監控配置文件。

    使用單例模式確保全局只有一個配置管理器實例。
    """
    _instance = None
    _initialized = False

    def __new__(cls, *args, **kwargs): 
        if cls._instance is None: 
            cls._instance = super().__new__(cls) 
        return cls._instance

    def __init__(self, config_path: str = None):
        if self._initialized:
            if config_path and config_path != self.config_path:
                print(f"Warning: ConfigManager already initialized with path '{self.config_path}'. Ignoring new path '{config_path}'.")
            return
        
        if config_path:
            self.config_path = config_path
        else:
            self.config_path = find_config_path()

        if not self.config_path or not os.path.exists(self.config_path):
            raise FileNotFoundError(
                "Could not find config.ini. Please provide the path explicitly "
                "to ConfigManager(config_path='/path/to/your/config.ini') "
                "or place it in the project root or a 'config/' subdirectory."
            )
        
        print(f"ConfigManager is using configuration file: {self.config_path}")

        self._config = configparser.RawConfigParser()
        self._load_config()

        self._start_watchdog()
        self._initialized = True

    def _load_config(self):
        self._config.read(self.config_path, encoding='utf-8')
{{MANAGER_PROPERTIES}}

    def reload_config(self):
        try:
            new_config = configparser.RawConfigParser()
            new_config.read(self.config_path, encoding='utf-8')
            self._config = new_config
            self._load_config() 
            print("Configuration values reloaded successfully.")
        except Exception as e:
            print(f"Error reloading configuration: {e}")

    def _start_watchdog(self):
        """
        啟動 Watchdog 觀察者以監控配置文件的變更。
        只監控配置文件所在的目錄，並排除指定的子目錄。
        """
        try:
            # 確定要監控的目錄路徑
            config_dir = os.path.dirname(self.config_path)
            if not config_dir:
                config_dir = '.'
            
            # 使用絕對路徑確保路徑正確
            watch_path = os.path.abspath(config_dir)
            
            if not os.path.isdir(watch_path):
                print(f"Warning: Config directory '{watch_path}' does not exist. Watchdog not started.")
                return

            # 定義要排除的目錄
            exclude_dirs = {'data', 'logs', 'src', '.git', '__pycache__', '.vscode', '.idea'}
            
            # 創建事件處理器
            event_handler = ConfigFileHandler(self, exclude_dirs=exclude_dirs)
            
            # 創建並啟動觀察者
            observer = Observer()
            
            # 使用遞迴監控，但透過事件處理器過濾不需要的目錄
            observer.schedule(event_handler, watch_path, recursive=True)
            
            # 在背景線程中啟動觀察者
            observer_thread = Thread(target=observer.start, daemon=True)
            observer_thread.start()
            
            print(f"Started watchdog monitoring config directory: '{watch_path}'")
            print(f"Watching for changes to: {os.path.basename(self.config_path)}")
            print(f"Excluding directories: {', '.join(sorted(exclude_dirs))}")
            
        except Exception as e:
            print(f"Failed to start watchdog: {e}")
            print("Configuration file monitoring is disabled.")