import os
import re
from pathlib import Path
from typing import Dict, List, Optional, Any, Tuple, Set

from vulnerability_checker.checks.base import BaseCheck
from vulnerability_checker.models import CheckResult, CheckStatus, VulnerabilityIssue

class GtkCheck(BaseCheck):
    """
    Check for PyGObject/Gtk+3 specific vulnerabilities.
    """
    name = "gtk"
    description = "Check for PyGObject/Gtk+3 specific vulnerabilities (GtkTemplate Injection, Signal Handler Leak, Pango Markup XSS, GDK Resource Injection, CSS Provider RCE, Clipboard Hijacking, D-Bus Injection)"

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__(config)

    def run(self, target_path: str, **kwargs) -> Tuple[CheckResult, List[VulnerabilityIssue]]:
        self.issues = []
        path = Path(target_path)
        py_files = self._find_files(path, {".py"})
        ui_files = self._find_files(path, {".ui", ".glade"})
        css_files = self._find_files(path, {".css"})

        for file_path in py_files:
            self._check_gtk_template_injection(file_path, ui_files)
            self._check_signal_handler_leak(file_path)
            self._check_pango_markup_xss(file_path)
            self._check_gdk_resource_injection(file_path)
            self._check_css_provider_rce(file_path, css_files)
            self._check_clipboard_hijacking(file_path)
            self._check_dbus_injection(file_path)
            self._check_insecure_filechooser_usage(file_path)
            self._check_unrestricted_drag_and_drop(file_path)
            self._check_webkitgtk_unsafe_settings(file_path)
            self._check_untrusted_gsettings_usage(file_path)
            self._check_unprotected_window_embedding(file_path)
            self._check_insecure_clipboard_format_handling(file_path)
            self._check_gtkbuilder_dynamic_loading(file_path)
            self._check_aboutdialog_disclosure(file_path)
            self._check_entry_set_visibility(file_path)
            self._check_sensitive_data_in_window_titles(file_path)
            self._check_printoperation_injection(file_path)
            self._check_revealer_sensitive_data(file_path)
            self._check_textbuffer_injection(file_path)
            self._check_accelgroup_key_hijacking(file_path)
            self._check_messagedialog_injection(file_path)
            self._check_filesystemmodel_traversal(file_path)
            self._check_menu_injection(file_path)

        status = CheckStatus.PASSED if not self.issues else CheckStatus.FAILED
        result = self.create_result(
            status=status,
            message=f"Found {len(self.issues)} GTK-specific vulnerabilities" if self.issues else "No GTK-specific vulnerabilities detected",
        )
        return result, self.issues

    def _find_files(self, path: Path, extensions: Set[str]) -> Set[Path]:
        result = set()
        if path.is_file():
            if path.suffix in extensions and not self.should_exclude_path(path):
                result.add(path)
            return result
        for root, dirs, files in os.walk(path):
            dirs[:] = [d for d in dirs if not self.should_exclude_path(os.path.join(root, d))]
            for file in files:
                file_path = Path(root) / file
                if file_path.suffix in extensions and not self.should_exclude_path(file_path):
                    result.add(file_path)
        return result

    def _check_gtk_template_injection(self, py_file: Path, ui_files: Set[Path]):
        """
        Наличие неэкранированных подстановок в Gtk.Template (filename/string) из ненадёжных источников, а также переменных в .ui/.glade файлах. Путь к шаблону или строка шаблона формируется динамически или из внешнего источника.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            # Пример: Gtk.Template(filename=...) или Gtk.Template(string=...)
            template_pattern = re.compile(r"Gtk\.Template\s*\(([^)]*)\)")
            for match in template_pattern.finditer(content):
                args = match.group(1)
                if re.search(r"filename\s*=\s*([\w'\"]+)", args) or re.search(r"string\s*=\s*", args):
                    # Проверяем, не подставляется ли путь из внешнего источника
                    if re.search(r"filename\s*=\s*\w+", args) and not re.search(r"['\"]", args):
                        self.add_issue(
                            issue_type="GtkTemplate Injection",
                            severity="critical",
                            description="Unescaped Gtk.Template filename argument from untrusted source.",
                            file_path=str(py_file),
                            line_number=self._find_line(content, match.start()),
                            code_snippet=match.group(0),
                            confidence="HIGH",
                            cwe_id="CWE-94",
                            owasp_category="A1:2017-Injection",
                            remediation="Avoid passing user-controlled values to Gtk.Template filename/string. Use only trusted, static files.",
                        )
            # Анализ .ui/.glade файлов на наличие подозрительных конструкций
            for ui_file in ui_files:
                with open(ui_file, "r", encoding="utf-8", errors="ignore") as f:
                    ui_content = f.read()
                if re.search(r"<object class=", ui_content) and re.search(r"\$\{.*\}", ui_content):
                    self.add_issue(
                        issue_type="GtkTemplate Injection",
                        severity="critical",
                        description="Potential template injection in UI file (variable substitution detected).",
                        file_path=str(ui_file),
                        line_number=1,
                        code_snippet="...",
                        confidence="HIGH",
                        cwe_id="CWE-94",
                        owasp_category="A1:2017-Injection",
                        remediation="Do not use variable substitution in .ui/.glade files from untrusted sources.",
                    )
        except Exception as e:
            pass

    def _check_signal_handler_leak(self, py_file: Path):
        """
        connect() вызывается, а disconnect() нигде не встречается для этого объекта.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            connect_calls = [m for m in re.finditer(r"\.connect\(", content)]
            disconnect_calls = [m for m in re.finditer(r"\.disconnect\(", content)]
            if connect_calls and not disconnect_calls:
                for m in connect_calls:
                    self.add_issue(
                        issue_type="Signal Handler Leak",
                        severity="medium",
                        description="Signal connected but never disconnected. May cause memory leaks or DoS.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=content[m.start():m.start()+40],
                        confidence="MEDIUM",
                        cwe_id="CWE-401",
                        owasp_category="A9:2017-Using Components with Known Vulnerabilities",
                        remediation="Always disconnect signal handlers when widgets are destroyed.",
                    )
        except Exception:
            pass

    def _check_pango_markup_xss(self, py_file: Path):
        """
        set_markup() вызывается с переменной, а не строковым литералом.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"set_markup\(([^)]*)\)", content):
                arg = m.group(1)
                # Если аргумент не строковый литерал
                if not re.match(r"\s*['\"]", arg):
                    self.add_issue(
                        issue_type="Pango Markup XSS",
                        severity="high",
                        description="set_markup() called with non-literal argument. May allow XSS if input is user-controlled.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-79",
                        owasp_category="A7:2017-XSS",
                        remediation="Sanitize all input passed to set_markup().",
                    )
        except Exception:
            pass

    def _check_gdk_resource_injection(self, py_file: Path):
        """
        GdkPixbuf.Pixbuf.new_from_file() вызывается с путём, полученным из внешнего источника. Путь к файлу формируется динамически или из пользовательского ввода.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"GdkPixbuf\.Pixbuf\.new_from_file\(([^)]*)\)", content):
                arg = m.group(1)
                if not re.match(r"\s*['\"]", arg):
                    self.add_issue(
                        issue_type="GDK Resource Injection",
                        severity="high",
                        description="GdkPixbuf.Pixbuf.new_from_file() called with non-literal argument. May allow LFI/RCE.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-22",
                        owasp_category="A1:2017-Injection",
                        remediation="Validate and sanitize all file paths passed to GdkPixbuf.Pixbuf.new_from_file().",
                    )
        except Exception:
            pass

    def _check_css_provider_rce(self, py_file: Path, css_files: Set[Path]):
        """
        Gtk.CssProvider.load_from_path() вызывается с невалидированным путём и/или CSS содержит внешние импорты. Путь к CSS-файлу формируется динамически или CSS содержит @import.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"CssProvider\.load_from_path\(([^)]*)\)", content):
                arg = m.group(1)
                if not re.match(r"\s*['\"]", arg):
                    self.add_issue(
                        issue_type="CSS Provider RCE",
                        severity="critical",
                        description="Gtk.CssProvider.load_from_path() called with non-literal argument. May allow RCE if path is user-controlled.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-94",
                        owasp_category="A1:2017-Injection",
                        remediation="Do not pass user-controlled paths to load_from_path().",
                    )
            # Анализ CSS-файлов на подозрительные конструкции (например, @import из внешних источников)
            for css_file in css_files:
                with open(css_file, "r", encoding="utf-8", errors="ignore") as f:
                    css_content = f.read()
                if re.search(r"@import\s+url\([^)]+\)", css_content):
                    self.add_issue(
                        issue_type="CSS Provider RCE",
                        severity="high",
                        description="CSS file contains @import from external source. May allow code injection.",
                        file_path=str(css_file),
                        line_number=1,
                        code_snippet="...",
                        confidence="MEDIUM",
                        cwe_id="CWE-94",
                        owasp_category="A1:2017-Injection",
                        remediation="Avoid @import from untrusted sources in CSS files.",
                    )
        except Exception:
            pass

    def _check_clipboard_hijacking(self, py_file: Path):
        """
        Используется Clipboard, но не вызывается очистка (set_text("")).
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.Clipboard\.get\([^)]+\)", content):
                # Проверяем, есть ли очистка clipboard после использования
                if not re.search(r"set_text\(\s*['\"]{0,1}\s*['\"]{0,1}\s*\)", content):
                    self.add_issue(
                        issue_type="Clipboard Hijacking",
                        severity="medium",
                        description="Clipboard is used but not cleared after handling secrets. May leak sensitive data.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-200",
                        owasp_category="A3:2017-Sensitive Data Exposure",
                        remediation="Always clear clipboard after copying sensitive data.",
                    )
        except Exception:
            pass

    def _check_dbus_injection(self, py_file: Path):
        """
        Gio.DBusProxy вызывается с невалидированными интерфейсами. Имя интерфейса формируется динамически или не проверяется.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gio\.DBusProxy\(([^)]*)\)", content):
                arg = m.group(1)
                if not re.search(r"['\"]bus_name['\"]\s*:\s*['\"]org\.gtk\.\w+['\"]", arg):
                    self.add_issue(
                        issue_type="D-Bus Injection",
                        severity="high",
                        description="Gio.DBusProxy used with non-validated interface. May allow privilege escalation.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-285",
                        owasp_category="A5:2017-Broken Access Control",
                        remediation="Validate all D-Bus interface names and restrict to trusted interfaces only.",
                    )
        except Exception:
            pass

    def _check_insecure_filechooser_usage(self, py_file: Path):
        """
        FileChooser используется без set_filter/add_filter/set_current_folder.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.FileChooser(\w*)\(([^)]*)\)", content):
                # Проверяем отсутствие фильтрации или проверки пути
                if not re.search(r"set_filter|add_filter|set_current_folder|set_do_overwrite_confirmation", content):
                    self.add_issue(
                        issue_type="Insecure FileChooser Usage",
                        severity="high",
                        description="Gtk.FileChooser used without file type filtering or path validation.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-22",
                        owasp_category="A5:2017-Broken Access Control",
                        remediation="Always set file filters and validate file paths in FileChooser dialogs.",
                    )
        except Exception:
            pass

    def _check_unrestricted_drag_and_drop(self, py_file: Path):
        """
        drag_data_received вызывается без get_data_type/get_format/get_mime_type.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            # Поиск drag-data-received без проверки типа
            for m in re.finditer(r"drag_data_received", content):
                if not re.search(r"get_data_type|get_format|get_mime_type", content):
                    self.add_issue(
                        issue_type="Unrestricted Drag-and-Drop",
                        severity="medium",
                        description="Drag-and-drop handler without data type validation.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-20",
                        owasp_category="A8:2017-Insecure Deserialization",
                        remediation="Always validate mime types and data formats in drag-and-drop handlers.",
                    )
        except Exception:
            pass

    def _check_webkitgtk_unsafe_settings(self, py_file: Path):
        """
        enable_developer_extras, allow_universal_access_from_file_urls, enable_javascript_markup = True.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"WebKit.*Settings\(([^)]*)\)", content):
                # Поиск опасных настроек
                if re.search(r"enable_developer_extras\s*=\s*True|allow_universal_access_from_file_urls\s*=\s*True|enable_javascript_markup\s*=\s*True", content):
                    self.add_issue(
                        issue_type="WebKitGTK Unsafe Settings",
                        severity="critical",
                        description="WebKitGTK used with unsafe settings (developer extras, universal access, JS markup).",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-284",
                        owasp_category="A5:2017-Broken Access Control",
                        remediation="Disable dangerous WebKitGTK settings unless absolutely necessary.",
                    )
        except Exception:
            pass

    def _check_untrusted_gsettings_usage(self, py_file: Path):
        """
        Gio.Settings вызывается без schema/key.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gio\.Settings\(([^)]*)\)", content):
                # Проверяем отсутствие схемы или ключа
                if not re.search(r"schema|key", m.group(1)):
                    self.add_issue(
                        issue_type="Untrusted GSettings Usage",
                        severity="medium",
                        description="Gio.Settings used without schema/key validation. May allow config tampering.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-494",
                        owasp_category="A6:2017-Security Misconfiguration",
                        remediation="Always specify and validate schema and keys in GSettings.",
                    )
        except Exception:
            pass

    def _check_unprotected_window_embedding(self, py_file: Path):
        """
        Gtk.Plug/Gtk.Socket вызывается без проверки id/window_id/socket_id.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.(Plug|Socket)\(([^)]*)\)", content):
                # Проверяем отсутствие проверки идентификатора
                if not re.search(r"id|window_id|socket_id", m.group(1)):
                    self.add_issue(
                        issue_type="Unprotected Window Embedding",
                        severity="high",
                        description="Gtk.Plug/Socket used without ID validation. May allow UI spoofing.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-290",
                        owasp_category="A1:2017-Injection",
                        remediation="Always validate window/socket IDs when embedding windows.",
                    )
        except Exception:
            pass

    def _check_insecure_clipboard_format_handling(self, py_file: Path):
        """
        Clipboard используется без wait_for_targets/get_targets.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.Clipboard\.get\([^)]+\)", content):
                # Проверяем mime-типы
                if not re.search(r"wait_for_targets|get_targets", content):
                    self.add_issue(
                        issue_type="Insecure Clipboard Format Handling",
                        severity="medium",
                        description="Clipboard used without mime type validation. May allow XSS/RCE via clipboard.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-184",
                        owasp_category="A3:2017-Sensitive Data Exposure",
                        remediation="Always validate clipboard data formats and mime types.",
                    )
        except Exception:
            pass

    def _check_gtkbuilder_dynamic_loading(self, py_file: Path):
        """
        Gtk.Builder.add_from_file/add_from_string вызывается с динамическим или внешним путём (например, /tmp, http, ftp, file://).
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.Builder\.(add_from_file|add_from_string)\(([^)]*)\)", content):
                arg = m.group(2)
                # Если путь не строковый литерал или содержит suspicious path
                if not re.match(r"\s*['\"]", arg) or re.search(r"/tmp|http|ftp|file://", arg):
                    self.add_issue(
                        issue_type="GtkBuilder Dynamic Loading",
                        severity="critical",
                        description="Gtk.Builder loads UI from dynamic or untrusted source. May allow RCE/UI spoofing.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-94",
                        owasp_category="A1:2017-Injection",
                        remediation="Do not load UI from untrusted or dynamic sources in Gtk.Builder.",
                    )
        except Exception:
            pass

    def _check_aboutdialog_disclosure(self, py_file: Path):
        """
        В поля AboutDialog подставляются переменные окружения, пользовательские данные, токены и т.д.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.AboutDialog\(([^)]*)\)", content):
                if re.search(r"os\.environ|user|token|password|secret", m.group(1), re.IGNORECASE):
                    self.add_issue(
                        issue_type="AboutDialog Disclosure",
                        severity="medium",
                        description="Sensitive or user data used in AboutDialog fields.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-200",
                        owasp_category="A3:2017-Sensitive Data Exposure",
                        remediation="Do not use sensitive/user data in AboutDialog fields.",
                    )
        except Exception:
            pass

    def _check_entry_set_visibility(self, py_file: Path):
        """
        Gtk.Entry используется для пароля, но set_visibility(False) не вызывается.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.Entry\(([^)]*)\)", content):
                # Проверяем, что set_visibility(False) не вызывается
                entry_var = re.search(r'(\w+)', m.group(0))
                if entry_var:
                    var = entry_var.group(1)
                    if not re.search(rf"{var}\.set_visibility\(False\)", content):
                        self.add_issue(
                            issue_type="Entry.set_visibility Disclosure",
                            severity="high",
                            description="Gtk.Entry used for password input without set_visibility(False).",
                            file_path=str(py_file),
                            line_number=self._find_line(content, m.start()),
                            code_snippet=m.group(0),
                            confidence="HIGH",
                            cwe_id="CWE-522",
                            owasp_category="A3:2017-Sensitive Data Exposure",
                            remediation="Always call set_visibility(False) for password fields.",
                        )
        except Exception:
            pass

    def _check_sensitive_data_in_window_titles(self, py_file: Path):
        """
        set_title вызывается с переменной, содержащей токен, пароль, email и т.д.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"set_title\(([^)]*)\)", content):
                if re.search(r"token|password|secret|user|email", m.group(1), re.IGNORECASE):
                    self.add_issue(
                        issue_type="Sensitive Data in Window Title",
                        severity="medium",
                        description="Sensitive data used in window title.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-200",
                        owasp_category="A3:2017-Sensitive Data Exposure",
                        remediation="Never display sensitive data in window titles.",
                    )
        except Exception:
            pass

    def _check_printoperation_injection(self, py_file: Path):
        """
        В PrintOperation передаются данные пользователя напрямую.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.PrintOperation\(([^)]*)\)", content):
                if re.search(r"user|input|data|text", m.group(1), re.IGNORECASE):
                    self.add_issue(
                        issue_type="PrintOperation Injection",
                        severity="medium",
                        description="User data passed to PrintOperation without sanitization.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-74",
                        owasp_category="A1:2017-Injection",
                        remediation="Sanitize all user data before printing.",
                    )
        except Exception:
            pass

    def _check_revealer_sensitive_data(self, py_file: Path):
        """
        Revealer скрывает данные, но не очищает их из памяти/UI.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.Revealer\(([^)]*)\)", content):
                revealer_var = re.search(r'(\w+)', m.group(0))
                if revealer_var:
                    var = revealer_var.group(1)
                    # Проверяем, что при скрытии вызывается очистка
                    if re.search(rf"{var}\.set_reveal_child\(False\)", content) and not re.search(rf"{var}\.set_text\(['\"]?['\"]?\)", content):
                        self.add_issue(
                            issue_type="Revealer Sensitive Data",
                            severity="medium",
                            description="Sensitive data remains in Revealer after hiding.",
                            file_path=str(py_file),
                            line_number=self._find_line(content, m.start()),
                            code_snippet=m.group(0),
                            confidence="MEDIUM",
                            cwe_id="CWE-200",
                            owasp_category="A3:2017-Sensitive Data Exposure",
                            remediation="Clear sensitive data from Revealer when hiding.",
                        )
        except Exception:
            pass

    def _check_textbuffer_injection(self, py_file: Path):
        """
        set_text вызывается с переменной, а не строковым литералом.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.TextBuffer\(([^)]*)\)", content):
                buffer_var = re.search(r'(\w+)', m.group(0))
                if buffer_var:
                    var = buffer_var.group(1)
                    if re.search(rf"{var}\.set_text\(([^)]*)\)", content):
                        arg = re.search(rf"{var}\.set_text\(([^)]*)\)", content).group(1)
                        if not re.match(r"\s*['\"]", arg):
                            self.add_issue(
                                issue_type="TextBuffer Injection",
                                severity="medium",
                                description="User data inserted into TextBuffer without sanitization.",
                                file_path=str(py_file),
                                line_number=self._find_line(content, m.start()),
                                code_snippet=m.group(0),
                                confidence="MEDIUM",
                                cwe_id="CWE-79",
                                owasp_category="A7:2017-XSS",
                                remediation="Sanitize all user data before inserting into TextBuffer.",
                            )
        except Exception:
            pass

    def _check_accelgroup_key_hijacking(self, py_file: Path):
        """
        В AccelGroup добавляются клавиши, полученные от пользователя или из переменных.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.AccelGroup\(([^)]*)\)", content):
                if re.search(r"user|input|custom|dynamic", m.group(1), re.IGNORECASE):
                    self.add_issue(
                        issue_type="AccelGroup Key Hijacking",
                        severity="medium",
                        description="User-controlled or dynamic key added to AccelGroup.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-284",
                        owasp_category="A5:2017-Broken Access Control",
                        remediation="Do not add user-controlled keys to AccelGroup.",
                    )
        except Exception:
            pass

    def _check_messagedialog_injection(self, py_file: Path):
        """
        В MessageDialog передаются данные пользователя напрямую.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.MessageDialog\(([^)]*)\)", content):
                if re.search(r"user|input|data|text", m.group(1), re.IGNORECASE):
                    self.add_issue(
                        issue_type="MessageDialog Injection",
                        severity="medium",
                        description="User data passed to MessageDialog without sanitization.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-79",
                        owasp_category="A7:2017-XSS",
                        remediation="Sanitize all user data before displaying in MessageDialog.",
                    )
        except Exception:
            pass

    def _check_filesystemmodel_traversal(self, py_file: Path):
        """
        FileSystemModel вызывается с переменной, содержащей путь от пользователя.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.FileSystemModel\(([^)]*)\)", content):
                if re.search(r"user|input|data|path", m.group(1), re.IGNORECASE):
                    self.add_issue(
                        issue_type="FileSystemModel Traversal",
                        severity="high",
                        description="User-controlled path used in FileSystemModel. May allow directory traversal.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="HIGH",
                        cwe_id="CWE-22",
                        owasp_category="A5:2017-Broken Access Control",
                        remediation="Validate and sanitize all paths used in FileSystemModel.",
                    )
        except Exception:
            pass

    def _check_menu_injection(self, py_file: Path):
        """
        Menu/MenuItem создаётся с текстом, полученным от пользователя.
        """
        try:
            with open(py_file, "r", encoding="utf-8", errors="ignore") as f:
                content = f.read()
            for m in re.finditer(r"Gtk\.(Menu|MenuItem)\(([^)]*)\)", content):
                if re.search(r"user|input|data|text", m.group(2), re.IGNORECASE):
                    self.add_issue(
                        issue_type="Menu Injection",
                        severity="medium",
                        description="User data used in menu item without sanitization.",
                        file_path=str(py_file),
                        line_number=self._find_line(content, m.start()),
                        code_snippet=m.group(0),
                        confidence="MEDIUM",
                        cwe_id="CWE-79",
                        owasp_category="A7:2017-XSS",
                        remediation="Sanitize all user data before adding to menu items.",
                    )
        except Exception:
            pass

    def _find_line(self, content: str, pos: int) -> int:
        # Определить номер строки по позиции
        return content[:pos].count("\n") + 1
