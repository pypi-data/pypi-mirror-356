import lief
import numpy as np
import torch
from secml_malware.utils.pe_operations import create_int_list_from_x_adv
from secml.settings import SECML_PYTORCH_USE_CUDA

from secml_malware.attack.whitebox.c_discretized_bytes_evasion import CDiscreteBytesEvasion
from secml_malware.models import CClassifierEnd2EndMalware

use_cuda = torch.cuda.is_available() and SECML_PYTORCH_USE_CUDA


class CSlackEvasion(CDiscreteBytesEvasion):
    """Creates the attack that perturbs the slack's sections of a Windows PE malware."""

    def __init__(
        self,
        end2end_model: CClassifierEnd2EndMalware,
        iterations: int = 100,
        is_debug: bool = False,
        random_init: bool = False,
        threshold: float = 0,
        penalty_regularizer: int = 0
    ):
        """
        Creates the evasion object.

        Parameters
        ----------
        end2end_model : CClassifierEnd2EndMalware
            the target end-to-end model
        iterations : int, optional, default 100
            the number of iterations of the optimizer
        is_debug : bool, optional, default False
            if True, prints debug information during the optimization
        random_init : bool, optional, default False
            if True, it randomizes the locations set by index_to_perturb before starting the optimization
        threshold : float, optional, default 0
            the detection threshold to bypass. Default is 0
        penalty_regularizer : float
            the regularization parameter, Default is 0
        """

        super(CSlackEvasion, self).__init__(
            end2end_model,
            index_to_perturb=[],
            iterations=iterations,
            is_debug=is_debug,
            random_init=random_init,
            threshold=threshold,
            penalty_regularizer=penalty_regularizer
        )

    def _run(self, x0, y0, x_init=None):
        self.indexes_to_perturb = self._create_slack_indexes(x0)
        return super()._run(x0, y0, x_init=x_init)

    def _create_slack_indexes(self, x0):
        x_bytes = create_int_list_from_x_adv(
            x0,
            self.classifier.get_embedding_value(),
            self.classifier.get_is_shifting_values()
        )
        try:
            liefpe = lief.PE.parse(x_bytes)
        except:
            return []
        window_input_length = self.classifier.get_input_max_length()
        all_slack_space = []
        for s in liefpe.sections:
            if s.size > s.virtual_size:
                all_slack_space.extend(list(range(
                    min(window_input_length, s.offset + s.virtual_size),
                    min(window_input_length, s.offset + s.size)
                )))
        return all_slack_space
