# Copyright (c) 2024-2025 Graham R King
# Licensed under the MIT License. See LICENSE file for details.
from __future__ import annotations

import textwrap
from copy import deepcopy
from pathlib import Path


class TypeHinter:
    INDENT_UNITS = 4

    HEADERS = (
        "# DO NOT EDIT this file, it is automatically generated.",
        "# ",
        "# This file is only used as a code completion helper",
        "# for editors, it is not used at runtime.",
        "from __future__ import annotations",
        "from typing import TypeAlias, Annotated",
        "from enum import Enum, IntFlag",
        "from wayland.baseobject import WaylandEvent",
        "new_id: TypeAlias = int",
        "fd: TypeAlias = int",
        "",
    )

    def __init__(self, overrides_dir: str = "docs/.overrides/typehints"):
        self.overrides_dir = Path(overrides_dir)

    def create_type_hinting(self, structure: dict, path: str) -> None:
        file_name = f"{path}/__init__.pyi"
        headers = [line + "\n" for line in self.HEADERS]
        class_definitions = []

        for class_name, details in structure.items():
            class_declaration = self._create_class_declaration(class_name, details)
            class_body = self._create_class_body(class_name, details)
            class_definitions.append(class_declaration + class_body)

        with open(file_name, "w", encoding="utf-8") as outfile:
            outfile.writelines(headers + class_definitions)

    def _load_override_content(self, interface_name: str) -> str:
        """Load override content for the given interface name."""
        override_file = self.overrides_dir / f"{interface_name}.txt"
        if override_file.exists():
            return override_file.read_text(encoding="utf-8")
        return ""

    def _create_class_declaration(self, class_name: str, details: dict) -> str:
        declaration = f"class {class_name}:\n"
        declaration += self.indent(details["description"], 1, comment=True)
        declaration += self._pad("object_id = 0\n", 1)
        declaration += self._pad(f"version = {details['version']}\n\n", 1)
        return declaration

    def _create_class_body(self, class_name: str, details: dict) -> str:
        body = []
        body.append(self.process_enums(details.get("enums", [])))
        body.append(self.process_members(class_name, details.get("requests", [])))

        # Add on_* event handler stubs
        event_handlers = self.process_event_handlers(
            class_name, details.get("events", [])
        )
        if event_handlers:
            body.append(event_handlers)

        override_content = self._load_override_content(class_name)
        if override_content:
            body.append(override_content)

        events = self.process_members(
            class_name, details.get("events", []), events=True
        )
        if events:
            body.append(self._pad("class events(WaylandEvent):\n" + events, 1))

        return "\n".join(body) + "\n"

    def process_members(
        self, class_name: str, members: list[dict], *, events: bool = False
    ) -> str:
        indent_level = 2 if events else 1

        definitions = []

        for member in members:
            new_args, return_type = self._process_args(
                class_name, member["args"], events
            )

            docstring = self._create_docstring(member, new_args, return_type)
            arg_list = ", ".join(f"{arg['name']}: {arg['type']}" for arg in new_args)
            arg_list = f"self, {arg_list}" if arg_list else "self"
            signature = [
                self._pad(
                    f"def {member['name']}({arg_list}) -> {return_type or 'None'}:",
                    indent_level,
                ),
                self.indent(docstring, indent_level + 1),
                self._pad("...", indent_level + 1),
            ]

            definitions.append("\n".join(signature) + "\n")

        return "\n".join(definitions)

    def _process_args(
        self, class_name: str, args: list[dict], events: bool
    ) -> tuple[list[dict], str | None]:
        new_args = []
        return_type = None

        for arg in deepcopy(args):
            processed_return_type = self._process_single_arg(arg, class_name, events)
            if processed_return_type:
                return_type = processed_return_type
                continue
            new_args.append(arg)

        return new_args, return_type

    def _process_single_arg(
        self, arg: dict, class_name: str, events: bool
    ) -> str | None:
        if arg["type"] == "new_id":
            return self._handle_new_id_type(arg, events)

        if arg["type"] == "object" and arg.get("interface"):
            arg["type"] = arg["interface"]
        elif arg.get("enum"):
            self._handle_enum_type(arg, class_name)
        else:
            self._apply_simple_type_mapping(arg)

        return None

    def _handle_new_id_type(self, arg: dict, events: bool) -> str | None:
        interface = arg.get("interface")
        if interface and not events:
            return interface
        if interface and events:
            arg["type"] = interface
        return None

    def _handle_enum_type(self, arg: dict, class_name: str) -> None:
        enum_ref = arg["enum"]
        if "." in enum_ref:
            arg["type"] = enum_ref
        else:
            arg["type"] = f"{class_name}.{enum_ref}"

    def _apply_simple_type_mapping(self, arg: dict) -> None:
        type_mapping = {
            "string": "str",
            "fixed": "float",
            "uint": "int",
            "array": "list",
        }
        if arg["type"] in type_mapping:
            arg["type"] = type_mapping[arg["type"]]

    def _create_docstring(
        self, member: dict, args: list[dict], return_type: str | None
    ) -> str:
        docstring_parts = []

        if member.get("description"):
            docstring_parts.append(member["description"])

        args_with_descriptions = [arg for arg in args if arg.get("description")]
        if args_with_descriptions:
            docstring_parts.append("")
            docstring_parts.append("Args:")
            for arg in args_with_descriptions:
                arg_desc = arg["description"].strip()
                if arg_desc:
                    docstring_parts.append(self._pad(f"{arg['name']}: {arg_desc}", 1))

        if return_type:
            docstring_parts.append("")
            docstring_parts.append("Returns:")
            docstring_parts.append(self._pad(f"{return_type}: The created object", 1))

        return "\n".join(docstring_parts) if docstring_parts else ""

    def process_enums(self, members: list[dict]) -> str:
        indent_level = 1

        definitions = []

        for member in members:
            enum_name = member["name"]
            enum_type = "IntFlag" if member.get("bitfield") else "Enum"

            signature = [self._pad(f"class {enum_name}({enum_type}):", indent_level)]
            if member.get("description"):
                signature.append(self.indent(member["description"], indent_level + 1))

            for arg in member["args"]:
                value_name = arg["name"]
                try:
                    int(value_name)
                    value_name = f"{enum_name}_{value_name}"
                except ValueError:
                    pass
                signature.append(self._pad(f"{value_name}: int", indent_level + 1))
                if arg.get("description"):
                    comment_lines = [
                        f"{line.strip()}"
                        for line in arg["description"].splitlines()
                        if line.strip()
                    ]
                    if comment_lines:
                        comment_block = "\n".join(comment_lines)
                        signature.append(
                            self.indent(comment_block, indent_level + 1, comment=True)
                        )

            definitions.append("\n".join(signature) + "\n\n")

        return "\n".join(definitions)

    @classmethod
    def _pad(cls, astring: str, amount: int):
        return (" " * (cls.INDENT_UNITS * amount)) + astring

    @classmethod
    def indent(
        cls, input_string: str, indent_level: int, *, comment: bool = True
    ) -> str:
        indent_str = cls._pad("", indent_level)
        if comment:
            if "\n" in input_string.strip():
                input_string = f'"""\n{input_string}\n"""\n'
            else:
                # Single line doc comment
                input_string = f'"""{input_string}"""\n'

        return textwrap.indent(input_string, indent_str)

    def process_event_handlers(self, class_name: str, events: list[dict]) -> str:
        """Generate on_* method stubs with summary line from event descriptions"""
        definitions = []

        for event in events:
            method_name = f"on_{event['name']}"
            event_name = event["name"]
            new_args, _ = self._process_args(class_name, event["args"], events=True)

            arg_list = ", ".join(f"{arg['name']}: {arg['type']}" for arg in new_args)
            arg_list = f"self, {arg_list}" if arg_list else "self"

            # Extract first line of description
            description = event.get("description", "").strip()
            if description:
                first_line = description.split("\n")[0].strip()
                if first_line:
                    first_line = f"{first_line}."
                # Build docstring with summary + reference
                ref_link = f"[`wayland.{class_name}.events.{event_name}`][]"
                docstring = f"{first_line}\n\nOverride to handle {ref_link}."
            else:
                # Fallback if no description
                ref_link = f"[`wayland.{class_name}.events.{event_name}`][]"
                docstring = f"Override to handle {ref_link}"

            definitions.append(self._pad(f"def {method_name}({arg_list}) -> None:", 1))
            definitions.append(self.indent(docstring, 2, comment=True))
            definitions.append(self._pad("...", 2))
            definitions.append("")

        return "\n".join(definitions)
